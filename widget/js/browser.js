var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var res = mod._cached ? mod._cached : mod();
    return res;
}

require.paths = [];
require.modules = {};
require.extensions = [".js",".coffee"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = x + '/package.json';
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

require.define = function (filename, fn) {
    var dirname = require._core[filename]
        ? ''
        : require.modules.path().dirname(filename)
    ;
    
    var require_ = function (file) {
        return require(file, dirname)
    };
    require_.resolve = function (name) {
        return require.resolve(name, dirname);
    };
    require_.modules = require.modules;
    require_.define = require.define;
    var module_ = { exports : {} };
    
    require.modules[filename] = function () {
        require.modules[filename]._cached = module_.exports;
        fn.call(
            module_.exports,
            require_,
            module_,
            module_.exports,
            dirname,
            filename
        );
        require.modules[filename]._cached = module_.exports;
        return module_.exports;
    };
};

if (typeof process === 'undefined') process = {};

if (!process.nextTick) process.nextTick = (function () {
    var queue = [];
    var canPost = typeof window !== 'undefined'
        && window.postMessage && window.addEventListener
    ;
    
    if (canPost) {
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'browserify-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);
    }
    
    return function (fn) {
        if (canPost) {
            queue.push(fn);
            window.postMessage('browserify-tick', '*');
        }
        else setTimeout(fn, 0);
    };
})();

if (!process.title) process.title = 'browser';

if (!process.binding) process.binding = function (name) {
    if (name === 'evals') return require('vm')
    else throw new Error('No such module')
};

if (!process.cwd) process.cwd = function () { return '.' };

if (!process.env) process.env = {};
if (!process.argv) process.argv = [];

require.define("path", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\n//@ sourceURL=path"
));

require.define("/jsmm/index.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/*jshint node:true*/\n\"use strict\";\n\nvar jsmm = {};\njsmm.verbose = false;\n\nrequire('./jsmm.base')(jsmm);\nrequire('./jsmm.parser')(jsmm);\nrequire('./jsmm.safe')(jsmm);\nrequire('./jsmm.step')(jsmm);\nrequire('./jsmm.dot')(jsmm);\nrequire('./jsmm.simple.runner')(jsmm);\nrequire('./jsmm.static.runner')(jsmm);\nrequire('./jsmm.test')(jsmm);\nrequire('./jsmm.editor')(jsmm);\n\nmodule.exports = jsmm;\n//@ sourceURL=/jsmm/index.js"
));

require.define("/jsmm/jsmm.base.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/*jshint node:true*/\n\"use strict\";\n\nmodule.exports = function(jsmm) {\n\tjsmm.Tree = function() { return this.init.apply(this, arguments); };\n\n\tjsmm.nodes = {};\n\tjsmm.nodes.Program = function() { return this.build.apply(this, arguments); };\n\tjsmm.nodes.StatementList = function() { return this.build.apply(this, arguments); };\n\tjsmm.nodes.CommonSimpleStatement = function() { return this.build.apply(this, arguments); };\n\tjsmm.nodes.PostfixStatement = function() { return this.build.apply(this, arguments); };\n\tjsmm.nodes.AssignmentStatement = function() { return this.build.apply(this, arguments); };\n\tjsmm.nodes.VarStatement = function() { return this.build.apply(this, arguments); };\n\tjsmm.nodes.VarItem = function() { return this.build.apply(this, arguments); };\n\tjsmm.nodes.ReturnStatement = function() { return this.build.apply(this, arguments); };\n\tjsmm.nodes.BinaryExpression = function() { return this.build.apply(this, arguments); };\n\tjsmm.nodes.UnaryExpression = function() { return this.build.apply(this, arguments); };\n\tjsmm.nodes.NumberLiteral = function() { return this.build.apply(this, arguments); };\n\tjsmm.nodes.StringLiteral = function() { return this.build.apply(this, arguments); };\n\tjsmm.nodes.BooleanLiteral = function() { return this.build.apply(this, arguments); };\n\tjsmm.nodes.NameIdentifier = function() { return this.build.apply(this, arguments); };\n\tjsmm.nodes.ObjectIdentifier = function() { return this.build.apply(this, arguments); };\n\tjsmm.nodes.ArrayIdentifier = function() { return this.build.apply(this, arguments); };\n\tjsmm.nodes.FunctionCall = function() { return this.build.apply(this, arguments); };\n\tjsmm.nodes.CallStatement = function() { return this.build.apply(this, arguments); };\n\tjsmm.nodes.IfBlock = function() { return this.build.apply(this, arguments); };\n\tjsmm.nodes.ElseIfBlock = function() { return this.build.apply(this, arguments); };\n\tjsmm.nodes.ElseBlock = function() { return this.build.apply(this, arguments); };\n\tjsmm.nodes.WhileBlock = function() { return this.build.apply(this, arguments); };\n\tjsmm.nodes.ForBlock = function() { return this.build.apply(this, arguments); };\n\tjsmm.nodes.FunctionDeclaration = function() { return this.build.apply(this, arguments); };\n\n\tjsmm.Tree.prototype = {\n\t\tinit: function(code) {\n\t\t\tthis.genId = 0;\n\t\t\tthis.nodes = [];\n\t\t\t//this.code = code;\n\t\t\tthis.nodesByType = { Program: [], StatementList: [], CommonSimpleStatement: [], PostfixStatement: [],\n\t\t\t\tAssignmentStatement: [], VarStatement: [], VarItem: [], ReturnStatement: [], BinaryExpression: [],\n\t\t\t\tUnaryExpression: [], NumberLiteral: [], StringLiteral: [], BooleanLiteral: [], NameIdentifier: [],\n\t\t\t\tObjectIdentifier: [], ArrayIdentifier: [], FunctionCall: [], CallStatement: [], IfBlock: [], ElseIfBlock: [],\n\t\t\t\tElseBlock: [], WhileBlock: [], ForBlock: [], FunctionDeclaration: []\n\t\t\t};\n\t\t\tthis.nodesByLine = [];\n\t\t\tthis.nodesWithHook = [];\n\t\t\tthis.error = null;\n\t\t\tjsmm.parser.yy.tree = this;\n\t\t\ttry {\n\t\t\t\tthis.programNode = jsmm.parser.parse(code + \"\\n\");\n\t\t\t} catch (error) {\n\t\t\t\tif (error instanceof jsmm.msg.Error) {\n\t\t\t\t\tthis.error = error;\n\t\t\t\t} else {\n\t\t\t\t\t//throw error;\n\t\t\t\t\tthis.error = new jsmm.msg.Error({}, 'An unknown error has occurred', '', error);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\thasError: function() {\n\t\t\treturn this.error !== null;\n\t\t},\n\t\tgetError: function() {\n\t\t\treturn this.error;\n\t\t},\n\t\tgetNewId: function() {\n\t\t\treturn this.genId++;\n\t\t},\n\t\tgetNodeByLine: function(line) {\n\t\t\tif (this.nodesByLine[line] === undefined) return null;\n\t\t\telse return this.nodesByLine[line];\n\t\t},\n\t\tgetNodesByType: function(type) {\n\t\t\treturn this.nodesByType[type];\n\t\t},\n\t\taddHookBeforeNode: function(node, func) {\n\t\t\tif (node.hooksBefore === undefined) {\n\t\t\t\tthrow new Error('Trying to add a hook to an unhookable node');\n\t\t\t} else {\n\t\t\t\tnode.hooksBefore.push(func);\n\t\t\t\tthis.nodesWithHook.push(node);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t\taddHookAfterNode: function(node, func) {\n\t\t\tif (node.hooksAfter === undefined) {\n\t\t\t\tthrow new Error('Trying to add a hook to an unhookable node');\n\t\t\t} else {\n\t\t\t\tnode.hooksAfter.push(func);\n\t\t\t\tthis.nodesWithHook.push(node);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t\tclearHooks: function() {\n\t\t\tfor (var i=0; i<this.nodesWithHook.length; i++) {\n\t\t\t\tthis.nodesWithHook[i].hooksBefore = [];\n\t\t\t\tthis.nodesWithHook[i].hooksAfter = [];\n\t\t\t}\n\t\t\tthis.nodesWithHook = [];\n\t\t}\n\t};\n\n\tjsmm.addCommonNodeMethods = function(type, node) {\n\t\tnode.build = function(_$, column2) {\n\t\t\tthis.tree = jsmm.parser.yy.tree;\n\t\t\tthis.id = this.tree.getNewId();\n\t\t\tthis.tree.nodes[this.id] = this;\n\t\t\tthis.tree.nodesByType[type].push(this);\n\t\t\tthis.type = type;\n\t\t\tthis.lineLoc = {line: _$.first_line, column: _$.first_column, column2 : (column2 || _$.last_column)};\n\t\t\tthis.blockLoc = {line: _$.first_line, line2: _$.last_line};\n\t\t\tthis.textLoc = {line: _$.first_line, column: _$.first_column, line2: _$.last_line, column2: _$.last_column};\n\t\t\tthis.parent = null;\n\t\t\tthis.init.apply(this, [].slice.call(arguments, 2));\n\t\t};\n\t\tnode.runHooksBefore = function(scope) {\n\t\t\tif (this.hooksBefore === undefined) throw new Error('runHooksBefore on unhookable node');\n\t\t\tfor (var i=0; i<this.hooksBefore.length; i++) {\n\t\t\t\tthis.hooksBefore[i](this, scope);\n\t\t\t}\n\t\t};\n\t\tnode.runHooksAfter = function(scope) {\n\t\t\tif (this.hooksAfter === undefined) throw new Error('runHooksAfter on unhookable node');\n\t\t\tfor (var i=0; i<this.hooksAfter.length; i++) {\n\t\t\t\tthis.hooksAfter[i](this, scope);\n\t\t\t}\n\t\t};\n\t\treturn node;\n\t};\n\n\tjsmm.nodes.Program.prototype = jsmm.addCommonNodeMethods('Program', {\n\t\tinit: function(statementList) {\n\t\t\tthis.statementList = statementList;\n\t\t\tstatementList.parent = this;\n\t\t},\n\t\tgetCode: function() {\n\t\t\treturn this.statementList.getCode();\n\t\t},\n\t\tgetFunction: function(scope) {\n\t\t\t/*jshint evil:true*/\n\t\t\tvar args = [jsmm];\n\t\t\tvar output = 'new function() {';\n\t\t\toutput += 'return function(jsmm';\n\t\t\tfor (var name in scope) {\n\t\t\t\toutput += ', ' + name;\n\t\t\t\targs.push(scope[name]);\n\t\t\t}\n\t\t\toutput += ') { return function() { \\n';\n\t\t\toutput += this.statementList.getCode() + 'return; }; }; }';\n\t\t\t//console.log(output);\n\t\t\treturn eval(output).apply(null, args);\n\t\t}\n\t});\n\n\tjsmm.nodes.StatementList.prototype = jsmm.addCommonNodeMethods('StatementList', {\n\t\tinit: function() {\n\t\t\tthis.statements = [];\n\t\t},\n\t\taddStatement: function(statement) {\n\t\t\tthis.statements.push(statement);\n\t\t\tstatement.parent = this;\n\t\t},\n\t\tgetCode: function() {\n\t\t\tvar output = \"\";\n\t\t\tfor (var i=0; i<this.statements.length; i++) {\n\t\t\t\toutput += this.statements[i].getCode() + \"\\n\";\n\t\t\t}\n\t\t\treturn output;\n\t\t},\n\t\tgetChildren: function() {\n\t\t\treturn this.statements;\n\t\t}\n\t});\n\n\tjsmm.nodes.CommonSimpleStatement.prototype = jsmm.addCommonNodeMethods('CommonSimpleStatement', {\n\t\tinit: function(statement) {\n\t\t\tthis.statement = statement;\n\t\t\tstatement.parent = this;\n\t\t\tthis.tree.nodesByLine[this.lineLoc.line] = this;\n\t\t\tthis.hooksBefore = [];\n\t\t\tthis.hooksAfter = [];\n\t\t\t//console.log(this);\n\t\t},\n\t\tgetCode: function() {\n\t\t\treturn this.statement.getCode() + \";\";\n\t\t},\n\t\tgetChildren: function() {\n\t\t\treturn [this.statement];\n\t\t}\n\t});\n\n\tjsmm.nodes.PostfixStatement.prototype = jsmm.addCommonNodeMethods('PostfixStatement', {\n\t\tinit: function(identifier, symbol) {\n\t\t\tthis.identifier = identifier;\n\t\t\tthis.symbol = symbol;\n\t\t\tidentifier.parent = this;\n\t\t\tsymbol.parent = this;\n\t\t},\n\t\tgetCode: function() {\n\t\t\treturn this.identifier.getCode() + this.symbol;\n\t\t},\n\t\tgetChildren: function() {\n\t\t\treturn [this.identifier];\n\t\t}\n\t});\n\n\tjsmm.nodes.AssignmentStatement.prototype = jsmm.addCommonNodeMethods('AssignmentStatement', {\n\t\tinit: function(identifier, symbol, expression) {\n\t\t\tthis.identifier = identifier;\n\t\t\tthis.symbol = symbol;\n\t\t\tthis.expression = expression;\n\t\t\tidentifier.parent = this;\n\t\t\texpression.parent = this;\n\t\t},\n\t\tgetCode: function() {\n\t\t\treturn this.identifier.getCode() + \" \" + this.symbol + \" \" + this.expression.getCode();\n\t\t},\n\t\tgetChildren: function() {\n\t\t\treturn [this.identifier, this.expression];\n\t\t}\n\t});\n\n\tjsmm.nodes.VarStatement.prototype = jsmm.addCommonNodeMethods('VarStatement', {\n\t\tinit: function() {\n\t\t\tthis.items = [];\n\t\t},\n\t\taddVarItem: function(item) {\n\t\t\tthis.items.push(item);\n\t\t\titem.parent = this;\n\t\t},\n\t\tgetCode: function() {\n\t\t\tvar output = \"var \" + this.items[0].getCode();\n\t\t\tfor (var i=1; i<this.items.length; i++) {\n\t\t\t\toutput += \", \" + this.items[i].getCode();\n\t\t\t}\n\t\t\treturn output;\n\t\t},\n\t\tgetChildren: function() {\n\t\t\treturn this.items;\n\t\t}\n\t});\n\n\tjsmm.nodes.VarItem.prototype = jsmm.addCommonNodeMethods('VarItem', {\n\t\tinit: function(name, assignment) {\n\t\t\tthis.name = name;\n\t\t\tthis.assignment = assignment;\n\t\t\tif (assignment !== null) assignment.parent = this;\n\t\t},\n\t\tgetCode: function() {\n\t\t\tif (this.assignment === null) {\n\t\t\t\treturn this.name;\n\t\t\t} else {\n\t\t\t\treturn this.assignment.getCode();\n\t\t\t}\n\t\t},\n\t\tgetChildren: function() {\n\t\t\treturn [this.assignment];\n\t\t}\n\t});\n\n\tjsmm.nodes.ReturnStatement.prototype = jsmm.addCommonNodeMethods('ReturnStatement', {\n\t\tinit: function(expression) {\n\t\t\tthis.expression = expression;\n\t\t\texpression.parent = this;\n\t\t\tthis.tree.nodesByLine[this.lineLoc.line] = this;\n\t\t\tthis.hooksBefore = [];\n\t\t\tthis.hooksAfter = [];\n\t\t},\n\t\tgetCode: function() {\n\t\t\tif (this.expression === null) {\n\t\t\t\treturn \"return;\";\n\t\t\t} else {\n\t\t\t\treturn \"return \" + this.expression.getCode() + \";\";\n\t\t\t}\n\t\t},\n\t\titerateRunHooksAfter: function(scope) {\n\t\t\tvar node = this;\n\t\t\twhile (!(node.type === 'Program' || node.type === 'FunctionDeclaration')) {\n\t\t\t\tif (node.hooksAfter !== undefined) node.runHooksAfter(scope);\n\t\t\t\tnode = node.parent;\n\t\t\t}\n\t\t\tif (node.hooksAfter !== undefined) node.runHooksAfter(scope);\n\t\t}\n\t});\n\n\tjsmm.nodes.BinaryExpression.prototype = jsmm.addCommonNodeMethods('BinaryExpression', {\n\t\tinit: function(expression1, symbol, expression2) {\n\t\t\tthis.expression1 = expression1;\n\t\t\tthis.symbol = symbol;\n\t\t\tthis.expression2 = expression2;\n\t\t\texpression1.parent = this;\n\t\t\texpression2.parent = this;\n\t\t},\n\t\tgetCode: function() {\n\t\t\treturn \"(\" + this.expression1.getCode() + this.symbol + this.expression2.getCode() + \")\";\n\t\t}\n\t});\n\n\tjsmm.nodes.UnaryExpression.prototype = jsmm.addCommonNodeMethods('UnaryExpression', {\n\t\tinit: function(symbol, expression) {\n\t\t\tthis.symbol = symbol;\n\t\t\tthis.expression = expression;\n\t\t\texpression.parent = this;\n\t\t},\n\t\tgetCode: function() {\n\t\t\treturn \"(\" + this.symbol + this.expression.getCode() + \")\";\n\t\t}\n\t});\n\n\tjsmm.nodes.NumberLiteral.prototype = jsmm.addCommonNodeMethods('NumberLiteral', {\n\t\tinit: function(number) {\n\t\t\tthis.number = parseFloat(number);\n\t\t},\n\t\tgetCode: function() {\n\t\t\treturn this.number;\n\t\t}\n\t});\n\n\tjsmm.nodes.StringLiteral.prototype = jsmm.addCommonNodeMethods('StringLiteral', {\n\t\tinit: function(str) {\n\t\t\tthis.str = JSON.parse(str);\n\t\t},\n\t\tgetCode: function() {\n\t\t\treturn JSON.stringify(this.str);\n\t\t}\n\t});\n\n\tjsmm.nodes.BooleanLiteral.prototype = jsmm.addCommonNodeMethods('BooleanLiteral', {\n\t\tinit: function(bool) {\n\t\t\tthis.bool = bool;\n\t\t},\n\t\tgetCode: function() {\n\t\t\treturn this.bool ? \"true\" : \"false\";\n\t\t}\n\t});\n\n\tjsmm.nodes.NameIdentifier.prototype = jsmm.addCommonNodeMethods('NameIdentifier', {\n\t\tinit: function(name) {\n\t\t\tthis.name = name;\n\t\t},\n\t\tgetCode: function() {\n\t\t\treturn this.name;\n\t\t}\n\t});\n\n\tjsmm.nodes.ObjectIdentifier.prototype = jsmm.addCommonNodeMethods('ObjectIdentifier', {\n\t\tinit: function(identifier, prop) {\n\t\t\tthis.identifier = identifier;\n\t\t\tthis.prop = prop;\n\t\t\tidentifier.parent = this;\n\t\t},\n\t\tgetCode: function() {\n\t\t\treturn this.identifier.getCode() + \".\" + this.prop;\n\t\t}\n\t});\n\n\tjsmm.nodes.ArrayIdentifier.prototype = jsmm.addCommonNodeMethods('ArrayIdentifier', {\n\t\tinit: function(identifier, expression) {\n\t\t\tthis.identifier = identifier;\n\t\t\tthis.expression = expression;\n\t\t\tidentifier.parent = this;\n\t\t\texpression.parent = this;\n\t\t},\n\t\tgetCode: function() {\n\t\t\treturn this.identifier.getCode() + \"[\" + this.expression.getCode() + \"]\";\n\t\t}\n\t});\n\n\tjsmm.nodes.FunctionCall.prototype = jsmm.addCommonNodeMethods('FunctionCall', {\n\t\tinit: function(identifier, expressionArgs) {\n\t\t\tthis.identifier = identifier;\n\t\t\tthis.expressionArgs = expressionArgs;\n\t\t\tidentifier.parent = this;\n\t\t\tfor (var i=0; i<this.expressionArgs.length; i++) {\n\t\t\t\texpressionArgs[i].parent = this;\n\t\t\t}\n\t\t},\n\t\tgetCode: function() {\n\t\t\tvar output = this.identifier.getCode() + \"(\";\n\t\t\tif (this.expressionArgs.length > 0) output += this.expressionArgs[0].getCode();\n\t\t\tfor (var i=1; i<this.expressionArgs.length; i++) {\n\t\t\t\toutput += \", \" + this.expressionArgs[i].getCode();\n\t\t\t}\n\t\t\treturn output + \")\";\n\t\t}\n\t});\n\n\tjsmm.nodes.CallStatement.prototype = jsmm.addCommonNodeMethods('CallStatement', {\n\t\tinit: function(functionCall) {\n\t\t\tthis.functionCall = functionCall;\n\t\t\tfunctionCall.parent = this;\n\t\t},\n\t\tgetCode: function() {\n\t\t\treturn this.functionCall.getCode();\n\t\t}\n\t});\n\n\tjsmm.nodes.IfBlock.prototype = jsmm.addCommonNodeMethods('IfBlock', {\n\t\tinit: function(expression, statementList, elseBlock) {\n\t\t\tthis.expression = expression;\n\t\t\tthis.statementList = statementList;\n\t\t\tthis.elseBlock = elseBlock;\n\t\t\texpression.parent = this;\n\t\t\tstatementList.parent = this;\n\t\t\tif (elseBlock !== null) elseBlock.parent = this;\n\t\t\tthis.tree.nodesByLine[this.lineLoc.line] = this;\n\t\t\tthis.hooksBefore = [];\n\t\t\tthis.hooksAfter = [];\n\t\t},\n\t\tgetCode: function() {\n\t\t\tvar output = \"if (\" + this.expression.getCode() + \") {\\n\" + this.statementList.getCode() + \"}\";\n\t\t\tif (this.elseBlock !== null) {\n\t\t\t\toutput += this.elseBlock.getCode();\n\t\t\t}\n\t\t\treturn output;\n\t\t}\n\t});\n\n\tjsmm.nodes.ElseIfBlock.prototype = jsmm.addCommonNodeMethods('ElseIfBlock', {\n\t\tinit: function(ifBlock) {\n\t\t\tthis.ifBlock = ifBlock;\n\t\t\tifBlock.parent = this;\n\t\t},\n\t\tgetCode: function() {\n\t\t\treturn \" else \" + this.ifBlock.getCode();\n\t\t}\n\t});\n\n\tjsmm.nodes.ElseBlock.prototype = jsmm.addCommonNodeMethods('ElseBlock', {\n\t\tinit: function(statementList) {\n\t\t\tthis.statementList = statementList;\n\t\t\tstatementList.parent = this;\n\t\t\tthis.tree.nodesByLine[this.lineLoc.line] = this;\n\t\t\tthis.hooksBefore = [];\n\t\t\tthis.hooksAfter = [];\n\t\t},\n\t\tgetCode: function() {\n\t\t\treturn \" else {\\n\" + this.statementList.getCode() + \"}\";\n\t\t}\n\t});\n\n\tjsmm.nodes.WhileBlock.prototype = jsmm.addCommonNodeMethods('WhileBlock', {\n\t\tinit: function(expression, statementList) {\n\t\t\tthis.expression = expression;\n\t\t\tthis.statementList = statementList;\n\t\t\texpression.parent = this;\n\t\t\tstatementList.parent = this;\n\t\t\tthis.tree.nodesByLine[this.lineLoc.line] = this;\n\t\t\tthis.hooksBefore = [];\n\t\t\tthis.hooksAfter = [];\n\t\t},\n\t\tgetCode: function() {\n\t\t\treturn \"while (\" + this.expression.getCode() + \") {\\n\" + this.statementList.getCode() + \"}\";\n\t\t}\n\t});\n\n\tjsmm.nodes.ForBlock.prototype = jsmm.addCommonNodeMethods('ForBlock', {\n\t\tinit: function(statement1, expression, statement2, statementList) {\n\t\t\tthis.statement1 = statement1;\n\t\t\tthis.expression = expression;\n\t\t\tthis.statement2 = statement2;\n\t\t\tthis.statementList = statementList;\n\t\t\tstatement1.parent = this;\n\t\t\texpression.parent = this;\n\t\t\tstatement2.parent = this;\n\t\t\tstatementList.parent = this;\n\t\t\tthis.tree.nodesByLine[this.lineLoc.line] = this;\n\t\t\tthis.hooksBefore = [];\n\t\t\tthis.hooksAfter = [];\n\t\t},\n\t\tgetCode: function() {\n\t\t\tvar output = \"for (\" + this.statement1.getCode() + \";\" + this.expression.getCode() + \";\";\n\t\t\toutput += this.statement2.getCode() + \") {\\n\" + this.statementList.getCode() + \"}\";\n\t\t\treturn output;\n\t\t}\n\t});\n\n\tjsmm.nodes.FunctionDeclaration.prototype = jsmm.addCommonNodeMethods('FunctionDeclaration', {\n\t\tinit: function(name, nameArgs, statementList) {\n\t\t\tthis.name = name;\n\t\t\tthis.nameArgs = nameArgs;\n\t\t\tthis.statementList = statementList;\n\t\t\tstatementList.parent = this;\n\t\t\tthis.tree.nodesByLine[this.lineLoc.line] = this;\n\t\t\tthis.hooksBefore = [];\n\t\t\tthis.hooksAfter = [];\n\t\t},\n\t\tgetArgList: function() {\n\t\t\tvar output = \"(\";\n\t\t\tif (this.nameArgs.length > 0) output += this.nameArgs[0];\n\t\t\tfor (var i=1; i<this.nameArgs.length; i++) {\n\t\t\t\toutput += ', ' + this.nameArgs[i];\n\t\t\t}\n\t\t\treturn output + \")\";\n\t\t},\n\t\tgetCode: function() {\n\t\t\tvar output = \"function \" + this.name + this.getArgList() + \"{\\n\" + this.statementList.getCode() + \"}\";\n\t\t\treturn output;\n\t\t}\n\t});\n};\n//@ sourceURL=/jsmm/jsmm.base.js"
));

require.define("/jsmm/jsmm.parser.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/*jshint node:true*/\n\"use strict\";\n\nmodule.exports = function(jsmm) {\n\tjsmm.parser = require('./jsmmparser').parser;\n\tjsmm.parser.yy = {};\n\tjsmm.parser.yy.nodes = jsmm.nodes;\n\n\t// function used by the parser to throw errors\n\t// also used below by catching tokenizer errors\n\tjsmm.parser.yy.parseError = function(errStr, hash) {\n\t\thash = hash || {};\n\t\tvar token = hash.token || '';\n\t\tvar expected = hash.expected || [];\n\t\tvar loc = {\n\t\t\tline: jsmm.parser.lexer.yylloc.first_line,\n\t\t\tcolumn: jsmm.parser.lexer.yylloc.first_column\n\t\t};\n\t\t\n\t\t// if there are no newlines, give a range instead of a single position\n\t\tif (hash.text.match(/\\n/) === null) {\n\t\t\tloc.column2 = loc.column + hash.text.length;\n\t\t}\n\t\t\n\t\t// entries are in the form \"'FOR'\", remove the extra quotes\n\t\ttoken = token.replace(/[']/g, \"\");\n\t\tfor (var i=0; i<expected.length; i++) {\n\t\t\texpected[i] = expected[i].replace(/[']/g, \"\");\n\t\t}\n\t\t\n\t\tvar makeNear = function(text, f, near) {\n\t\t\tif (text.replace(/\\s*/, '').length > 0) {\n\t\t\t\treturn (near || ' near ') + f(text);\n\t\t\t} else {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t};\n\t\t\n\t\t//console.log(hash.text);\n\t\tvar suggestionError = function(suggestion) {\n\t\t\tthrow new jsmm.msg.Error(loc, function(f) {\n\t\t\t\treturn 'Invalid syntax encountered' + makeNear(hash.text, f) + ', perhaps there is a ' + f(suggestion) + ' missing';\n\t\t\t}, errStr);\n\t\t};\n\t\t\n\t\tif (token === \"RESERVED\") {\n\t\t\t// special case: passing on the information that the word is reserved\n\t\t\tthrow new jsmm.msg.Error(loc, function(f) { return 'Unfortunately ' + f(hash.text) + ' is a reserved word, which means you cannot use it as a variable name'; }, errStr);\n\t\t} else if (hash.token === null) {\n\t\t\t// lexer error\n\t\t\tloc = {line: hash.line+1, column: 0};\n\t\t\tthrow new jsmm.msg.Error(loc, 'Invalid syntax encountered', errStr);\n\t\t} else if (expected.length === 1 && expected[0] === 'NEWLINE') {\n\t\t\tthrow new jsmm.msg.Error(loc, function(f) {\n\t\t\t\treturn 'Invalid syntax encountered, perhaps some code' + makeNear(hash.text, f) + ' should be put on a new line.';\n\t\t\t}, errStr);\n\t\t} else if (expected.length === 1) {\n\t\t\t// if only one thing can be expected, pass it on\n\t\t\tif (expected[0] === 'NAME') {\n\t\t\t\texpected[0] = 'variable name';\n\t\t\t}\n\t\t\tsuggestionError(expected[0]);\n\t\t} else if (expected.indexOf(\";\") >= 0 && token === \"NEWLINE\") {\n\t\t\t// ; expected before of newline is usually forgotten\n\t\t\tsuggestionError(';');\n\t\t} else if (expected.indexOf(\"}\") >= 0 && [\"FUNCTION\", \"EOF\"].indexOf(token) >= 0) {\n\t\t\t// } expected before function declaration or eof is usually forgotten\n\t\t\tsuggestionError('}');\n\t\t} else if (expected.indexOf(\")\") >= 0 && [\"{\", \";\", \"NEWLINE\"].indexOf(token) >= 0) {\n\t\t\t// ) expected before { or ; is usually forgotten\n\t\t\tsuggestionError(')');\n\t\t} else {\n\t\t\tthrow new jsmm.msg.Error(loc, function(f) { return 'Invalid syntax encountered' + makeNear(hash.text, f); }, errStr);\n\t\t}\n\t};\n};\n//@ sourceURL=/jsmm/jsmm.parser.js"
));

require.define("/jsmm/jsmmparser.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/* Jison generated parser */\nvar jsmmparser = (function(){\nvar parser = {trace: function trace() { },\nyy: {},\nsymbols_: {\"error\":2,\"program\":3,\"programStatementList\":4,\"EOF\":5,\"NEWLINE\":6,\"commonStatement\":7,\"functionDeclaration\":8,\"statementList\":9,\"simpleStatement\":10,\";\":11,\"blockStatement\":12,\"returnStatement\":13,\"assignmentStatement\":14,\"varStatement\":15,\"callStatement\":16,\"identExpression\":17,\"+\":18,\"=\":19,\"expression\":20,\"+=\":21,\"VAR\":22,\"varList\":23,\"varListItem\":24,\",\":25,\"NAME\":26,\"RETURN\":27,\"andExpression\":28,\"||\":29,\"relationalExpression\":30,\"&&\":31,\"addExpression\":32,\"==\":33,\"multExpression\":34,\"unaryExpression\":35,\"*\":36,\"primaryExpression\":37,\"!\":38,\"NUMBER\":39,\"STRING\":40,\"TRUE\":41,\"FALSE\":42,\"callExpression\":43,\"(\":44,\")\":45,\".\":46,\"[\":47,\"]\":48,\"callArguments\":49,\"ifBlock\":50,\"whileBlock\":51,\"forBlock\":52,\"IF\":53,\"{\":54,\"}\":55,\"elseBlock\":56,\"ELSE\":57,\"WHILE\":58,\"FOR\":59,\"FUNCTION\":60,\"functionArguments\":61,\"reserved\":62,\"RESERVED\":63,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",5:\"EOF\",6:\"NEWLINE\",11:\";\",18:\"+\",19:\"=\",21:\"+=\",22:\"VAR\",25:\",\",26:\"NAME\",27:\"RETURN\",29:\"||\",31:\"&&\",33:\"==\",36:\"*\",38:\"!\",39:\"NUMBER\",40:\"STRING\",41:\"TRUE\",42:\"FALSE\",44:\"(\",45:\")\",46:\".\",47:\"[\",48:\"]\",53:\"IF\",54:\"{\",55:\"}\",57:\"ELSE\",58:\"WHILE\",59:\"FOR\",60:\"FUNCTION\",63:\"RESERVED\"},\nproductions_: [0,[3,2],[3,3],[4,0],[4,3],[4,3],[9,0],[9,3],[7,2],[7,1],[7,1],[10,1],[10,1],[10,1],[10,3],[14,3],[14,3],[15,2],[23,1],[23,3],[24,1],[24,3],[13,2],[13,3],[20,1],[20,3],[28,1],[28,3],[30,1],[30,3],[32,1],[32,3],[34,1],[34,3],[35,1],[35,2],[35,2],[37,1],[37,1],[37,1],[37,1],[37,1],[37,1],[37,3],[17,1],[17,3],[17,4],[43,3],[43,4],[49,1],[49,3],[16,1],[12,1],[12,1],[12,1],[50,9],[56,0],[56,2],[56,5],[51,8],[52,12],[8,8],[8,9],[61,1],[61,3],[62,1]],\nperformAction: function anonymous(yytext,yyleng,yylineno,yy,yystate,$$,_$) {\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 1: this.$ = new yy.nodes.Program(this._$, null, $$[$0-1]); return this.$; \nbreak;\ncase 2: this.$ = new yy.nodes.Program(this._$, null, $$[$0-1]); return this.$; \nbreak;\ncase 3: this.$ = new yy.nodes.StatementList(this._$, null); \nbreak;\ncase 4: this.$ = $$[$0-2]; this.$.addStatement($$[$0-1]); \nbreak;\ncase 5: this.$ = $$[$0-2]; this.$.addStatement($$[$0-1]); \nbreak;\ncase 6: this.$ = new yy.nodes.StatementList(this._$, null); \nbreak;\ncase 7: this.$ = $$[$0-2]; this.$.addStatement($$[$0-1]); \nbreak;\ncase 8: this.$ = new yy.nodes.CommonSimpleStatement(this._$, undefined, $$[$0-1]); \nbreak;\ncase 14: this.$ = new yy.nodes.PostfixStatement(this._$, undefined, $$[$0-2], $$[$0-1]+$$[$0-1]); \nbreak;\ncase 15: this.$ = new yy.nodes.AssignmentStatement(this._$, undefined, $$[$0-2], \"=\", $$[$0]); \nbreak;\ncase 16: this.$ = new yy.nodes.AssignmentStatement(this._$, undefined, $$[$0-2], $$[$0-1], $$[$0]); \nbreak;\ncase 17: this.$ = $$[$0]; \nbreak;\ncase 18: this.$ = new yy.nodes.VarStatement(this._$, undefined); this.$.addVarItem($$[$0]); \nbreak;\ncase 19: this.$ = $$[$0-2]; this.$.addVarItem($$[$0]); \nbreak;\ncase 20: this.$ = new yy.nodes.VarItem(this._$, undefined, $$[$0], null); \nbreak;\ncase 21:\n\t\t\tthis.$ = new yy.nodes.VarItem(this._$, undefined, $$[$0-2], new yy.nodes.AssignmentStatement(this._$, undefined, new yy.nodes.NameIdentifier(_$[$0-2], undefined, $$[$0-2]), \"=\", $$[$0]));\n\t\t\nbreak;\ncase 22: this.$ = new yy.nodes.ReturnStatement(this._$, undefined, null); \nbreak;\ncase 23: this.$ = new yy.nodes.ReturnStatement(this._$, undefined, $$[$0-1]); \nbreak;\ncase 25: this.$ = new yy.nodes.BinaryExpression(this._$, undefined, $$[$0-2], $$[$0-1], $$[$0]); \nbreak;\ncase 27: this.$ = new yy.nodes.BinaryExpression(this._$, undefined, $$[$0-2], $$[$0-1], $$[$0]); \nbreak;\ncase 29: this.$ = new yy.nodes.BinaryExpression(this._$, undefined, $$[$0-2], $$[$0-1], $$[$0]); \nbreak;\ncase 31: this.$ = new yy.nodes.BinaryExpression(this._$, undefined, $$[$0-2], $$[$0-1], $$[$0]); \nbreak;\ncase 33: this.$ = new yy.nodes.BinaryExpression(this._$, undefined, $$[$0-2], $$[$0-1], $$[$0]); \nbreak;\ncase 35: this.$ = new yy.nodes.UnaryExpression(this._$, undefined, $$[$0-1], $$[$0]); \nbreak;\ncase 36: this.$ = new yy.nodes.UnaryExpression(this._$, undefined, $$[$0-1], $$[$0]); \nbreak;\ncase 38: this.$ = new yy.nodes.NumberLiteral(this._$, undefined, $$[$0]); \nbreak;\ncase 39: this.$ = new yy.nodes.StringLiteral(this._$, undefined, $$[$0]); \nbreak;\ncase 40: this.$ = new yy.nodes.BooleanLiteral(this._$, undefined, true); \nbreak;\ncase 41: this.$ = new yy.nodes.BooleanLiteral(this._$, undefined, false); \nbreak;\ncase 43: this.$ = $$[$0-1]; \nbreak;\ncase 44: this.$ = new yy.nodes.NameIdentifier(this._$, undefined, $$[$0]); \nbreak;\ncase 45: this.$ = new yy.nodes.ObjectIdentifier(this._$, undefined, $$[$0-2], $$[$0]); \nbreak;\ncase 46: this.$ = new yy.nodes.ArrayIdentifier(this._$, undefined, $$[$0-3], $$[$0-1]); \nbreak;\ncase 47: this.$ = new yy.nodes.FunctionCall(this._$, undefined, $$[$0-2], []); \nbreak;\ncase 48: this.$ = new yy.nodes.FunctionCall(this._$, undefined, $$[$0-3], $$[$0-1]); \nbreak;\ncase 49: this.$ = [$$[$0]]; \nbreak;\ncase 50: this.$ = $$[$0-2]; this.$.push($$[$0]); \nbreak;\ncase 51: this.$ = new yy.nodes.CallStatement(this._$, undefined, $$[$0]); \nbreak;\ncase 55: this.$ = new yy.nodes.IfBlock(this._$, _$[$0-5].last_column, $$[$0-6], $$[$0-2], $$[$0]); \nbreak;\ncase 56: this.$ = null; \nbreak;\ncase 57: this.$ = new yy.nodes.ElseIfBlock(this._$, _$[$0-1].last_column, $$[$0]); \nbreak;\ncase 58: this.$ = new yy.nodes.ElseBlock(this._$, _$[$0-4].last_column, $$[$0-1]); \nbreak;\ncase 59: this.$ = new yy.nodes.WhileBlock(this._$, _$[$0-4].last_column, $$[$0-5], $$[$0-1]); \nbreak;\ncase 60: this.$ = new yy.nodes.ForBlock(this._$, _$[$0-4].last_column, $$[$0-9], $$[$0-7], $$[$0-5], $$[$0-1]); \nbreak;\ncase 61: this.$ = new yy.nodes.FunctionDeclaration(this._$, _$[$0-4].last_column, $$[$0-6], [], $$[$0-1]); \nbreak;\ncase 62: this.$ = new yy.nodes.FunctionDeclaration(this._$, _$[$0-4].last_column, $$[$0-7], $$[$0-5], $$[$0-1]); \nbreak;\ncase 63: this.$ = [$$[$0]]; \nbreak;\ncase 64: this.$ = $$[$0-2]; this.$.push($$[$0]); \nbreak;\n}\n},\ntable: [{3:1,4:2,5:[2,3],6:[1,3],22:[2,3],26:[2,3],27:[2,3],53:[2,3],58:[2,3],59:[2,3],60:[2,3]},{1:[3]},{5:[1,4],7:5,8:6,10:7,12:8,13:9,14:11,15:12,16:13,17:14,22:[1,19],26:[1,21],27:[1,18],43:20,50:15,51:16,52:17,53:[1,22],58:[1,23],59:[1,24],60:[1,10]},{4:25,5:[2,3],22:[2,3],26:[2,3],27:[2,3],53:[2,3],58:[2,3],59:[2,3],60:[2,3]},{1:[2,1]},{6:[1,26]},{6:[1,27]},{11:[1,28]},{6:[2,9]},{6:[2,10]},{26:[1,29]},{11:[2,11],45:[2,11]},{11:[2,12],45:[2,12]},{11:[2,13],45:[2,13]},{18:[1,30],19:[1,31],21:[1,32],44:[1,35],46:[1,33],47:[1,34]},{6:[2,52]},{6:[2,53]},{6:[2,54]},{11:[1,36],17:46,18:[1,44],20:37,26:[1,21],28:38,30:39,32:40,34:41,35:42,37:43,38:[1,45],39:[1,47],40:[1,48],41:[1,49],42:[1,50],43:51,44:[1,52]},{23:53,24:54,26:[1,55]},{11:[2,51],45:[2,51]},{11:[2,44],18:[2,44],19:[2,44],21:[2,44],25:[2,44],29:[2,44],31:[2,44],33:[2,44],36:[2,44],44:[2,44],45:[2,44],46:[2,44],47:[2,44],48:[2,44]},{44:[1,56]},{44:[1,57]},{44:[1,58]},{5:[1,59],7:5,8:6,10:7,12:8,13:9,14:11,15:12,16:13,17:14,22:[1,19],26:[1,21],27:[1,18],43:20,50:15,51:16,52:17,53:[1,22],58:[1,23],59:[1,24],60:[1,10]},{5:[2,4],22:[2,4],26:[2,4],27:[2,4],53:[2,4],58:[2,4],59:[2,4],60:[2,4]},{5:[2,5],22:[2,5],26:[2,5],27:[2,5],53:[2,5],58:[2,5],59:[2,5],60:[2,5]},{6:[2,8]},{44:[1,60]},{18:[1,61]},{17:46,18:[1,44],20:62,26:[1,21],28:38,30:39,32:40,34:41,35:42,37:43,38:[1,45],39:[1,47],40:[1,48],41:[1,49],42:[1,50],43:51,44:[1,52]},{17:46,18:[1,44],20:63,26:[1,21],28:38,30:39,32:40,34:41,35:42,37:43,38:[1,45],39:[1,47],40:[1,48],41:[1,49],42:[1,50],43:51,44:[1,52]},{26:[1,64]},{17:46,18:[1,44],20:65,26:[1,21],28:38,30:39,32:40,34:41,35:42,37:43,38:[1,45],39:[1,47],40:[1,48],41:[1,49],42:[1,50],43:51,44:[1,52]},{17:46,18:[1,44],20:68,26:[1,21],28:38,30:39,32:40,34:41,35:42,37:43,38:[1,45],39:[1,47],40:[1,48],41:[1,49],42:[1,50],43:51,44:[1,52],45:[1,66],49:67},{6:[2,22]},{11:[1,69],29:[1,70]},{11:[2,24],25:[2,24],29:[2,24],31:[1,71],45:[2,24],48:[2,24]},{11:[2,26],25:[2,26],29:[2,26],31:[2,26],33:[1,72],45:[2,26],48:[2,26]},{11:[2,28],18:[1,73],25:[2,28],29:[2,28],31:[2,28],33:[2,28],45:[2,28],48:[2,28]},{11:[2,30],18:[2,30],25:[2,30],29:[2,30],31:[2,30],33:[2,30],36:[1,74],45:[2,30],48:[2,30]},{11:[2,32],18:[2,32],25:[2,32],29:[2,32],31:[2,32],33:[2,32],36:[2,32],45:[2,32],48:[2,32]},{11:[2,34],18:[2,34],25:[2,34],29:[2,34],31:[2,34],33:[2,34],36:[2,34],45:[2,34],48:[2,34]},{17:46,18:[1,44],26:[1,21],35:75,37:43,38:[1,45],39:[1,47],40:[1,48],41:[1,49],42:[1,50],43:51,44:[1,52]},{17:46,18:[1,44],26:[1,21],35:76,37:43,38:[1,45],39:[1,47],40:[1,48],41:[1,49],42:[1,50],43:51,44:[1,52]},{11:[2,37],18:[2,37],25:[2,37],29:[2,37],31:[2,37],33:[2,37],36:[2,37],44:[1,35],45:[2,37],46:[1,33],47:[1,34],48:[2,37]},{11:[2,38],18:[2,38],25:[2,38],29:[2,38],31:[2,38],33:[2,38],36:[2,38],45:[2,38],48:[2,38]},{11:[2,39],18:[2,39],25:[2,39],29:[2,39],31:[2,39],33:[2,39],36:[2,39],45:[2,39],48:[2,39]},{11:[2,40],18:[2,40],25:[2,40],29:[2,40],31:[2,40],33:[2,40],36:[2,40],45:[2,40],48:[2,40]},{11:[2,41],18:[2,41],25:[2,41],29:[2,41],31:[2,41],33:[2,41],36:[2,41],45:[2,41],48:[2,41]},{11:[2,42],18:[2,42],25:[2,42],29:[2,42],31:[2,42],33:[2,42],36:[2,42],45:[2,42],48:[2,42]},{17:46,18:[1,44],20:77,26:[1,21],28:38,30:39,32:40,34:41,35:42,37:43,38:[1,45],39:[1,47],40:[1,48],41:[1,49],42:[1,50],43:51,44:[1,52]},{11:[2,17],25:[1,78],45:[2,17]},{11:[2,18],25:[2,18],45:[2,18]},{11:[2,20],19:[1,79],25:[2,20],45:[2,20]},{17:46,18:[1,44],20:80,26:[1,21],28:38,30:39,32:40,34:41,35:42,37:43,38:[1,45],39:[1,47],40:[1,48],41:[1,49],42:[1,50],43:51,44:[1,52]},{17:46,18:[1,44],20:81,26:[1,21],28:38,30:39,32:40,34:41,35:42,37:43,38:[1,45],39:[1,47],40:[1,48],41:[1,49],42:[1,50],43:51,44:[1,52]},{10:82,14:11,15:12,16:13,17:14,22:[1,19],26:[1,21],43:20},{1:[2,2]},{26:[1,85],45:[1,83],61:84},{11:[2,14],45:[2,14]},{11:[2,15],29:[1,70],45:[2,15]},{11:[2,16],29:[1,70],45:[2,16]},{11:[2,45],18:[2,45],19:[2,45],21:[2,45],25:[2,45],29:[2,45],31:[2,45],33:[2,45],36:[2,45],44:[2,45],45:[2,45],46:[2,45],47:[2,45],48:[2,45]},{29:[1,70],48:[1,86]},{11:[2,47],18:[2,47],25:[2,47],29:[2,47],31:[2,47],33:[2,47],36:[2,47],45:[2,47],48:[2,47]},{25:[1,88],45:[1,87]},{25:[2,49],29:[1,70],45:[2,49]},{6:[2,23]},{17:46,18:[1,44],26:[1,21],28:89,30:39,32:40,34:41,35:42,37:43,38:[1,45],39:[1,47],40:[1,48],41:[1,49],42:[1,50],43:51,44:[1,52]},{17:46,18:[1,44],26:[1,21],30:90,32:40,34:41,35:42,37:43,38:[1,45],39:[1,47],40:[1,48],41:[1,49],42:[1,50],43:51,44:[1,52]},{17:46,18:[1,44],26:[1,21],32:91,34:41,35:42,37:43,38:[1,45],39:[1,47],40:[1,48],41:[1,49],42:[1,50],43:51,44:[1,52]},{17:46,18:[1,44],26:[1,21],34:92,35:42,37:43,38:[1,45],39:[1,47],40:[1,48],41:[1,49],42:[1,50],43:51,44:[1,52]},{17:46,18:[1,44],26:[1,21],35:93,37:43,38:[1,45],39:[1,47],40:[1,48],41:[1,49],42:[1,50],43:51,44:[1,52]},{11:[2,35],18:[2,35],25:[2,35],29:[2,35],31:[2,35],33:[2,35],36:[2,35],45:[2,35],48:[2,35]},{11:[2,36],18:[2,36],25:[2,36],29:[2,36],31:[2,36],33:[2,36],36:[2,36],45:[2,36],48:[2,36]},{29:[1,70],45:[1,94]},{24:95,26:[1,55]},{17:46,18:[1,44],20:96,26:[1,21],28:38,30:39,32:40,34:41,35:42,37:43,38:[1,45],39:[1,47],40:[1,48],41:[1,49],42:[1,50],43:51,44:[1,52]},{29:[1,70],45:[1,97]},{29:[1,70],45:[1,98]},{11:[1,99]},{54:[1,100]},{25:[1,102],45:[1,101]},{25:[2,63],45:[2,63]},{11:[2,46],18:[2,46],19:[2,46],21:[2,46],25:[2,46],29:[2,46],31:[2,46],33:[2,46],36:[2,46],44:[2,46],45:[2,46],46:[2,46],47:[2,46],48:[2,46]},{11:[2,48],18:[2,48],25:[2,48],29:[2,48],31:[2,48],33:[2,48],36:[2,48],45:[2,48],48:[2,48]},{17:46,18:[1,44],20:103,26:[1,21],28:38,30:39,32:40,34:41,35:42,37:43,38:[1,45],39:[1,47],40:[1,48],41:[1,49],42:[1,50],43:51,44:[1,52]},{11:[2,25],25:[2,25],29:[2,25],31:[1,71],45:[2,25],48:[2,25]},{11:[2,27],25:[2,27],29:[2,27],31:[2,27],33:[1,72],45:[2,27],48:[2,27]},{11:[2,29],18:[1,73],25:[2,29],29:[2,29],31:[2,29],33:[2,29],45:[2,29],48:[2,29]},{11:[2,31],18:[2,31],25:[2,31],29:[2,31],31:[2,31],33:[2,31],36:[1,74],45:[2,31],48:[2,31]},{11:[2,33],18:[2,33],25:[2,33],29:[2,33],31:[2,33],33:[2,33],36:[2,33],45:[2,33],48:[2,33]},{11:[2,43],18:[2,43],25:[2,43],29:[2,43],31:[2,43],33:[2,43],36:[2,43],45:[2,43],48:[2,43]},{11:[2,19],25:[2,19],45:[2,19]},{11:[2,21],25:[2,21],29:[1,70],45:[2,21]},{54:[1,104]},{54:[1,105]},{17:46,18:[1,44],20:106,26:[1,21],28:38,30:39,32:40,34:41,35:42,37:43,38:[1,45],39:[1,47],40:[1,48],41:[1,49],42:[1,50],43:51,44:[1,52]},{6:[1,107]},{54:[1,108]},{26:[1,109]},{25:[2,50],29:[1,70],45:[2,50]},{6:[1,110]},{6:[1,111]},{11:[1,112],29:[1,70]},{9:113,22:[2,6],26:[2,6],27:[2,6],53:[2,6],55:[2,6],58:[2,6],59:[2,6]},{6:[1,114]},{25:[2,64],45:[2,64]},{9:115,22:[2,6],26:[2,6],27:[2,6],53:[2,6],55:[2,6],58:[2,6],59:[2,6]},{9:116,22:[2,6],26:[2,6],27:[2,6],53:[2,6],55:[2,6],58:[2,6],59:[2,6]},{10:117,14:11,15:12,16:13,17:14,22:[1,19],26:[1,21],43:20},{7:119,10:7,12:8,13:9,14:11,15:12,16:13,17:14,22:[1,19],26:[1,21],27:[1,18],43:20,50:15,51:16,52:17,53:[1,22],55:[1,118],58:[1,23],59:[1,24]},{9:120,22:[2,6],26:[2,6],27:[2,6],53:[2,6],55:[2,6],58:[2,6],59:[2,6]},{7:119,10:7,12:8,13:9,14:11,15:12,16:13,17:14,22:[1,19],26:[1,21],27:[1,18],43:20,50:15,51:16,52:17,53:[1,22],55:[1,121],58:[1,23],59:[1,24]},{7:119,10:7,12:8,13:9,14:11,15:12,16:13,17:14,22:[1,19],26:[1,21],27:[1,18],43:20,50:15,51:16,52:17,53:[1,22],55:[1,122],58:[1,23],59:[1,24]},{45:[1,123]},{6:[2,61]},{6:[1,124]},{7:119,10:7,12:8,13:9,14:11,15:12,16:13,17:14,22:[1,19],26:[1,21],27:[1,18],43:20,50:15,51:16,52:17,53:[1,22],55:[1,125],58:[1,23],59:[1,24]},{6:[2,56],56:126,57:[1,127]},{6:[2,59]},{54:[1,128]},{22:[2,7],26:[2,7],27:[2,7],53:[2,7],55:[2,7],58:[2,7],59:[2,7]},{6:[2,62]},{6:[2,55]},{50:129,53:[1,22],54:[1,130]},{6:[1,131]},{6:[2,57]},{6:[1,132]},{9:133,22:[2,6],26:[2,6],27:[2,6],53:[2,6],55:[2,6],58:[2,6],59:[2,6]},{9:134,22:[2,6],26:[2,6],27:[2,6],53:[2,6],55:[2,6],58:[2,6],59:[2,6]},{7:119,10:7,12:8,13:9,14:11,15:12,16:13,17:14,22:[1,19],26:[1,21],27:[1,18],43:20,50:15,51:16,52:17,53:[1,22],55:[1,135],58:[1,23],59:[1,24]},{7:119,10:7,12:8,13:9,14:11,15:12,16:13,17:14,22:[1,19],26:[1,21],27:[1,18],43:20,50:15,51:16,52:17,53:[1,22],55:[1,136],58:[1,23],59:[1,24]},{6:[2,60]},{6:[2,58]}],\ndefaultActions: {4:[2,1],8:[2,9],9:[2,10],15:[2,52],16:[2,53],17:[2,54],28:[2,8],36:[2,22],59:[2,2],69:[2,23],118:[2,61],122:[2,59],125:[2,62],126:[2,55],129:[2,57],135:[2,60],136:[2,58]},\nparseError: function parseError(str, hash) {\n    throw new Error(str);\n},\nparse: function parse(input) {\n    var self = this,\n        stack = [0],\n        vstack = [null], // semantic value stack\n        lstack = [], // location stack\n        table = this.table,\n        yytext = '',\n        yylineno = 0,\n        yyleng = 0,\n        recovering = 0,\n        TERROR = 2,\n        EOF = 1;\n\n    //this.reductionCount = this.shiftCount = 0;\n\n    this.lexer.setInput(input);\n    this.lexer.yy = this.yy;\n    this.yy.lexer = this.lexer;\n    if (typeof this.lexer.yylloc == 'undefined')\n        this.lexer.yylloc = {};\n    var yyloc = this.lexer.yylloc;\n    lstack.push(yyloc);\n\n    if (typeof this.yy.parseError === 'function')\n        this.parseError = this.yy.parseError;\n\n    function popStack (n) {\n        stack.length = stack.length - 2*n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n\n    function lex() {\n        var token;\n        token = self.lexer.lex() || 1; // $end = 1\n        // if token isn't its numeric value, convert\n        if (typeof token !== 'number') {\n            token = self.symbols_[token] || token;\n        }\n        return token;\n    }\n\n    var symbol, preErrorSymbol, state, action, a, r, yyval={},p,len,newState, expected;\n    while (true) {\n        // retreive state number from top of stack\n        state = stack[stack.length-1];\n\n        // use default actions if available\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol == null)\n                symbol = lex();\n            // read action for current state and first input\n            action = table[state] && table[state][symbol];\n        }\n\n        // handle parse error\n        _handle_error:\n        if (typeof action === 'undefined' || !action.length || !action[0]) {\n\n            if (!recovering) {\n                // Report error\n                expected = [];\n                for (p in table[state]) if (this.terminals_[p] && p > 2) {\n                    expected.push(\"'\"+this.terminals_[p]+\"'\");\n                }\n                var errStr = '';\n                if (this.lexer.showPosition) {\n                    errStr = 'Parse error on line '+(yylineno+1)+\":\\n\"+this.lexer.showPosition()+\"\\nExpecting \"+expected.join(', ') + \", got '\" + this.terminals_[symbol]+ \"'\";\n                } else {\n                    errStr = 'Parse error on line '+(yylineno+1)+\": Unexpected \" +\n                                  (symbol == 1 /*EOF*/ ? \"end of input\" :\n                                              (\"'\"+(this.terminals_[symbol] || symbol)+\"'\"));\n                }\n                this.parseError(errStr,\n                    {text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected});\n            }\n\n            // just recovered from another error\n            if (recovering == 3) {\n                if (symbol == EOF) {\n                    throw new Error(errStr || 'Parsing halted.');\n                }\n\n                // discard current lookahead and grab another\n                yyleng = this.lexer.yyleng;\n                yytext = this.lexer.yytext;\n                yylineno = this.lexer.yylineno;\n                yyloc = this.lexer.yylloc;\n                symbol = lex();\n            }\n\n            // try to recover from error\n            while (1) {\n                // check for error recovery rule in this state\n                if ((TERROR.toString()) in table[state]) {\n                    break;\n                }\n                if (state == 0) {\n                    throw new Error(errStr || 'Parsing halted.');\n                }\n                popStack(1);\n                state = stack[stack.length-1];\n            }\n\n            preErrorSymbol = symbol; // save the lookahead token\n            symbol = TERROR;         // insert generic error symbol as new lookahead\n            state = stack[stack.length-1];\n            action = table[state] && table[state][TERROR];\n            recovering = 3; // allow 3 real symbols to be shifted before reporting a new error\n        }\n\n        // this shouldn't happen, unless resolve defaults are off\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: '+state+', token: '+symbol);\n        }\n\n        switch (action[0]) {\n\n            case 1: // shift\n                //this.shiftCount++;\n\n                stack.push(symbol);\n                vstack.push(this.lexer.yytext);\n                lstack.push(this.lexer.yylloc);\n                stack.push(action[1]); // push state\n                symbol = null;\n                if (!preErrorSymbol) { // normal execution/no error\n                    yyleng = this.lexer.yyleng;\n                    yytext = this.lexer.yytext;\n                    yylineno = this.lexer.yylineno;\n                    yyloc = this.lexer.yylloc;\n                    if (recovering > 0)\n                        recovering--;\n                } else { // error just occurred, resume old lookahead f/ before error\n                    symbol = preErrorSymbol;\n                    preErrorSymbol = null;\n                }\n                break;\n\n            case 2: // reduce\n                //this.reductionCount++;\n\n                len = this.productions_[action[1]][1];\n\n                // perform semantic action\n                yyval.$ = vstack[vstack.length-len]; // default to $$ = $1\n                // default location, uses first token for firsts, last for lasts\n                yyval._$ = {\n                    first_line: lstack[lstack.length-(len||1)].first_line,\n                    last_line: lstack[lstack.length-1].last_line,\n                    first_column: lstack[lstack.length-(len||1)].first_column,\n                    last_column: lstack[lstack.length-1].last_column\n                };\n                r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);\n\n                if (typeof r !== 'undefined') {\n                    return r;\n                }\n\n                // pop off stack\n                if (len) {\n                    stack = stack.slice(0,-1*len*2);\n                    vstack = vstack.slice(0, -1*len);\n                    lstack = lstack.slice(0, -1*len);\n                }\n\n                stack.push(this.productions_[action[1]][0]);    // push nonterminal (reduce)\n                vstack.push(yyval.$);\n                lstack.push(yyval._$);\n                // goto new state = table[STATE][NONTERMINAL]\n                newState = table[stack[stack.length-2]][stack[stack.length-1]];\n                stack.push(newState);\n                break;\n\n            case 3: // accept\n                return true;\n        }\n\n    }\n\n    return true;\n}};\n/* Jison generated lexer */\nvar lexer = (function(){\nvar lexer = ({EOF:1,\nparseError:function parseError(str, hash) {\n        if (this.yy.parseError) {\n            this.yy.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\nsetInput:function (input) {\n        this._input = input;\n        this._more = this._less = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {first_line:1,first_column:0,last_line:1,last_column:0};\n        return this;\n    },\ninput:function () {\n        var ch = this._input[0];\n        this.yytext+=ch;\n        this.yyleng++;\n        this.match+=ch;\n        this.matched+=ch;\n        var lines = ch.match(/\\n/);\n        if (lines) this.yylineno++;\n        this._input = this._input.slice(1);\n        return ch;\n    },\nunput:function (ch) {\n        this._input = ch + this._input;\n        return this;\n    },\nmore:function () {\n        this._more = true;\n        return this;\n    },\nless:function (n) {\n        this._input = this.match.slice(n) + this._input;\n    },\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20)+(next.length > 20 ? '...':'')).replace(/\\n/g, \"\");\n    },\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c+\"^\";\n    },\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) this.done = true;\n\n        var token,\n            match,\n            tempMatch,\n            index,\n            col,\n            lines;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i=0;i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                match = tempMatch;\n                index = i;\n                if (!this.options.flex) break;\n            }\n        }\n        if (match) {\n            lines = match[0].match(/\\n.*/g);\n            if (lines) this.yylineno += lines.length;\n            this.yylloc = {first_line: this.yylloc.last_line,\n                           last_line: this.yylineno+1,\n                           first_column: this.yylloc.last_column,\n                           last_column: lines ? lines[lines.length-1].length-1 : this.yylloc.last_column + match[0].length}\n            this.yytext += match[0];\n            this.match += match[0];\n            this.yyleng = this.yytext.length;\n            this._more = false;\n            this._input = this._input.slice(match[0].length);\n            this.matched += match[0];\n            token = this.performAction.call(this, this.yy, this, rules[index],this.conditionStack[this.conditionStack.length-1]);\n            if (token) return token;\n            else return;\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            this.parseError('Lexical error on line '+(this.yylineno+1)+'. Unrecognized text.\\n'+this.showPosition(), \n                    {text: \"\", token: null, line: this.yylineno});\n        }\n    },\nlex:function lex() {\n        var r = this.next();\n        if (typeof r !== 'undefined') {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\nbegin:function begin(condition) {\n        this.conditionStack.push(condition);\n    },\npopState:function popState() {\n        return this.conditionStack.pop();\n    },\n_currentRules:function _currentRules() {\n        return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules;\n    },\ntopState:function () {\n        return this.conditionStack[this.conditionStack.length-2];\n    },\npushState:function begin(condition) {\n        this.begin(condition);\n    }});\nlexer.options = {};\nlexer.performAction = function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\n\nvar YYSTATE=YY_START\nswitch($avoiding_name_collisions) {\ncase 0:/* skip and comments */\nbreak;\ncase 1:return \"RESERVED\";\nbreak;\ncase 2:return \"TRUE\";\nbreak;\ncase 3:return \"FALSE\";\nbreak;\ncase 4:return \"IF\";\nbreak;\ncase 5:return \"ELSE\";\nbreak;\ncase 6:return \"WHILE\";\nbreak;\ncase 7:return \"FOR\";\nbreak;\ncase 8:return \"VAR\";\nbreak;\ncase 9:return \"FUNCTION\";\nbreak;\ncase 10:return \"RETURN\";\nbreak;\ncase 11:return \"NAME\";\nbreak;\ncase 12:return \"NEWLINE\";\nbreak;\ncase 13:return \"NUMBER\";\nbreak;\ncase 14:return \"STRING\";\nbreak;\ncase 15:return \"EOF\";\nbreak;\ncase 16:return \"+=\";\nbreak;\ncase 17:return \"==\";\nbreak;\ncase 18:return \"&&\";\nbreak;\ncase 19:return \"||\";\nbreak;\ncase 20:return \"=\";\nbreak;\ncase 21:return \"+\";\nbreak;\ncase 22:return \"*\";\nbreak;\ncase 23:return \";\";\nbreak;\ncase 24:return \"!\";\nbreak;\ncase 25:return \"(\";\nbreak;\ncase 26:return \")\";\nbreak;\ncase 27:return \"{\";\nbreak;\ncase 28:return \"}\";\nbreak;\ncase 29:return \"[\";\nbreak;\ncase 30:return \"]\";\nbreak;\ncase 31:return \".\";\nbreak;\ncase 32:return \",\";\nbreak;\n}\n};\nlexer.rules = [/^(?:((?:[ \\f\\r\\t\\v\\u00A0\\u2028\\u2029]+))|((?:(?:[/][/][^\\n]*)|(?:[/][*](?:[^*\\n]*[*][^/\\n])*[^*\\n]*[*][/]))))/,/^((?:null|break|case|catch|default|finally|instanceof|new|continue|void|delete|this|do|in|switch|throw|try|typeof|with|abstract|boolean|byte|char|class|const|debugger|double|enum|export|extends|final|float|goto|implements|import|int|interface|long|native|package|private|protected|public|short|static|super|synchronized|throws|transient|volatile|arguments|NaN|Array|Object|RegExp|toString|jsmm|jsmmparser|jsmmExecutionCounter|jsmmCallStackDepth|jsmmtemp|jsmmscope|jsmmscopeInner|jsmmscopeOuter|jsmmtree))(?!([0-9a-zA-Z_]))/,/^true\\b/,/^false\\b/,/^if\\b/,/^((?:((?:((?:[ \\f\\r\\t\\v\\u00A0\\u2028\\u2029]+))|((?:(?:[/][/][^\\n]*)|(?:[/][*](?:[^*\\n]*[*][^/\\n])*[^*\\n]*[*][/])))|((?:[/][*](?:[^*]*[*][^/])*[^*]*[*][/]))))*(?:[\\n]((?:((?:[ \\f\\r\\t\\v\\u00A0\\u2028\\u2029]+))|((?:(?:[/][/][^\\n]*)|(?:[/][*](?:[^*\\n]*[*][^/\\n])*[^*\\n]*[*][/])))|((?:[/][*](?:[^*]*[*][^/])*[^*]*[*][/]))))*)+))?else\\b/,/^while\\b/,/^for\\b/,/^var\\b/,/^function\\b/,/^return\\b/,/^([a-zA-Z_])([0-9a-zA-Z_])*/,/^((?:((?:((?:[ \\f\\r\\t\\v\\u00A0\\u2028\\u2029]+))|((?:(?:[/][/][^\\n]*)|(?:[/][*](?:[^*\\n]*[*][^/\\n])*[^*\\n]*[*][/])))|((?:[/][*](?:[^*]*[*][^/])*[^*]*[*][/]))))*(?:[\\n]((?:((?:[ \\f\\r\\t\\v\\u00A0\\u2028\\u2029]+))|((?:(?:[/][/][^\\n]*)|(?:[/][*](?:[^*\\n]*[*][^/\\n])*[^*\\n]*[*][/])))|((?:[/][*](?:[^*]*[*][^/])*[^*]*[*][/]))))*)+))/,/^((?:(?:(?:[1-9]([0-9])*)|0)((?:\\.([0-9])+))?((?:[eE][+-]?([0-9])+))?))/,/^((?:[\"][^\\\\\"\\n]*(?:[\\\\][nt\"\\\\][^\\\\\"]*)*[\"]))/,/^$/,/^(\\+=|-=|\\*=|\\/=|%=)/,/^(==|!=|>=|<=|>|<)/,/^&&/,/^\\|\\|/,/^=/,/^(\\+|-)/,/^(\\*|\\/|%)/,/^;/,/^!/,/^\\(/,/^\\)/,/^\\{/,/^\\}/,/^\\[/,/^\\]/,/^\\./,/^,/];\nlexer.conditions = {\"INITIAL\":{\"rules\":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32],\"inclusive\":true}};\nreturn lexer;})()\nparser.lexer = lexer;\nreturn parser;\n})();\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\nexports.parser = jsmmparser;\nexports.parse = function () { return jsmmparser.parse.apply(jsmmparser, arguments); }\nexports.main = function commonjsMain(args) {\n    if (!args[1])\n        throw new Error('Usage: '+args[0]+' FILE');\n    if (typeof process !== 'undefined') {\n        var source = require('fs').readFileSync(require('path').join(process.cwd(), args[1]), \"utf8\");\n    } else {\n        var cwd = require(\"file\").path(require(\"file\").cwd());\n        var source = cwd.join(args[1]).read({charset: \"utf-8\"});\n    }\n    return exports.parser.parse(source);\n}\nif (typeof module !== 'undefined' && require.main === module) {\n  exports.main(typeof process !== 'undefined' ? process.argv.slice(1) : require(\"system\").args);\n}\n}\n//@ sourceURL=/jsmm/jsmmparser.js"
));

require.define("fs", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "// nothing to see here... no file methods for the browser\n\n//@ sourceURL=fs"
));

require.define("/node_modules/file/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\"main\":\"./lib/file\"}\n//@ sourceURL=/node_modules/file/package.json"
));

require.define("/node_modules/file/lib/file.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var path = require('path');\nvar fs = require('fs');\nvar assert = require(\"assert\");\n\n// file.mkdirs\n//\n// Given a path to a directory, create it, and all the intermediate directories\n// as well\n// \n// @path: the path to create\n// @mode: the file mode to create the directory with:\n//    ex: file.mkdirs(\"/tmp/dir\", 755, function () {})\n// @callback: called when finished.\nexports.mkdirs = function (_path, mode, callback) {\n  _path = exports.path.abspath(_path);\n\n  var dirs = _path.split(\"/\");\n  var walker = [dirs.shift()];\n\n  // walk\n  // @ds:  A list of directory names\n  // @acc: An accumulator of walked dirs\n  // @m:   The mode\n  // @cb:  The callback\n  var walk = function (ds, acc, m, cb) {\n    if (ds.length > 0) {\n      var d = ds.shift();\n\n      acc.push(d);\n      var dir = acc.join(\"/\");\n\n      // look for dir on the fs, if it doesn't exist then create it, and \n      // continue our walk, otherwise if it's a file, we have a name\n      // collision, so exit.\n      fs.stat(dir, function (err, stat) {\n        // if the directory doesn't exist then create it\n        if (err) {\n          // 2 means it's wasn't there\n          if (err.errno == 2 || err.errno == 34) {\n            fs.mkdir(dir, m, function (erro) {\n              if (erro && erro.errno != 17 && erro.errno != 34) {\n                assert(false)\n                return cb(erro);\n              } else {\n                return walk(ds, acc, m, cb);\n              }\n            });\n          } else {\n            return cb(err);\n          }\n        } else {\n          if (stat.isDirectory()) {\n            return walk(ds, acc, m, cb);\n          } else {\n            return cb(new Error(\"Failed to mkdir \" + dir + \": File exists\\n\"));\n          }\n        }\n      });\n    } else {\n      return cb();\n    }\n  };\n  return walk(dirs, walker, mode, callback);\n};\n\n// file.mkdirsSync\n//\n// Synchronus version of file.mkdirs\n//\n// Given a path to a directory, create it, and all the intermediate directories\n// as well\n// \n// @path: the path to create\n// @mode: the file mode to create the directory with:\n//    ex: file.mkdirs(\"/tmp/dir\", 755, function () {})\nexports.mkdirsSync = function (_path, mode) {\n  if (_path[0] !== \"/\") {\n    _path = path.join(process.cwd(), _path)\n  }\n\n  var dirs = _path.split(\"/\");\n  var walker = [dirs.shift()];\n\n  dirs.reduce(function (acc, d) {\n    acc.push(d);\n    var dir = acc.join(\"/\");\n    \n    try {\n      var stat = fs.statSync(dir);\n      if (!stat.isDirectory()) {\n        throw \"Failed to mkdir \" + dir + \": File exists\";\n      }\n    } catch (err) {\n      fs.mkdirSync(dir, mode);\n    }\n    return acc;\n  }, walker);\n};\n\n// file.walk\n//\n// Given a path to a directory, walk the fs below that directory\n// \n// @start: the path to startat\n// @callback: called for each new directory we enter\n//    ex: file.walk(\"/tmp\", function(error, path, dirs, name) {})\n//\n//    path is the current directory we're in\n//    dirs is the list of directories below it\n//    names is the list of files in it\n//\nexports.walk = function (start, callback) {\n  fs.lstat(start, function (err, stat) {\n    if (err) { return callback(err) }\n    if (stat.isDirectory()) {\n\n      fs.readdir(start, function (err, files) {\n        var coll = files.reduce(function (acc, i) {\n          var abspath = path.join(start, i);\n\n          if (fs.statSync(abspath).isDirectory()) {\n            exports.walk(abspath, callback);\n            acc.dirs.push(abspath);\n          } else {\n            acc.names.push(abspath);\n          }\n\n          return acc;\n        }, {\"names\": [], \"dirs\": []});\n\n        return callback(null, start, coll.dirs, coll.names);\n      });\n    } else {\n      return callback(new Error(\"path: \" + start + \" is not a directory\"));\n    }\n  });\n};\n\n// file.walkSync\n//\n// Synchronus version of file.walk\n//\n// Given a path to a directory, walk the fs below that directory\n// \n// @start: the path to startat\n// @callback: called for each new directory we enter\n//    ex: file.walk(\"/tmp\", function(error, path, dirs, name) {})\n//\n//    path is the current directory we're in\n//    dirs is the list of directories below it\n//    names is the list of files in it\n//\nexports.walkSync = function (start, callback) {\n  var stat = fs.statSync(start);\n\n  if (stat.isDirectory()) {\n    var filenames = fs.readdirSync(start);\n\n    var coll = filenames.reduce(function (acc, name) {\n      var abspath = path.join(start, name);\n\n      if (fs.statSync(abspath).isDirectory()) {\n        acc.dirs.push(name);\n      } else {\n        acc.names.push(name);\n      }\n\n      return acc;\n    }, {\"names\": [], \"dirs\": []});\n\n    callback(start, coll.dirs, coll.names);\n\n    coll.dirs.forEach(function (d) {\n      var abspath = path.join(start, d);\n      exports.walkSync(abspath, callback);\n    });\n\n  } else {\n    throw new Error(\"path: \" + start + \" is not a directory\");\n  }\n};\n\nexports.path = {};\n\nexports.path.abspath = function (to) {\n  var from;\n  switch (to.charAt(0)) {\n    case \"~\": from = process.env.HOME; to = to.substr(1); break\n    case \"/\": from = \"\"; break\n    default : from = process.cwd(); break\n  }\n  return path.join(from, to);\n}\n\nexports.path.relativePath = function (base, compare) {\n  base = base.split(\"/\");\n  compare = compare.split(\"/\");\n\n  if (base[0] == \"\") {\n    base.shift();\n  }\n\n  if (compare[0] == \"\") {\n    compare.shift();\n  }\n\n  var l = compare.length;\n\n  for (var i = 0; i < l; i++) {\n    if (!base[i] || (base[i] != compare[i])) {\n      return compare.slice(i).join(\"/\");\n    }\n  }\n\n  return \"\"\n};\n\nexports.path.join = function (head, tail) {\n  if (head == \"\") {\n    return tail;\n  } else {\n    return path.join(head, tail);\n  }\n};\n\n\n//@ sourceURL=/node_modules/file/lib/file.js"
));

require.define("assert", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "// UTILITY\nvar util = require('util');\nvar pSlice = Array.prototype.slice;\n\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.message = options.message;\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  var stackStartFunction = options.stackStartFunction || fail;\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  }\n};\nutil.inherits(assert.AssertionError, Error);\n\nfunction replacer(key, value) {\n  if (value === undefined) {\n    return '' + value;\n  }\n  if (typeof value === 'number' && (isNaN(value) || !isFinite(value))) {\n    return value.toString();\n  }\n  if (typeof value === 'function' || value instanceof RegExp) {\n    return value.toString();\n  }\n  return value;\n}\n\nfunction truncate(s, n) {\n  if (typeof s == 'string') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\n\nassert.AssertionError.prototype.toString = function() {\n  if (this.message) {\n    return [this.name + ':', this.message].join(' ');\n  } else {\n    return [\n      this.name + ':',\n      truncate(JSON.stringify(this.actual, replacer), 128),\n      this.operator,\n      truncate(JSON.stringify(this.expected, replacer), 128)\n    ].join(' ');\n  }\n};\n\n// assert.AssertionError instanceof Error\n\nassert.AssertionError.__proto__ = Error.prototype;\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!!!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {\n    if (actual.length != expected.length) return false;\n\n    for (var i = 0; i < actual.length; i++) {\n      if (actual[i] !== expected[i]) return false;\n    }\n\n    return true;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (typeof actual != 'object' && typeof expected != 'object') {\n    return actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b) {\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b);\n  }\n  try {\n    var ka = Object.keys(a),\n        kb = Object.keys(b),\n        key, i;\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key])) return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (expected instanceof RegExp) {\n    return expected.test(actual);\n  } else if (actual instanceof expected) {\n    return true;\n  } else if (expected.call({}, actual) === true) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  try {\n    block();\n  } catch (e) {\n    actual = e;\n  }\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail('Missing expected exception' + message);\n  }\n\n  if (!shouldThrow && expectedException(actual, expected)) {\n    fail('Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [true].concat(pSlice.call(arguments)));\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [false].concat(pSlice.call(arguments)));\n};\n\nassert.ifError = function(err) { if (err) {throw err;}};\n\n//@ sourceURL=assert"
));

require.define("util", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var events = require('events');\n\nexports.print = function () {};\nexports.puts = function () {};\nexports.debug = function() {};\n\nexports.inspect = function(obj, showHidden, depth, colors) {\n  var seen = [];\n\n  var stylize = function(str, styleType) {\n    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n    var styles =\n        { 'bold' : [1, 22],\n          'italic' : [3, 23],\n          'underline' : [4, 24],\n          'inverse' : [7, 27],\n          'white' : [37, 39],\n          'grey' : [90, 39],\n          'black' : [30, 39],\n          'blue' : [34, 39],\n          'cyan' : [36, 39],\n          'green' : [32, 39],\n          'magenta' : [35, 39],\n          'red' : [31, 39],\n          'yellow' : [33, 39] };\n\n    var style =\n        { 'special': 'cyan',\n          'number': 'blue',\n          'boolean': 'yellow',\n          'undefined': 'grey',\n          'null': 'bold',\n          'string': 'green',\n          'date': 'magenta',\n          // \"name\": intentionally not styling\n          'regexp': 'red' }[styleType];\n\n    if (style) {\n      return '\\033[' + styles[style][0] + 'm' + str +\n             '\\033[' + styles[style][1] + 'm';\n    } else {\n      return str;\n    }\n  };\n  if (! colors) {\n    stylize = function(str, styleType) { return str; };\n  }\n\n  function format(value, recurseTimes) {\n    // Provide a hook for user-specified inspect functions.\n    // Check that value is an object with an inspect function on it\n    if (value && typeof value.inspect === 'function' &&\n        // Filter out the util module, it's inspect function is special\n        value !== exports &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      return value.inspect(recurseTimes);\n    }\n\n    // Primitive types cannot have properties\n    switch (typeof value) {\n      case 'undefined':\n        return stylize('undefined', 'undefined');\n\n      case 'string':\n        var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                                 .replace(/'/g, \"\\\\'\")\n                                                 .replace(/\\\\\"/g, '\"') + '\\'';\n        return stylize(simple, 'string');\n\n      case 'number':\n        return stylize('' + value, 'number');\n\n      case 'boolean':\n        return stylize('' + value, 'boolean');\n    }\n    // For some reason typeof null is \"object\", so special case here.\n    if (value === null) {\n      return stylize('null', 'null');\n    }\n\n    // Look up the keys of the object.\n    var visible_keys = Object_keys(value);\n    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;\n\n    // Functions without properties can be shortcutted.\n    if (typeof value === 'function' && keys.length === 0) {\n      if (isRegExp(value)) {\n        return stylize('' + value, 'regexp');\n      } else {\n        var name = value.name ? ': ' + value.name : '';\n        return stylize('[Function' + name + ']', 'special');\n      }\n    }\n\n    // Dates without properties can be shortcutted\n    if (isDate(value) && keys.length === 0) {\n      return stylize(value.toUTCString(), 'date');\n    }\n\n    var base, type, braces;\n    // Determine the object type\n    if (isArray(value)) {\n      type = 'Array';\n      braces = ['[', ']'];\n    } else {\n      type = 'Object';\n      braces = ['{', '}'];\n    }\n\n    // Make functions say that they are functions\n    if (typeof value === 'function') {\n      var n = value.name ? ': ' + value.name : '';\n      base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';\n    } else {\n      base = '';\n    }\n\n    // Make dates with properties first say the date\n    if (isDate(value)) {\n      base = ' ' + value.toUTCString();\n    }\n\n    if (keys.length === 0) {\n      return braces[0] + base + braces[1];\n    }\n\n    if (recurseTimes < 0) {\n      if (isRegExp(value)) {\n        return stylize('' + value, 'regexp');\n      } else {\n        return stylize('[Object]', 'special');\n      }\n    }\n\n    seen.push(value);\n\n    var output = keys.map(function(key) {\n      var name, str;\n      if (value.__lookupGetter__) {\n        if (value.__lookupGetter__(key)) {\n          if (value.__lookupSetter__(key)) {\n            str = stylize('[Getter/Setter]', 'special');\n          } else {\n            str = stylize('[Getter]', 'special');\n          }\n        } else {\n          if (value.__lookupSetter__(key)) {\n            str = stylize('[Setter]', 'special');\n          }\n        }\n      }\n      if (visible_keys.indexOf(key) < 0) {\n        name = '[' + key + ']';\n      }\n      if (!str) {\n        if (seen.indexOf(value[key]) < 0) {\n          if (recurseTimes === null) {\n            str = format(value[key]);\n          } else {\n            str = format(value[key], recurseTimes - 1);\n          }\n          if (str.indexOf('\\n') > -1) {\n            if (isArray(value)) {\n              str = str.split('\\n').map(function(line) {\n                return '  ' + line;\n              }).join('\\n').substr(2);\n            } else {\n              str = '\\n' + str.split('\\n').map(function(line) {\n                return '   ' + line;\n              }).join('\\n');\n            }\n          }\n        } else {\n          str = stylize('[Circular]', 'special');\n        }\n      }\n      if (typeof name === 'undefined') {\n        if (type === 'Array' && key.match(/^\\d+$/)) {\n          return str;\n        }\n        name = JSON.stringify('' + key);\n        if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n          name = name.substr(1, name.length - 2);\n          name = stylize(name, 'name');\n        } else {\n          name = name.replace(/'/g, \"\\\\'\")\n                     .replace(/\\\\\"/g, '\"')\n                     .replace(/(^\"|\"$)/g, \"'\");\n          name = stylize(name, 'string');\n        }\n      }\n\n      return name + ': ' + str;\n    });\n\n    seen.pop();\n\n    var numLinesEst = 0;\n    var length = output.reduce(function(prev, cur) {\n      numLinesEst++;\n      if (cur.indexOf('\\n') >= 0) numLinesEst++;\n      return prev + cur.length + 1;\n    }, 0);\n\n    if (length > 50) {\n      output = braces[0] +\n               (base === '' ? '' : base + '\\n ') +\n               ' ' +\n               output.join(',\\n  ') +\n               ' ' +\n               braces[1];\n\n    } else {\n      output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n    }\n\n    return output;\n  }\n  return format(obj, (typeof depth === 'undefined' ? 2 : depth));\n};\n\n\nfunction isArray(ar) {\n  return ar instanceof Array ||\n         Array.isArray(ar) ||\n         (ar && ar !== Object.prototype && isArray(ar.__proto__));\n}\n\n\nfunction isRegExp(re) {\n  return re instanceof RegExp ||\n    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');\n}\n\n\nfunction isDate(d) {\n  if (d instanceof Date) return true;\n  if (typeof d !== 'object') return false;\n  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);\n  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);\n  return JSON.stringify(proto) === JSON.stringify(properties);\n}\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\nexports.log = function (msg) {};\n\nexports.pump = null;\n\nvar Object_keys = Object.keys || function (obj) {\n    var res = [];\n    for (var key in obj) res.push(key);\n    return res;\n};\n\nvar Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {\n    var res = [];\n    for (var key in obj) {\n        if (Object.hasOwnProperty.call(obj, key)) res.push(key);\n    }\n    return res;\n};\n\nvar Object_create = Object.create || function (prototype, properties) {\n    // from es5-shim\n    var object;\n    if (prototype === null) {\n        object = { '__proto__' : null };\n    }\n    else {\n        if (typeof prototype !== 'object') {\n            throw new TypeError(\n                'typeof prototype[' + (typeof prototype) + '] != \\'object\\''\n            );\n        }\n        var Type = function () {};\n        Type.prototype = prototype;\n        object = new Type();\n        object.__proto__ = prototype;\n    }\n    if (typeof properties !== 'undefined' && Object.defineProperties) {\n        Object.defineProperties(object, properties);\n    }\n    return object;\n};\n\nexports.inherits = function(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object_create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n};\n\n//@ sourceURL=util"
));

require.define("events", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "if (!process.EventEmitter) process.EventEmitter = function () {};\n\nvar EventEmitter = exports.EventEmitter = process.EventEmitter;\nvar isArray = typeof Array.isArray === 'function'\n    ? Array.isArray\n    : function (xs) {\n        return Object.toString.call(xs) === '[object Array]'\n    }\n;\n\n// By default EventEmitters will print a warning if more than\n// 10 listeners are added to it. This is a useful default which\n// helps finding memory leaks.\n//\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nvar defaultMaxListeners = 10;\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!this._events) this._events = {};\n  this._events.maxListeners = n;\n};\n\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == 'function') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('addListener only takes instances of Function');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == \"newListeners\"! Before\n  // adding it to the listeners, first emit \"newListeners\".\n  this.emit('newListener', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n\n    // Check for listener leak\n    if (!this._events[type].warned) {\n      var m;\n      if (this._events.maxListeners !== undefined) {\n        m = this._events.maxListeners;\n      } else {\n        m = defaultMaxListeners;\n      }\n\n      if (m && m > 0 && this._events[type].length > m) {\n        this._events[type].warned = true;\n        console.error('(node) warning: possible EventEmitter memory ' +\n                      'leak detected. %d listeners added. ' +\n                      'Use emitter.setMaxListeners() to increase limit.',\n                      this._events[type].length);\n        console.trace();\n      }\n    }\n\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('removeListener only takes instances of Function');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = list.indexOf(listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n\n//@ sourceURL=events"
));

require.define("/node_modules/system/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\"main\":\"engines/node/system\"}\n//@ sourceURL=/node_modules/system/package.json"
));

require.define("/node_modules/system/engines/node/system.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "'use strict'\n\nvar print, stdin\n\ntry { // node >= 0.3.0\n  print = require('util').puts\n} catch (e) { // node <= 0.3.0\n  print = require('sys').puts\n}\n\nObject.defineProperties(exports, {\n  stdout: {\n    value: process.stdout,\n    enumerable: true\n  },\n  stdin: {\n    get: function() {\n      return stdin || (stdin = process.openStdin())\n    },\n    enumerable: true\n  },\n  stderr: {\n    get: function() {\n      return stdin || (stdin = process.openStdin())\n    },\n    enumerable: true\n  },\n  env: {\n    value: process.env,\n    enumerable: true\n  },\n  args: {\n    value: process.argv,\n    enumerable: true\n  },\n  print: {\n    value: print,\n    enumerable: true\n  },\n  engine: {\n    value: 'node',\n    enumerable: true\n  }\n})\n\n//@ sourceURL=/node_modules/system/engines/node/system.js"
));

require.define("sys", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = require('util');\n\n//@ sourceURL=sys"
));

require.define("/jsmm/jsmm.safe.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/*jshint node:true*/\n\"use strict\";\n\nmodule.exports = function(jsmm) {\n\trequire('./jsmm.func')(jsmm);\n\t\n\tvar getNode = function(obj) {\n\t\t//return '{line: ' + obj.startPos.line + ', column: ' + obj.startPos.column + '}';\n\t\treturn 'jsmmtree.nodes[' + obj.id + ']';\n\t};\n\t\n\tvar getScope = function() {\n\t\treturn '(jsmmscopeInner||jsmmscopeOuter)';\n\t};\n\n\tvar hooksBefore = function(node) {\n\t\tif (node.hooksBefore.length > 0) {\n\t\t\treturn getNode(node) + '.runHooksBefore(' + getScope() + ');';\n\t\t} else {\n\t\t\treturn '';\n\t\t}\n\t};\n\n\tvar hooksAfter = function(node) {\n\t\tif (node.hooksAfter.length > 0) {\n\t\t\treturn getNode(node) + '.runHooksAfter(' + getScope() + ');';\n\t\t} else {\n\t\t\treturn '';\n\t\t}\n\t};\n\t\n\t/* statementList */\n\tjsmm.nodes.Program.prototype.getSafeCode = function() {\n\t\tvar output = 'new function() {';\n\t\toutput += 'return function(jsmm, jsmmtree, jsmmscope) {';\n\t\toutput += 'return function() { var jsmmscopeInner, jsmmscopeOuter = new jsmm.func.Scope(jsmmscope);\\n';\n\t\toutput += 'var jsmmExecutionCounter = 0;\\n';\n\t\toutput += 'var jsmmCallStackDepth = 0;\\n';\n\t\toutput += this.statementList.getSafeCode() + 'return jsmmscopeOuter; }; }; }';\n\t\treturn output;\n\t};\n\t\n\tjsmm.nodes.Program.prototype.getSafeFunction = function(scope) {\n\t\t/*jshint evil:true*/\n\t\treturn eval(this.getSafeCode())(jsmm, this.tree, scope);\n\t};\n\t\n\t/* statements */\n\tjsmm.nodes.StatementList.prototype.getSafeCode = function() {\n\t\tvar output = 'jsmmExecutionCounter += ' + (this.statements.length+1) + ';\\n';\n\t\toutput += ' jsmm.func.checkExecutionCounter(' + getNode(this) + ', jsmmExecutionCounter);\\n';\n\t\tfor (var i=0; i<this.statements.length; i++) {\n\t\t\toutput += this.statements[i].getSafeCode() + '\\n';\n\t\t\tif (jsmm.verbose) {\n\t\t\t\toutput += 'console.log(\"after line ' + this.statements[i].endPos.line + ':\");\\n';\n\t\t\t\toutput += 'console.log(' +  getScope() + ');\\n';\n\t\t\t\toutput += 'console.log(\" \");\\n';\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t};\n\t\n\t/* statement */\n\tjsmm.nodes.CommonSimpleStatement.prototype.getSafeCode = function() {\n\t\treturn hooksBefore(this) + this.statement.getSafeCode() + \";\" + hooksAfter(this);\n\t};\n\t\n\t/* identifier, symbol */\n\tjsmm.nodes.PostfixStatement.prototype.getSafeCode = function() {\n\t\treturn 'jsmm.func.postfix(' + getNode(this) + ', ' + this.identifier.getSafeCode() + ', \"' + this.symbol + '\")';\n\t};\n\t\n\t/* identifier, symbol, expression */\n\tjsmm.nodes.AssignmentStatement.prototype.getSafeCode = function() {\n\t\treturn 'jsmm.func.assignment(' + getNode(this) + ', ' + this.identifier.getSafeCode() + ', \"' + this.symbol + '\", ' + this.expression.getSafeCode() + ')';\n\t};\n\t\n\t/* items */\n\tjsmm.nodes.VarStatement.prototype.getSafeCode = function() {\n\t\tvar output = this.items[0].getSafeCode();\n\t\tfor (var i=1; i<this.items.length; i++) {\n\t\t\toutput += ', ' + this.items[i].getSafeCode();\n\t\t}\n\t\treturn output;\n\t};\n\t\n\t/* name, assignment */\n\tjsmm.nodes.VarItem.prototype.getSafeCode = function() {\n\t\tvar output = 'jsmm.func.varItem(' + getNode(this) + ', ' +  getScope() + ', \"' + this.name + '\")';\n\t\tif (this.assignment !== null) {\n\t\t\t// ; is invalid in for loops\n\t\t\t// this should be possible in JS for normal statements as well\n\t\t\toutput += ', ' + this.assignment.getSafeCode();\n\t\t}\n\t\treturn output;\n\t};\n\t\n\t/* expression */\n\tjsmm.nodes.ReturnStatement.prototype.getSafeCode = function() {\n\t\tvar output = hooksBefore(this);\n\t\tif (this.expression === null) {\n\t\t\toutput += 'var jsmmtemp = undefined';\n\t\t} else {\n\t\t\toutput += 'var jsmmtemp = ' + this.expression.getSafeCode() + ';';\n\t\t}\n\t\toutput += getNode(this) + '.iterateRunHooksAfter(' + getScope() + ');';\n\t\toutput += 'jsmmCallStackDepth--;';\n\t\toutput += 'return jsmm.func.funcReturn(' + getNode(this) + ', jsmmtemp);';\n\t\treturn output;\n\t};\n\t\n\t/* expression1, symbol, expression2 */\n\tjsmm.nodes.BinaryExpression.prototype.getSafeCode = function() {\n\t\treturn 'jsmm.func.binary(' + getNode(this) + ', ' + this.expression1.getSafeCode() + ', \"' + this.symbol + '\", ' + this.expression2.getSafeCode() + ')';\n\t};\n\t\n\t/* symbol, expression */\n\tjsmm.nodes.UnaryExpression.prototype.getSafeCode = function() {\n\t\treturn 'jsmm.func.unary(' + getNode(this) + ', \"' + this.symbol + '\", ' + this.expression.getSafeCode() + ')';\n\t};\n\t\n\t/* number */\n\tjsmm.nodes.NumberLiteral.prototype.getSafeCode = function() {\n\t\treturn 'jsmm.func.number(' + getNode(this) + ', ' + this.number + ')';\n\t};\n\t\n\t/* str */\n\tjsmm.nodes.StringLiteral.prototype.getSafeCode = function() {\n\t\treturn 'jsmm.func.string(' + getNode(this) + ', ' + JSON.stringify(this.str) + ')';\n\t};\n\t\n\t/* bool */\n\tjsmm.nodes.BooleanLiteral.prototype.getSafeCode = function() {\n\t\treturn 'jsmm.func.bool(' + getNode(this) + ', ' + (this.bool ? 'true' : 'false') + ')';\n\t};\n\t\n\t/* name */\n\tjsmm.nodes.NameIdentifier.prototype.getSafeCode = function() {\n\t\treturn 'jsmm.func.name(' + getNode(this) + ', ' +  getScope() + ', \"' + this.name + '\")';\n\t};\n\t\n\t/* identifier, prop */\n\tjsmm.nodes.ObjectIdentifier.prototype.getSafeCode = function() {\n\t\treturn 'jsmm.func.object(' + getNode(this) + ', ' + this.identifier.getSafeCode() + ', \"' + this.prop + '\")';\n\t};\n\t\n\t/* identifier, expression */\n\tjsmm.nodes.ArrayIdentifier.prototype.getSafeCode = function() {\n\t\treturn 'jsmm.func.array(' + getNode(this) + ', ' + this.identifier.getSafeCode() + ', ' + this.expression.getSafeCode() + ')';\n\t};\n\t\n\t/* identifier, expressionArgs */\n\tjsmm.nodes.FunctionCall.prototype.getSafeCode = function() {\n\t\tvar output = 'jsmm.func.funcCall(' + getNode(this) + ', ' + this.identifier.getSafeCode() + ', [';\n\t\tif (this.expressionArgs.length > 0) output += this.expressionArgs[0].getSafeCode();\n\t\tfor (var i=1; i<this.expressionArgs.length; i++) {\n\t\t\toutput += \", \" + this.expressionArgs[i].getSafeCode();\n\t\t}\n\t\treturn output + '])';\n\t};\n\t\n\t/* functionCall */\n\tjsmm.nodes.CallStatement.prototype.getSafeCode = function() {\n\t\treturn this.functionCall.getSafeCode();\n\t};\n\t\n\t/* expression, statementList, elseBlock */\n\tjsmm.nodes.IfBlock.prototype.getSafeCode = function() {\n\t\tvar output = hooksBefore(this);\n\t\toutput += \"if (jsmm.func.conditional(\" + getNode(this) + ', \"if\", ' + this.expression.getSafeCode() + \")) {\\n\";\n\t\toutput += this.statementList.getSafeCode() + hooksAfter(this) + '}';\n\t\toutput += ' else {\\n'  + hooksAfter(this) + '\\n';\n\t\tif (this.elseBlock !== null) {\n\t\t\toutput += this.elseBlock.getSafeCode() + '\\n';\n\t\t}\n\t\toutput += '}';\n\t\treturn output;\n\t};\n\t\n\t/* ifBlock */\n\tjsmm.nodes.ElseIfBlock.prototype.getSafeCode = function() {\n\t\treturn this.ifBlock.getSafeCode();\n\t};\n\t\n\t/* statementList */\n\tjsmm.nodes.ElseBlock.prototype.getSafeCode = function() {\n\t\treturn hooksBefore(this) + '\\n' + this.statementList.getSafeCode() + hooksAfter(this);\n\t};\n\t\n\t/* expression, statementList */\n\tjsmm.nodes.WhileBlock.prototype.getSafeCode = function() {\n\t\tvar output = hooksBefore(this) + '\\n';\n\t\toutput += 'while (jsmm.func.conditional(' + getNode(this) + ', \"while\", ' + this.expression.getSafeCode() + '))';\n\t\toutput += '{\\n' + this.statementList.getSafeCode() + \"}\\n\" + hooksAfter(this);\n\t\treturn output;\n\t};\n\t\n\t/* statement1, expression, statement2, statementList */\n\tjsmm.nodes.ForBlock.prototype.getSafeCode = function() {\n\t\tvar output = hooksBefore(this) + '\\n';\n\t\toutput += \"for (\" + this.statement1.getSafeCode() + '; ';\n\t\toutput += 'jsmm.func.conditional(' + getNode(this) + ', \"for\", ' + this.expression.getSafeCode() + \"); \";\n\t\toutput += this.statement2.getSafeCode() + \") {\\n\" + this.statementList.getSafeCode() + \"}\\n\";\n\t\toutput += hooksAfter(this);\n\t\treturn output;\n\t};\n\t\n\t/* name, nameArgs, statementList */\n\tjsmm.nodes.FunctionDeclaration.prototype.getSafeCode = function() {\n\t\tvar output = 'jsmm.func.funcDecl(' + getNode(this) + ', jsmmscopeOuter, \"' + this.name + '\", ';\n\t\toutput += 'function' + this.getArgList() + \"{\\n\";\n\t\toutput += 'var jsmmscopeInner = new jsmm.func.Scope({';\n\t\tif (this.nameArgs.length > 0) output += '\"' + this.nameArgs[0] + '\": ' + this.nameArgs[0];\n\t\tfor (var i=1; i<this.nameArgs.length; i++) {\n\t\t\toutput += ', \"' + this.nameArgs[i] + '\": ' + this.nameArgs[i];\n\t\t}\n\t\toutput += '}, jsmmscopeOuter);\\n';\n\t\toutput += 'jsmmCallStackDepth++;';\n\t\toutput += 'jsmm.func.funcEnter(' + getNode(this) + ', ' + getScope() + ', jsmmCallStackDepth);\\n';\n\t\toutput += hooksBefore(this) + '\\n';\n\t\tif (jsmm.verbose) {\n\t\t\toutput += 'console.log(\"after entering ' + this.name + ':\");\\n';\n\t\t\toutput += 'console.log(jsmmscopeInner);\\n';\n\t\t\toutput += 'console.log(\" \");\\n';\n\t\t}\n\t\toutput += this.statementList.getSafeCode();\n\t\toutput += hooksAfter(this) + '\\n';\n\t\toutput += 'jsmmCallStackDepth--;';\n\t\toutput += 'return jsmm.func.funcReturn(' + getNode(this) + ');\\n';\n\t\toutput += '});';\n\t\treturn output;\n\t};\n};\n\n//@ sourceURL=/jsmm/jsmm.safe.js"
));

require.define("/jsmm/jsmm.func.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/*jshint node:true*/\n\"use strict\";\n\nmodule.exports = function(jsmm) {\n\trequire('./jsmm.msg')(jsmm);\n\t\n\tjsmm.func = {};\n\tjsmm.func.maxCallStackDepth = 100;\n\tjsmm.func.maxExecutionCounter = 4000;\n\t\n\tvar findVar = function(scope, name) {\n\t\tdo {\n\t\t\tif (scope.vars[name] !== undefined) {\n\t\t\t\treturn scope.vars[name];\n\t\t\t}\n\t\t\tscope = scope.parent;\n\t\t} while(scope !== null);\n\t\treturn undefined;\n\t};\n\n\tvar getValue = function(node, expression) {\n\t\tif (expression.value === undefined) {\n\t\t\tthrow new jsmm.msg.Error(node, function(f){ return f(expression.name) + ' is ' + f('undefined'); });\n\t\t} else if (expression.value === null) {\n\t\t\tthrow new jsmm.msg.Error(node, function(f){ return f(expression.name) + ' is ' + f('null'); });\n\t\t} else if (typeof expression.value === 'number' && !isFinite(expression.value)) {\n\t\t\tthrow new jsmm.msg.Error(node, function(f){ return f(expression.name) + ' is not a valid number'; });\n\t\t} else if (typeof expression.value === 'object' && expression.value.augmented === 'variable') {\n\t\t\treturn expression.value.get(node, expression.value.name);\n\t\t} else {\n\t\t\treturn expression.value;\n\t\t}\n\t};\n\t\n\tjsmm.func.Scope = function(vars, parent) {\n\t\tthis.vars = {};\n\t\tfor(var name in vars) {\n\t\t\tthis.vars[name] = {name: name, value: vars[name]};\n\t\t}\n\t\tthis.parent = parent || null;\n\t};\n\n\tjsmm.func.stringify = function(node, value) {\n\t\tif (typeof value === 'function') return '[function]';\n\t\telse if (typeof value === 'object' && value.augmented === 'function') return '[function]';\n\t\telse if (typeof value === 'object' && value.augmented === 'variable') return JSON.stringify(value.get(node, value.name));\n\t\telse if (Object.prototype.toString.call(value) === '[object Array]') return '[array]';\n\t\telse if (typeof value === 'object') return '[object]';\n\t\telse if (value === undefined) return 'undefined';\n\t\telse return JSON.stringify(value);\n\t};\n\t\n\tjsmm.func.postfix = function(node, variable, symbol) {\n\t\tif (typeof variable.value !== 'number') {\n\t\t\tthrow new jsmm.msg.Error(node, function(f){ return f(symbol) + ' not possible since ' + f(jsmm.func.stringify(node, variable.value)) + ' is not a number'; });\n\t\t} else {\n\t\t\tif (symbol === '++') {\n\t\t\t\tvariable.value++;\n\t\t\t} else {\n\t\t\t\tvariable.value--;\n\t\t\t}\n\t\t}\n\t\treturn variable;\n\t};\n\t\n\tjsmm.func.assignment = function(node, variable, symbol, expression) {\n\t\tvar value;\n\t\tif (symbol === '=') {\n\t\t\tvalue = getValue(node, expression);\n\t\t} else {\n\t\t\tvalue = getValue(node, jsmm.func.binary(node, variable, symbol, expression));\n\t\t}\n\t\tif (typeof variable.value === 'object' && variable.value.augmented === 'variable') {\n\t\t\ttry {\n\t\t\t\tvariable.value.set(node, variable.value.name, value);\n\t\t\t} catch (error) {\n\t\t\t\t// augmented variables should do their own error handling, so wrap the resulting strings or functions in jsmm messages\n\t\t\t\tif (['string', 'function'].indexOf(typeof error) >= 0) {\n\t\t\t\t\tthrow new jsmm.msg.Error(node, error);\n\t\t\t\t} else {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tvariable.value = value;\n\t\t}\n\t\treturn variable;\n\t};\n\t\n\tjsmm.func.varItem = function(node, scope, name) {\n\t\tscope.vars[name] = {name: name, value: undefined};\n\t\treturn scope.vars[name];\n\t};\n\t\n\tjsmm.func.binary = function(node, expression1, symbol, expression2) {\n\t\tvar value1 = getValue(node, expression1), value2 = getValue(node, expression2);\n\t\tif (['-', '*', '/', '%', '-=', '*=', '/=', '%=', '>', '>=', '<', '<='].indexOf(symbol) >= 0) {\n\t\t\tif (typeof value1 !== 'number' || !isFinite(value1)) {\n\t\t\t\tthrow new jsmm.msg.Error(node, function(f){ return f(symbol) + ' not possible since ' + f(jsmm.func.stringify(node, value1)) + ' is not a number'; });\n\t\t\t} else if (typeof value2 !== 'number' || !isFinite(value2)) {\n\t\t\t\tthrow new jsmm.msg.Error(node, function(f){ return f(symbol) + ' not possible since ' + f(jsmm.func.stringify(node, value2)) + ' is not a number'; });\n\t\t\t} else if (['/', '/=', '%', '%='].indexOf(symbol) >= 0 && value2 === 0) {\n\t\t\t\tthrow new jsmm.msg.Error(node, function(f){ return f(symbol) + ' not possible since it is a division by zero'; });\n\t\t\t}\n\t\t} else if (['+', '+='].indexOf(symbol) >= 0) {\n\t\t\tif (['number', 'string'].indexOf(typeof value1) < 0) {\n\t\t\t\tthrow new jsmm.msg.Error(node, function(f){ return f(symbol) + ' not possible since ' + f(jsmm.func.stringify(node, value1)) + ' is not a number or string'; });\n\t\t\t} else if (['number', 'string'].indexOf(typeof value2) < 0) {\n\t\t\t\tthrow new jsmm.msg.Error(node, function(f){ return f(symbol) + ' not possible since ' + f(jsmm.func.stringify(node, value2)) + ' is not a number or string'; });\n\t\t\t}\n\t\t} else if (['&&', '||'].indexOf(symbol) >= 0) {\n\t\t\tif (typeof value1 !== 'boolean') {\n\t\t\t\tthrow new jsmm.msg.Error(node, function(f){ return f(symbol) + ' not possible since ' + f(jsmm.func.stringify(node, value1)) + ' is not a boolean'; });\n\t\t\t} else if (typeof value2 !== 'boolean') {\n\t\t\t\tthrow new jsmm.msg.Error(node, function(f){ return f(symbol) + ' not possible since ' + f(jsmm.func.stringify(node, value2)) + ' is not a boolean'; });\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*jshint eqeqeq:false*/\n\t\tvar retVal;\n\t\tswitch(symbol) {\n\t\t\tcase '+': case '+=': retVal = value1 + value2; break;\n\t\t\tcase '-': case '-=': retVal = value1 - value2; break;\n\t\t\tcase '*': case '*=': retVal = value1 * value2; break;\n\t\t\tcase '/': case '/=': retVal = value1 / value2; break;\n\t\t\tcase '%': case '%=': retVal = value1 % value2; break;\n\t\t\tcase '>': retVal = value1 > value2; break;\n\t\t\tcase '>=': retVal = value1 >= value2; break;\n\t\t\tcase '<': retVal = value1 < value2; break;\n\t\t\tcase '<=': retVal = value1 <= value2; break;\n\t\t\tcase '&&': retVal = value1 && value2; break;\n\t\t\tcase '||': retVal = value1 || value2; break;\n\t\t\tcase '==': retVal = value1 == value2; break;\n\t\t\tcase '!=': retVal = value1 != value2; break;\n\t\t}\n\t\t\n\t\treturn {name: '(' + expression1.name + ' ' + symbol + ' ' + expression2.name + ')', value: retVal};\n\t};\n\t\n\tjsmm.func.unary = function(node, symbol, expression) {\n\t\tvar value = getValue(node, expression), retVal;\n\t\tif (symbol === '!') {\n\t\t\tif (typeof value !== 'boolean') {\n\t\t\t\tthrow new jsmm.msg.Error(node, function(f){ return f(symbol) + ' not possible since ' + f(jsmm.func.stringify(node, value)) + ' is not a boolean'; });\n\t\t\t} else {\n\t\t\t\t//return {name: symbol + expression.name, value: !value};\n\t\t\t\tretVal = !value;\n\t\t\t}\n\t\t} else {\n\t\t\tif (typeof value !== 'number') {\n\t\t\t\tthrow new jsmm.msg.Error(node, function(f){ return f(symbol) + ' not possible since ' + f(jsmm.func.stringify(node, value)) + ' is not a number'; });\n\t\t\t} else {\n\t\t\t\t//return {name: symbol + expression.name, value: (symbol==='+' ? value : -value)};\n\t\t\t\tretVal = (symbol === '+' ? value : -value);\n\t\t\t}\n\t\t}\n\t\treturn {name: '(' + symbol + expression.name + ')', value: retVal};\n\t};\n\t\n\tjsmm.func.number = function(node, num) {\n\t\treturn {name: jsmm.func.stringify(node, num), value: num};\n\t};\n\t\n\tjsmm.func.string = function(node, str) {\n\t\treturn {name: jsmm.func.stringify(node, str), value: str};\n\t};\n\t\n\tjsmm.func.bool = function(node, bool) {\n\t\treturn {name: jsmm.func.stringify(node, bool), value: bool};\n\t};\n\t\n\tjsmm.func.name = function(node, scope, name) {\n\t\tvar val = findVar(scope, name);\n\t\tif (val === undefined) {\n\t\t\tthrow new jsmm.msg.Error(node, function(f){ return 'Variable ' + f(name) + ' could not be found'; });\n\t\t} else {\n\t\t\treturn val;\n\t\t}\n\t};\n\t\n\tjsmm.func.object = function(node, object, property) {\n\t\tvar objectValue = getValue(node, object);\n\t\tif (objectValue[property] === undefined || objectValue.augmented !== undefined) {\n\t\t\tthrow new jsmm.msg.Error(node, function(f){ return 'Variable ' + f(object.name) + ' does not have property ' + f(property); });\n\t\t} else {\n\t\t\treturn {name: object.name + '.' + property, value: objectValue[property], parent: objectValue};\n\t\t}\n\t};\n\t\n\tjsmm.func.array = function(node, array, index) {\n\t\tvar arrayValue = getValue(node, array), indexValue = getValue(node, index);\n\t\tif (typeof indexValue !== 'number' && indexValue % 1 !== 0) {\n\t\t\tthrow new jsmm.msg.Error(node, function(f){ return 'Index ' + f(index.name) + ' is not an integer'; });\n\t\t} else if (Object.prototype.toString.call(arrayValue) !== '[object Array]') {\n\t\t\tthrow new jsmm.msg.Error(node, function(f){ return 'Variable ' + f(array.name) + ' is not an array'; });\n\t\t} else if (arrayValue[indexValue] === undefined) {\n\t\t\tthrow new jsmm.msg.Error(node, function(f){ return 'Array ' + f(array.name) + ' has no index ' + f(index.name); });\n\t\t} else {\n\t\t\treturn {name: array.name + '[' + index.name + ']', value: arrayValue[indexValue]};\n\t\t}\n\t};\n\t\n\tjsmm.func.conditional = function(node, type, expression) {\n\t\tvar value = getValue(node, expression);\n\t\tif (typeof value !== 'boolean') {\n\t\t\tthrow new jsmm.msg.Error(node, function(f){ return f(type) + ' is not possible since ' + f(expression.name) + ' is not a boolean'; });\n\t\t} else {\n\t\t\treturn value;\n\t\t}\n\t};\n\t\n\tjsmm.func.funcCall = function(node, func, args) {\n\t\tvar funcValue = getValue(node, func), funcArgs = [], appFunc;\n\n\t\tfor (var i=0; i<args.length; i++) {\n\t\t\tfuncArgs.push(getValue(node, args[i]));\n\t\t}\n\n\t\tif (typeof funcValue === 'object' && funcValue.augmented === 'function') {\n\t\t\ttry {\n\t\t\t\treturn jsmm.func.funcWrapResult(node, func, funcValue.func.call(func.parent || null, node, funcValue.name, funcArgs));\n\t\t\t} catch (error) {\n\t\t\t\t// augmented functions should do their own error handling, so wrap the resulting strings or functions in jsmm messages\n\t\t\t\tif (['string', 'function'].indexOf(typeof error) >= 0) {\n\t\t\t\t\tthrow new jsmm.msg.Error(node, error);\n\t\t\t\t} else {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (typeof funcValue !== 'function') {\n\t\t\tthrow new jsmm.msg.Error(node, function(f){ return 'Variable ' + f(func.name) + ' is not a function'; });\n\t\t} else {\n\t\t\treturn jsmm.func.funcWrapResult(node, func, funcValue.apply(func.parent || null, funcArgs));\n\t\t}\n\t};\n\t\n\tjsmm.func.funcWrapResult = function(node, func, result) {\n\t\tif (result === null) result = undefined;\n\t\treturn {name: func.name, value: result};\n\t};\n\t\n\tjsmm.func.funcDecl = function(node, scope, name, func) {\n\t\t// only check local scope for conflicts\n\t\tif (scope.vars[name] !== undefined) {\n\t\t\tif (typeof scope.vars[name].value === 'function' || (typeof scope.vars[name].value === 'object' && scope.vars[name].value.augmented === 'function')) {\n\t\t\t\tthrow new jsmm.msg.Error(node, function(f){ return 'Function ' + f(name) + ' cannot be declared since there already is a function with that name'; });\n\t\t\t} else {\n\t\t\t\tthrow new jsmm.msg.Error(node, function(f){ return 'Function ' + f(name) + ' cannot be declared since there already is a variable with that name'; });\n\t\t\t}\n\t\t} else {\n\t\t\tscope.vars[name] = {name: name, value: func};\n\t\t\treturn scope.vars[name];\n\t\t}\n\t};\n\t\n\n\tjsmm.func.funcEnter = function(node, scope, callStackDepth) {\n\t\t/*jshint loopfunc:true*/\n\t\tif (callStackDepth > jsmm.func.maxCallStackDepth) {\n\t\t\tthrow new jsmm.msg.Error(node, function(f){ return 'Too many nested function calls have been made already, perhaps there is infinite recursion somewhere'; });\n\t\t}\n\t\tfor (var name in scope.vars) {\n\t\t\tif (scope.vars[name].value === undefined) {\n\t\t\t\tthrow new jsmm.msg.Error(node, function(f){ return 'Variable ' + f(scope.vars[name].name) + ' is ' + f('undefined') + ', perhaps there are not enough arguments in the function call'; });\n\t\t\t} else if (scope.vars[name].value === null) {\n\t\t\t\tthrow new jsmm.msg.Error(node, function(f){ return 'Variable ' + f(scope.vars[name].name) + ' is ' + f('null'); });\n\t\t\t}\n\t\t}\n\t};\n\t\n\tjsmm.func.funcReturn = function(node, expression) {\n\t\tif (expression !== undefined) {\n\t\t\treturn getValue(node, expression);\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t};\n\t\n\tjsmm.func.checkExecutionCounter = function(node, executionCounter) {\n\t\tif (executionCounter > jsmm.func.maxExecutionCounter) {\n\t\t\tthrow new jsmm.msg.Error(node, function(f){ return 'Program takes too long to run'; });\n\t\t}\n\t};\n};\n\n//@ sourceURL=/jsmm/jsmm.func.js"
));

require.define("/jsmm/jsmm.msg.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/*jshint node:true*/\n\"use strict\";\n\nmodule.exports = function(jsmm) {\n\tjsmm.msg = {};\n\tjsmm.msg.Inline = function() { return this.init.apply(this, arguments); };\n\tjsmm.msg.Line = function() { return this.init.apply(this, arguments); };\n\tjsmm.msg.Continue = function() { return this.init.apply(this, arguments); };\n\tjsmm.msg.Error = function() { return this.init.apply(this, arguments); };\n\t\n\tjsmm.msg.addCommonMessageMethods = function(msg) {\n\t\tmsg.initMsg = function(msg) {\n\t\t\tvar message = (typeof msg === 'function') ? msg : function(f) { return msg; };\n\t\t\tthis.message = message(function f(val) { return val; });\n\t\t\tthis.html = message(function f(val) {\n\t\t\t\t// we assume that val is already JSON stringified\n\t\t\t\treturn '<span class=\"msg-value\">' + val.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;') + '</span>';\n\t\t\t});\n\t\t};\n\t\tmsg.loadLineLoc = function(lineLoc) {\n\t\t\tif (lineLoc.lineLoc !== undefined) lineLoc = lineLoc.lineLoc;\n\t\t\tthis.line = lineLoc.line || 0;\n\t\t\tthis.column = lineLoc.column || 0;\n\t\t\tif (typeof lineLoc.column2 === 'number' && lineLoc.column2 > lineLoc.column) {\n\t\t\t\tthis.column2 = lineLoc.column2;\n\t\t\t} else {\n\t\t\t\tthis.column2 = this.column;\n\t\t\t}\n\t\t};\n\t\treturn msg;\n\t};\n\t\n\tjsmm.msg.Inline.prototype = jsmm.msg.addCommonMessageMethods({\n\t\tinit: function(loc, msg) {\n\t\t\tthis.type = 'Inline';\n\t\t\tthis.loadLineLoc(loc);\n\t\t\tthis.initMsg(msg);\n\t\t}\n\t});\n\t\n\tjsmm.msg.Line.prototype = jsmm.msg.addCommonMessageMethods({\n\t\tinit: function(loc, msg, append) {\n\t\t\tthis.type = 'Line';\n\t\t\tthis.loadLineLoc(loc);\n\t\t\tthis.initMsg(msg);\n\t\t\tthis.append = append || false;\n\t\t}\n\t});\n\t\n\tjsmm.msg.Continue.prototype = jsmm.msg.addCommonMessageMethods({\n\t\tinit: function(loc) {\n\t\t\tthis.type = 'Continue';\n\t\t\tthis.loadLineLoc(loc);\n\t\t}\n\t});\n\t\n\tjsmm.msg.Error.prototype = jsmm.msg.addCommonMessageMethods({\n\t\tinit: function(loc, msg, more, orig) {\n\t\t\tthis.type = 'Error';\n\t\t\tthis.loadLineLoc(loc);\n\t\t\tthis.initMsg(msg);\n\t\t\tthis.more = more || '';\n\t\t\tthis.orig = orig || null;\n\t\t}\n\t});\n};\n\n//@ sourceURL=/jsmm/jsmm.msg.js"
));

require.define("/jsmm/jsmm.step.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/*jshint node:true*/\n\"use strict\";\n\nmodule.exports = function(jsmm) {\n\trequire('./jsmm.func')(jsmm);\n\trequire('./jsmm.msg')(jsmm);\n\t\n\tjsmm.step = {};\n\tjsmm.step.Stack = function() { return this.init.apply(this, arguments); };\n\tjsmm.step.StackElement = function() { return this.init.apply(this, arguments); };\n\t\n\tjsmm.step.Stack.prototype = {\n\t\tinit: function(tree, scope) {\n\t\t\tthis.elements = [new jsmm.step.StackElement(this, tree.programNode, new jsmm.func.Scope(scope))];\n\t\t\tthis.executionCounter = 0;\n\t\t\tthis.callStackDepth = 0;\n\t\t},\n\t\thasNext: function() {\n\t\t\treturn this.getLastStackElement() !== undefined;\n\t\t},\n\t\tstepNext: function(stack, se) {\n\t\t\treturn this.getLastStackElement().node.stepNext(this, this.getLastStackElement());\n\t\t},\n\t\t/// INTERNAL FUNCTIONS ///\n\t\tgetLastStackElement: function() {\n\t\t\tif (this.elements.length > 0) {\n\t\t\t\treturn this.elements[this.elements.length-1];\n\t\t\t} else {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t},\n\t\t// not strictly a pop since it returns the last element instead of the popped element\n\t\tup: function(arg) {\n\t\t\tthis.elements.pop();\n\t\t\tthis.getLastStackElement().args.push(arg);\n\t\t\treturn this.getLastStackElement();\n\t\t},\n\t\tupNext: function(arg) {\n\t\t\tvar se = this.up(arg);\n\t\t\treturn se.node.stepNext(this, se);\n\t\t},\n\t\tpushNode: function(node, scope) {\n\t\t\tthis.elements.push(new jsmm.step.StackElement(this, node, scope));\n\t\t\treturn node;\n\t\t},\n\t\tpushNodeNext: function(node, scope) {\n\t\t\tvar se = new jsmm.step.StackElement(this, node, scope);\n\t\t\tthis.elements.push(se);\n\t\t\treturn node.stepNext(this, se);\n\t\t}\n\t};\n\t\n\tjsmm.step.StackElement.prototype = {\n\t\tinit: function(stack, node, scope) {\n\t\t\tthis.stack = stack;\n\t\t\tthis.node = node;\n\t\t\tthis.scope = scope;\n\t\t\tthis.args = [];\n\t\t}\n\t};\n\t\n\t/* statementList */\n\tjsmm.nodes.Program.prototype.stepNext = function(stack, se) {\n\t\tswitch (se.args.length) {\n\t\t\tcase 0:\n\t\t\t\tstack.executionCounter = 0;\n\t\t\t\tstack.callStackDepth = 0;\n\t\t\t\treturn stack.pushNodeNext(this.statementList, se.scope);\n\t\t\tcase 1:\n\t\t\t\tstack.elements = [];\n\t\t\t\treturn [];\n\t\t}\n\t};\n\t\n\t/* statements */\n\tjsmm.nodes.StatementList.prototype.stepNext = function(stack, se) {\n\t\tif (jsmm.verbose && se.args.length > 0) {\n\t\t\tconsole.log('after line ' + this.statements[se.args.length-1].endPos.line + ':');\n\t\t\tconsole.log(se.scope);\n\t\t\tconsole.log(' ');\n\t\t}\n\t\t\n\t\tif (se.args.length === 0) {\n\t\t\tstack.executionCounter += this.statements.length+1;\n\t\t\tjsmm.func.checkExecutionCounter(this, stack.executionCounter);\n\t\t}\n\t\t\n\t\tif (se.args.length < this.statements.length) {\n\t\t\treturn stack.pushNodeNext(this.statements[se.args.length], se.scope);\n\t\t} else {\n\t\t\treturn stack.upNext(null);\n\t\t}\n\t};\n\t\n\t/* statement */\n\tjsmm.nodes.CommonSimpleStatement.prototype.stepNext = function(stack, se) {\n\t\tswitch (se.args.length) {\n\t\t\tcase 0:\n\t\t\t\tthis.runHooksBefore(se.scope);\n\t\t\t\treturn stack.pushNodeNext(this.statement, se.scope);\n\t\t\tcase 1:\n\t\t\t\tthis.runHooksAfter(se.scope);\n\t\t\t\treturn stack.upNext(null);\n\t\t}\n\t};\n\t\n\t/* identifier, symbol */\n\tjsmm.nodes.PostfixStatement.prototype.stepNext = function(stack, se) {\n\t\tswitch (se.args.length) {\n\t\t\tcase 0:\n\t\t\t\treturn stack.pushNodeNext(this.identifier, se.scope);\n\t\t\tcase 1:\n\t\t\t\tvar result = jsmm.func.postfix(this, se.args[0], this.symbol);\n\t\t\t\tstack.up(null);\n\t\t\t\tvar message = function(f) { return f(se.args[0].name) + ' = ' + f(jsmm.func.stringify(this, result.value)); };\n\t\t\t\treturn [new jsmm.msg.Inline(this, message), new jsmm.msg.Line(this, message)];\n\t\t}\n\t};\n\t\n\t/* identifier, symbol, expression */\n\tjsmm.nodes.AssignmentStatement.prototype.stepNext = function(stack, se) {\n\t\tswitch (se.args.length) {\n\t\t\tcase 0:\n\t\t\t\treturn stack.pushNodeNext(this.identifier, se.scope);\n\t\t\tcase 1:\n\t\t\t\treturn stack.pushNodeNext(this.expression, se.scope);\n\t\t\tcase 2:\n\t\t\t\tvar result = jsmm.func.assignment(this, se.args[0], this.symbol, se.args[1]);\n\t\t\t\tvar up = stack.up(result);\n\t\t\t\tvar append = (up.node.type === 'VarItem');\n\t\t\t\tvar message = function(f) { return f(se.args[0].name) + ' = ' + f(jsmm.func.stringify(this, result.value)); };\n\t\t\t\treturn [new jsmm.msg.Inline(this, message), new jsmm.msg.Line(this, message, append)];\n\t\t}\n\t};\n\t\n\t/* items */\n\tjsmm.nodes.VarStatement.prototype.stepNext = function(stack, se) {\n\t\tif (se.args.length === 0) {\n\t\t\tse.args.push(null);\n\t\t\treturn [new jsmm.msg.Line(this, ''),\n\t\t\t\tnew jsmm.msg.Continue(this)];\n\t\t} else if (se.args.length-1 < this.items.length) {\n\t\t\treturn stack.pushNodeNext(this.items[se.args.length-1], se.scope);\n\t\t} else {\n\t\t\treturn stack.upNext(null);\n\t\t}\n\t};\n\t\n\t/* name, assignment */\n\tjsmm.nodes.VarItem.prototype.stepNext = function(stack, se) {\n\t\tif (this.assignment === null) {\n\t\t\tjsmm.func.varItem(this, se.scope, this.name);\n\t\t\tvar ret = stack.upNext(null);\n\t\t\tret.push(new jsmm.msg.Line(this, 'undefined', true));\n\t\t\treturn ret;\n\t\t} else {\n\t\t\tswitch (se.args.length) {\n\t\t\t\tcase 0:\n\t\t\t\t\tjsmm.func.varItem(this, se.scope, this.name);\n\t\t\t\t\treturn stack.pushNodeNext(this.assignment, se.scope);\n\t\t\t\tcase 1:\n\t\t\t\t\treturn stack.upNext(null);\n\t\t\t}\n\t\t}\n\t};\n\t\n\t/* expression */\n\tjsmm.nodes.ReturnStatement.prototype.stepNext = function(stack, se) {\n\t\tif (this.expression === null) {\n\t\t\tstack.callStackDepth--;\n\t\t\tjsmm.func.funcReturn(this);\n\t\t\treturn stack.upNext(null);\n\t\t} else {\n\t\t\tswitch (se.args.length) {\n\t\t\t\tcase 0:\n\t\t\t\t\treturn stack.pushNodeNext(this.expression, se.scope);\n\t\t\t\tcase 1:\n\t\t\t\t\tthis.iterateRunHooksAfter(se.scope);\n\t\t\t\t\tvar lastStackElement = stack.getLastStackElement();\n\t\t\t\t\tstack.callStackDepth--;\n\t\t\t\t\tvar result = jsmm.func.funcReturn(this, se.args[0]);\n\t\t\t\t\twhile (!(lastStackElement.node.type === 'FunctionCall' ||\n\t\t\t\t\t\t\tlastStackElement.node.type === 'Program')) {\n\t\t\t\t\t\tlastStackElement = stack.up(result);\n\t\t\t\t\t}\n\t\t\t\t\t// Postcondition: lastStackElement is a FunctionCall or a Program\n\t\t\t\t\treturn [new jsmm.msg.Line(this, 'return ' + jsmm.func.stringify(this, se.args[0].value)),\n\t\t\t\t\t\tnew jsmm.msg.Continue(this)];\n\t\t\t}\n\t\t}\n\t};\n\t\n\t/* expression1, symbol, expression2 */\n\tjsmm.nodes.BinaryExpression.prototype.stepNext = function(stack, se) {\n\t\tswitch (se.args.length) {\n\t\t\tcase 0:\n\t\t\t\treturn stack.pushNodeNext(this.expression1, se.scope);\n\t\t\tcase 1:\n\t\t\t\treturn stack.pushNodeNext(this.expression2, se.scope);\n\t\t\tcase 2:\n\t\t\t\tvar result = jsmm.func.binary(this, se.args[0], this.symbol, se.args[1]);\n\t\t\t\tstack.up(result);\n\t\t\t\tvar that = this;\n\t\t\t\treturn [new jsmm.msg.Inline(this, function(f) {\n\t\t\t\t\treturn f(jsmm.func.stringify(this, se.args[0].value)) + ' ' + that.symbol + ' ' + f(jsmm.func.stringify(this, se.args[1].value)) + ' = ' + f(jsmm.func.stringify(this, result.value));\n\t\t\t\t})];\n\t\t}\n\t};\n\t\n\t/* symbol, expression */\n\tjsmm.nodes.UnaryExpression.prototype.stepNext = function(stack, se) {\n\t\tswitch (se.args.length) {\n\t\t\tcase 0:\n\t\t\t\treturn stack.pushNodeNext(this.expression, se.scope);\n\t\t\tcase 1:\n\t\t\t\tvar result = jsmm.func.unary(this, this.symbol, se.args[0]);\n\t\t\t\tstack.up(result);\n\t\t\t\tvar that = this;\n\t\t\t\treturn [new jsmm.msg.Inline(this, function(f) {\n\t\t\t\t\treturn that.symbol + f(jsmm.func.stringify(this, se.args[0].value)) + ' = ' + f(jsmm.func.stringify(this, result.value));\n\t\t\t\t})];\n\t\t}\n\t};\n\t\n\t/* number */\n\tjsmm.nodes.NumberLiteral.prototype.stepNext = function(stack, se) {\n\t\treturn stack.upNext(jsmm.func.number(this, this.number));\n\t};\n\t\n\t/* str */\n\tjsmm.nodes.StringLiteral.prototype.stepNext = function(stack, se) {\n\t\treturn stack.upNext(jsmm.func.string(this, this.str));\n\t};\n\t\n\t/* bool */\n\tjsmm.nodes.BooleanLiteral.prototype.stepNext = function(stack, se) {\n\t\treturn stack.upNext(jsmm.func.bool(this, this.bool));\n\t};\n\t\n\t/* name */\n\tjsmm.nodes.NameIdentifier.prototype.stepNext = function(stack, se) {\n\t\treturn stack.upNext(jsmm.func.name(this, se.scope, this.name));\n\t};\n\t\n\t/* identifier, prop */\n\tjsmm.nodes.ObjectIdentifier.prototype.stepNext = function(stack, se) {\n\t\tswitch (se.args.length) {\n\t\t\tcase 0:\n\t\t\t\treturn stack.pushNodeNext(this.identifier, se.scope);\n\t\t\tcase 1:\n\t\t\t\treturn stack.upNext(jsmm.func.object(this, se.args[0], this.prop));\n\t\t}\n\t};\n\t\n\t/* identifier, expression */\n\tjsmm.nodes.ArrayIdentifier.prototype.stepNext = function(stack, se) {\n\t\tswitch (se.args.length) {\n\t\t\tcase 0:\n\t\t\t\treturn stack.pushNodeNext(this.identifier, se.scope);\n\t\t\tcase 1:\n\t\t\t\treturn stack.pushNodeNext(this.expression, se.scope);\n\t\t\tcase 2:\n\t\t\t\treturn stack.upNext(jsmm.func.array(this, se.args[0], se.args[1]));\n\t\t}\n\t};\n\t\n\t/* identifier, expressionArgs */\n\tjsmm.nodes.FunctionCall.prototype.stepNext = function(stack, se) {\n\t\t// calculate function name once all the arguments are known\n\t\tif (se.args.length > this.expressionArgs.length) {\n\t\t\tvar name = se.args[0].name + '(';\n\t\t\tif (this.expressionArgs.length > 0) name += jsmm.func.stringify(this, se.args[1].value);\n\t\t\tfor (var i=1; i<this.expressionArgs.length; i++) {\n\t\t\t\tname += ', ' + jsmm.func.stringify(this, se.args[i+1].value);\n\t\t\t}\n\t\t\tname += ')';\n\t\t}\n\t\t\n\t\tvar result, up;\n\t\tif (se.args.length === 0) {\n\t\t\treturn stack.pushNodeNext(this.identifier, se.scope);\n\t\t} else if (se.args.length < this.expressionArgs.length+1) {\n\t\t\treturn stack.pushNodeNext(this.expressionArgs[se.args.length-1], se.scope);\n\t\t} else if (se.args.length === this.expressionArgs.length+1) {\n\t\t\tse.args.push(null);\n\t\t\t\n\t\t\treturn [new jsmm.msg.Inline(this, function(f) {\n\t\t\t\treturn 'calling ' + f(name);\n\t\t\t})];\n\t\t} else if (se.args.length === this.expressionArgs.length+2) {\n\t\t\t// first actual function call (all arguments are evaluated)\n\t\t\tresult = jsmm.func.funcCall(this, se.args[0], se.args.slice(1, se.args.length-1));\n\t\t\t\n\t\t\tif (result.value !== undefined && result.value[0] !== undefined && result.value[0] instanceof jsmm.msg.Inline) {\n\t\t\t\t// in this case the local function has been placed on the stack, so no moving up\n\t\t\t\treturn result.value;\n\t\t\t} else {\n\t\t\t\tup = stack.up(result);\n\t\t\t\t// fall through\n\t\t\t}\n\t\t} else {\n\t\t\t// in case of a user defined function, the result will be pushed on args\n\t\t\t// NOTE: this line is not used entirely correctly, as it is normally\n\t\t\t// called in the context of a function declaration, not a call\n\t\t\tresult = jsmm.func.funcWrapResult(this, se.args[0], se.args.pop());\n\t\t\tup = stack.up(result);\n\t\t\t// fall through\n\t\t}\n\t\t\n\t\tif (up.node.type === 'CallStatement') {\n\t\t\treturn [\n\t\t\t\tnew jsmm.msg.Line(this, function(f) { return f(name); }),\n\t\t\t\tnew jsmm.msg.Continue(this)\n\t\t\t];\n\t\t} else {\n\t\t\treturn [new jsmm.msg.Inline(this, function(f) { return f(name) + ' = ' + f(jsmm.func.stringify(this, result.value)); })];\n\t\t}\n\t};\n\t\n\t/* functionCall */\n\tjsmm.nodes.CallStatement.prototype.stepNext = function(stack, se) {\n\t\tswitch (se.args.length) {\n\t\t\tcase 0:\n\t\t\t\treturn stack.pushNodeNext(this.functionCall, se.scope);\n\t\t\tcase 1:\n\t\t\t\treturn stack.upNext(null);\n\t\t}\n\t};\n\t\n\t/* expression, statementList, elseBlock */\n\tjsmm.nodes.IfBlock.prototype.stepNext = function(stack, se) {\n\t\tswitch (se.args.length) {\n\t\t\tcase 0:\n\t\t\t\tthis.runHooksBefore(se.scope);\n\t\t\t\treturn stack.pushNodeNext(this.expression, se.scope);\n\t\t\tcase 1:\n\t\t\t\tif (jsmm.func.conditional(this, 'if', se.args[0])) {\n\t\t\t\t\treturn stack.pushNodeNext(this.statementList, se.scope);\n\t\t\t\t} else {\n\t\t\t\t\tthis.runHooksAfter(se.scope);\n\t\t\t\t\tif(this.elseBlock !== null) {\n\t\t\t\t\t\treturn stack.pushNodeNext(this.elseBlock, se.scope);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn stack.upNext(null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (se.args[1] !== 'else') this.runHooksAfter(this, se.scope);\n\t\t\t\treturn stack.upNext(null);\n\t\t}\n\t};\n\t\n\t/* ifBlock */\n\tjsmm.nodes.ElseIfBlock.prototype.stepNext = function(stack, se) {\n\t\tswitch (se.args.length) {\n\t\t\tcase 0:\n\t\t\t\treturn stack.pushNodeNext(this.ifBlock, se.scope);\n\t\t\tcase 1:\n\t\t\t\treturn stack.upNext('else');\n\t\t}\n\t};\n\t\n\t/* statementList */\n\tjsmm.nodes.ElseBlock.prototype.stepNext = function(stack, se) {\n\t\tswitch (se.args.length) {\n\t\t\tcase 0:\n\t\t\t\tthis.runHooksBefore(se.scope);\n\t\t\t\treturn stack.pushNodeNext(this.statementList, se.scope);\n\t\t\tcase 1:\n\t\t\t\tthis.runHooksAfter(se.scope);\n\t\t\t\treturn stack.upNext('else');\n\t\t}\n\t};\n\t\n\t/* expression, statementList */\n\tjsmm.nodes.WhileBlock.prototype.stepNext = function(stack, se) {\n\t\tswitch (se.args.length) {\n\t\t\tcase 0:\n\t\t\t\t// dummy value for runHooksBefore\n\t\t\t\tthis.runHooksBefore(se.scope);\n\t\t\t\tse.args.push(null);\n\t\t\t\t/* falls through */\n\t\t\tcase 1:\n\t\t\t\treturn stack.pushNodeNext(this.expression, se.scope);\n\t\t\tcase 2:\n\t\t\t\tif (jsmm.func.conditional(this, 'while', se.args[1])) {\n\t\t\t\t\treturn stack.pushNodeNext(this.statementList, se.scope);\n\t\t\t\t} else {\n\t\t\t\t\tthis.runHooksAfter(se.scope);\n\t\t\t\t\treturn stack.upNext(null);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tse.args.pop(); // pop statementList\n\t\t\t\tse.args.pop(); // pop expression\n\t\t\t\treturn this.stepNext(stack, se);\n\t\t}\n\t};\n\t\n\t/* statement1, expression, statement2, statementList */\n\tjsmm.nodes.ForBlock.prototype.stepNext = function(stack, se) {\n\t\tswitch (se.args.length) {\n\t\t\tcase 0:\n\t\t\t\tthis.runHooksBefore(se.scope);\n\t\t\t\treturn stack.pushNodeNext(this.statement1, se.scope);\n\t\t\tcase 1:\n\t\t\t\treturn stack.pushNodeNext(this.expression, se.scope);\n\t\t\tcase 2:\n\t\t\t\tif (jsmm.func.conditional(this, 'for', se.args[1])) {\n\t\t\t\t\treturn stack.pushNodeNext(this.statementList, se.scope);\n\t\t\t\t} else {\n\t\t\t\t\tthis.runHooksAfter(se.scope);\n\t\t\t\t\treturn stack.upNext(null);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\treturn stack.pushNodeNext(this.statement2, se.scope);\n\t\t\tcase 4:\n\t\t\t\tse.args.pop(); // pop statement2\n\t\t\t\tse.args.pop(); // pop statementList\n\t\t\t\tse.args.pop(); // pop expression\n\t\t\t\treturn this.stepNext(stack, se);\n\t\t}\n\t};\n\t\n\t/* name, nameArgs, statementList */\n\tjsmm.nodes.FunctionDeclaration.prototype.stepNext = function(stack, se) {\n\t\tvar that = this;\n\t\tswitch (se.args.length) {\n\t\t\tcase 0:\n\t\t\t\t// actual function declaration\n\t\t\t\tjsmm.func.funcDecl(this, se.scope, this.name, function() {\n\t\t\t\t\tvar vars = {};\n\t\t\t\t\tfor (var i=0; i<that.nameArgs.length; i++) {\n\t\t\t\t\t\tvars[that.nameArgs[i]] = arguments[i];\n\t\t\t\t\t}\n\t\t\t\t\tvar scope = new jsmm.func.Scope(vars, se.scope);\n\t\t\t\t\tstack.callStackDepth++;\n\t\t\t\t\tjsmm.func.funcEnter(that, scope, stack.callStackDepth);\n\t\t\t\t\tthat.runHooksBefore(that, se.scope);\n\n\t\t\t\t\t// get back to the original function declaration for runHooksAfter\n\t\t\t\t\tstack.pushNode(that, scope);\n\t\t\t\t\tstack.pushNode(that.statementList, scope);\n\t\t\t\t\t\n\t\t\t\t\tvar args = [];\n\t\t\t\t\tfor(var name in scope.vars) {\n\t\t\t\t\t\targs.push(jsmm.func.stringify(this, scope.vars[name].value));\n\t\t\t\t\t}\n\t\t\t\t\tvar message = that.name + '(' + args.join(', ') + ')';\n\t\t\t\t\treturn [new jsmm.msg.Inline(that, function(f) { return f(message); }),\n\t\t\t\t\t\tnew jsmm.msg.Line(that, message)];\n\t\t\t\t});\n\t\t\t\treturn stack.upNext(null);\n\t\t\tcase 1:\n\t\t\t\t// when reached the end of the function (i.e. there was no return statement)\n\t\t\t\tthis.runHooksAfter(se.scope);\n\t\t\t\treturn stack.upNext(null);\n\t\t}\n\n\t\t/*\n\t\toutput += 'function' + this.getArgList() + \"{\\n\";\n\t\toutput += 'var jsmmscopeInner = new jsmm.func.Scope({';\n\t\tif (this.nameArgs.length > 0) output += '\"' + this.nameArgs[0] + '\": ' + this.nameArgs[0];\n\t\tfor (var i=1; i<this.nameArgs.length; i++) {\n\t\t\toutput += ', \"' + this.nameArgs[i] + '\": ' + this.nameArgs[i];\n\t\t}\n\t\toutput += '}, jsmmscopeOuter);\\n';\n\t\toutput += 'jsmm.func.funcEnter(' + getEl(this) + ');\\n';\n\t\tif (jsmm.verbose) {\n\t\t\toutput += 'console.log(\"after entering ' + this.name + ':\");\\n';\n\t\t\toutput += 'console.log(jsmmscopeInner);\\n';\n\t\t\toutput += 'console.log(\" \");\\n';\n\t\t}\n\t\toutput += this.statementList.stepNext();\n\t\t//output += 'return jsmm.func.funcReturn(' + getEl(this) + ');\\n';\n\t\toutput += '});';\n\t\treturn output;\n\t\t*/\n\t};\n};\n\n//@ sourceURL=/jsmm/jsmm.step.js"
));

require.define("/jsmm/jsmm.dot.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/*jshint node:true*/\n\"use strict\";\n\nmodule.exports = function(jsmm) {\n\tvar makeEdge = function(from, to) {\n\t\treturn from + \"->\" + to + \";\";\n\t};\n\t\n\tvar makeNode = function(id, label, shape) {\n\t\tlabel = label.replace(/\\\"/g, '&quot;');\n\t\tlabel = label.replace(/\\\\/g, '\\\\\\\\');\n\t\tshape = shape || \"\";\n\t\treturn id + '[label=\"' + label + '\"shape=\"' + shape + '\"];';\n\t};\n\t\n\t/* statementList */\n\tjsmm.nodes.Program.prototype.getDot = function() {\n\t\treturn 'digraph{graph[ordering=\"in\"];' + makeNode(this.id, \"PROGRAM\") + this.statementList.getDot(this.id) + \"}\";\n\t};\n\t\n\t/* statements */\n\tjsmm.nodes.StatementList.prototype.getDot = function(fromId) {\n\t\tvar output = makeEdge(fromId, this.id);\n\t\toutput += \"subgraph cluster\" + this.id + \"{color=lightgrey;\";\n\t\toutput += makeNode(this.id, \"\", \"point\");\n\t\tfor (var i=0; i<this.statements.length; i++) {\n\t\t\toutput += this.statements[i].getDot(this.id);\n\t\t}\n\t\toutput += \"}\";\n\t\treturn output;\n\t};\n\t\n\t/* statement */\n\tjsmm.nodes.CommonSimpleStatement.prototype.getDot = function(fromId) {\n\t\treturn this.statement.getDot(fromId);\n\t};\n\t\n\t/* items */\n\tjsmm.nodes.VarStatement.prototype.getDot = function(fromId) {\n\t\tvar output = makeEdge(fromId, this.id);\n\t\toutput += \"subgraph cluster\" + this.id + \"{color=transparent;\";\n\t\toutput += makeNode(this.id, \"var\");\n\t\tfor (var i=0; i<this.items.length; i++) {\n\t\t\toutput += this.items[i].getDot(this.id);\n\t\t}\n\t\toutput += \"}\";\n\t\treturn output;\n\t};\n\t\n\t/* name, assignment */\n\tjsmm.nodes.VarItem.prototype.getDot = function(fromId) {\n\t\tvar output = \"\";\n\t\tif (this.assignment === null) {\n\t\t\toutput += makeEdge(fromId, this.id);\n\t\t\toutput += makeNode(this.id, this.name);\n\t\t}\n\t\telse {\n\t\t\toutput += this.assignment.getDot(fromId);\n\t\t}\n\t\treturn output;\n\t};\n\t\n\tjsmm.nodes.PostfixStatement.prototype.getDot =\n\tjsmm.nodes.AssignmentStatement.prototype.getDot =\n\tjsmm.nodes.ReturnStatement.prototype.getDot =\n\tjsmm.nodes.BinaryExpression.prototype.getDot =\n\tjsmm.nodes.UnaryExpression.prototype.getDot =\n\tjsmm.nodes.NumberLiteral.prototype.getDot =\n\tjsmm.nodes.StringLiteral.prototype.getDot =\n\tjsmm.nodes.BooleanLiteral.prototype.getDot =\n\tjsmm.nodes.NameIdentifier.prototype.getDot =\n\tjsmm.nodes.ObjectIdentifier.prototype.getDot =\n\tjsmm.nodes.ArrayIdentifier.prototype.getDot =\n\tjsmm.nodes.FunctionCall.prototype.getDot = function(fromId) {\n\t\treturn makeEdge(fromId, this.id) + makeNode(this.id, this.getCode());\n\t};\n\t\n\t/* functionCall */\n\tjsmm.nodes.CallStatement.prototype.getDot = function(fromId) {\n\t\treturn this.functionCall.getDot(fromId);\n\t};\n\t\n\t/* expression, statementList, elseBlock */\n\tjsmm.nodes.IfBlock.prototype.getDot = function(fromId) {\n\t\tvar output = makeEdge(fromId, this.id);\n\t\toutput += makeNode(this.id, \"if (\" + this.expression.getCode() + \")\", \"box\");\n\t\toutput += this.statementList.getDot(this.id);\n\t\tif (this.elseBlock !== null) {\n\t\t\toutput += this.elseBlock.getDot(this.id);\n\t\t}\n\t\treturn output;\n\t};\n\t\n\t/* ifBlock */\n\tjsmm.nodes.ElseIfBlock.prototype.getDot = function(fromId) {\n\t\tvar output = makeEdge(fromId, this.id);\n\t\toutput += makeNode(this.id, \"else\", \"box\");\n\t\toutput += this.ifBlock.getDot(this.id);\n\t\treturn output;\n\t};\n\t\n\t/* statementList */\n\tjsmm.nodes.ElseBlock.prototype.getDot = function(fromId) {\n\t\tvar output = makeEdge(fromId, this.id);\n\t\toutput += makeNode(this.id, \"else\", \"box\");\n\t\toutput += this.statementList.getDot(this.id);\n\t\treturn output;\n\t};\n\t\n\t/* expression, statementList */\n\tjsmm.nodes.WhileBlock.prototype.getDot = function(fromId) {\n\t\tvar output = makeEdge(fromId, this.id);\n\t\toutput += makeNode(this.id, \"while (\" + this.expression.getCode() + \")\", \"box\");\n\t\toutput += this.statementList.getDot(this.id);\n\t\treturn output;\n\t};\n\t\n\t/* statement1, expression, statement2, statementList */\n\tjsmm.nodes.ForBlock.prototype.getDot = function(fromId) {\n\t\tvar output = makeEdge(fromId, this.id);\n\t\toutput += makeNode(this.id, \"for ( ; \" + this.expression.getCode() + \" ; )\", \"box\");\n\t\toutput += this.statement1.getDot(this.id);\n\t\toutput += this.statementList.getDot(this.id);\n\t\toutput += this.statement2.getDot(this.id);\n\t\treturn output;\n\t};\n\t\n\t/* name, nameArgs, statementList */\n\tjsmm.nodes.FunctionDeclaration.prototype.getDot = function(fromId) {\n\t\tvar output = makeEdge(fromId, this.id);\n\t\toutput += makeNode(this.id, \"function \" + this.name + this.getArgList(), \"octagon\");\n\t\toutput += this.statementList.getDot(this.id);\n\t\treturn output;\n\t};\n};\n\n//@ sourceURL=/jsmm/jsmm.dot.js"
));

require.define("/jsmm/jsmm.simple.runner.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/*jshint node:true*/\n\"use strict\";\n\nmodule.exports = function(jsmm) {\n\trequire('./jsmm.msg')(jsmm);\n\t\n\tjsmm.SimpleRunner = function() { return this.init.apply(this, arguments); };\n\t\t\n\tjsmm.SimpleRunner.prototype = {\n\t\tinit: function(text, scope) {\n\t\t\tthis.code = text || '';\n\t\t\tthis.scope = scope || {};\n\t\t\tthis.reset();\n\t\t},\n\t\t\n\t\treset: function() {\n\t\t\tthis.tree = null;\n\t\t\tthis.rawFunc = null;\n\t\t\tthis.safeFunc = null;\n\t\t\tthis.stack = null;\n\t\t\tthis.stepPos = null;\n\t\t\tthis.resetError();\n\t\t},\n\t\t\n\t\tresetError: function() {\n\t\t\tthis.error = null;\n\t\t},\n\t\t\n\t\tsetText: function(text) {\n\t\t\tthis.reset();\n\t\t\tthis.code = text;\n\t\t},\n\t\t\n\t\tsetScope: function(scope) {\n\t\t\tthis.reset();\n\t\t\tthis.scope = scope;\n\t\t},\n\t\t\n\t\tgetCode: function() {\n\t\t\treturn this.code;\n\t\t},\n\t\t\n\t\thandleError: function(error) {\n\t\t\t//console.log(error);\n\t\t\tif (error instanceof jsmm.msg.Error) {\n\t\t\t\tthis.error = error;\n\t\t\t} else {\n\t\t\t\tthrow error;\n\t\t\t\tthis.error = new jsmm.msg.Error({}, 'An unknown error has occurred', '', error);\n\t\t\t}\n\t\t\t//console.log(this.error);\n\t\t},\n\t\t\n\t\tparse: function() {\n\t\t\tthis.resetError();\n\t\t\tif (this.tree !== null) return true;\n\t\t\t\n\t\t\ttry {\n\t\t\t\tthis.tree = new jsmm.Tree(this.code);\n\t\t\t\tif (this.tree.hasError()) {\n\t\t\t\t\tthis.handleError(this.tree.getError());\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} catch (error) {\n\t\t\t\tthis.handleError(error);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\t\tgetElementsByType: function(type) {\n\t\t\tthis.resetError();\n\t\t\tif (!this.parse()) return undefined;\n\n\t\t\treturn this.tree.nodesByType[type];\n\t\t},\n\n\t\tgetElementByLine: function(line) {\n\t\t\tthis.resetError();\n\t\t\tif (!this.parse()) return undefined;\n\n\t\t\treturn this.tree.nodesByLine[line];\n\t\t},\n\n\t\taddHookBeforeNode: function(node, func) {\n\t\t\tthis.safeFunc = null;\n\t\t\tthis.tree.addHookBeforeNode(node, func);\n\t\t},\n\n\t\taddHookAfterNode: function(node, func) {\n\t\t\tthis.safeFunc = null;\n\t\t\tthis.tree.addHookAfterNode(node, func);\n\t\t},\n\t\t\n\t\tgetDot: function() {\n\t\t\tthis.resetError();\n\t\t\tif (!this.parse()) return undefined;\n\t\t\t\n\t\t\ttry {\n\t\t\t\treturn this.tree.programNode.getDot();\n\t\t\t} catch (error) {\n\t\t\t\tthis.handleError(error);\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t},\n\t\t\n\t\tgetRawCode: function() {\n\t\t\tthis.resetError();\n\t\t\tif (!this.parse()) return undefined;\n\t\t\t\n\t\t\ttry {\n\t\t\t\treturn this.tree.programNode.getCode();\n\t\t\t} catch (error) {\n\t\t\t\tthis.handleError(error);\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t},\n\t\t\n\t\tmakeRawFunc: function() {\n\t\t\tthis.resetError();\n\t\t\tif (this.rawFunc !== null) return true;\n\t\t\tif (!this.parse()) return false;\n\t\t\t\n\t\t\ttry {\n\t\t\t\tthis.rawFunc = this.tree.programNode.getFunction(this.scope);\n\t\t\t\treturn true;\n\t\t\t} catch (error) {\n\t\t\t\tthis.handleError(error);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\t\n\t\trunRaw: function() {\n\t\t\tthis.resetError();\n\t\t\tif (!this.makeRawFunc()) return false;\n\t\t\t\n\t\t\ttry {\n\t\t\t\tthis.rawFunc();\n\t\t\t\treturn true;\n\t\t\t} catch (error) {\n\t\t\t\tthis.handleError(error);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\t\n\t\tgetSafeCode: function() {\n\t\t\tthis.resetError();\n\t\t\tif (!this.parse()) return undefined;\n\t\t\t\n\t\t\ttry {\n\t\t\t\treturn this.tree.programNode.getSafeCode();\n\t\t\t} catch (error) {\n\t\t\t\tthis.handleError(error);\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t},\n\t\t\n\t\tmakeSafeFunc: function() {\n\t\t\tthis.resetError();\n\t\t\tif (this.safeFunc !== null) return true;\n\t\t\tif (!this.parse()) return false;\n\t\t\t\n\t\t\ttry {\n\t\t\t\tthis.safeFunc = this.tree.programNode.getSafeFunction(this.scope);\n\t\t\t\treturn true;\n\t\t\t} catch (error) {\n\t\t\t\tthis.handleError(error);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\t\n\t\trunSafe: function() {\n\t\t\tthis.resetError();\n\t\t\tif (!this.makeSafeFunc()) return false;\n\t\t\t\n\t\t\ttry {\n\t\t\t\tthis.safeFunc();\n\t\t\t\treturn true;\n\t\t\t} catch (error) {\n\t\t\t\tthis.handleError(error);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\t\n\t\tstepInit: function() {\n\t\t\tthis.resetError();\n\t\t\tif (!this.parse()) return false;\n\t\t\ttry {\n\t\t\t\tthis.stack = new jsmm.step.Stack(this.tree, this.scope);\n\t\t\t\tthis.stepPos = 0;\n\t\t\t\treturn true;\n\t\t\t} catch (error) {\n\t\t\t\tthis.handleError(error);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\t\n\t\tstepNext: function() {\n\t\t\tthis.resetError();\n\t\t\t\n\t\t\tvar ret = [];\n\t\t\ttry {\n\t\t\t\tvar cont;\n\t\t\t\tdo {\n\t\t\t\t\tif (this.stack === null || !this.stack.hasNext()) return undefined;\n\t\t\t\t\t\n\t\t\t\t\tcont = false;\n\t\t\t\t\tvar msgs = this.stack.stepNext();\n\t\t\t\t\tif (msgs.length <= 0) return undefined;\n\t\t\t\t\t\n\t\t\t\t\tfor (var i=0; i<msgs.length; i++) {\n\t\t\t\t\t\tif (msgs[i] instanceof jsmm.msg.Error) {\n\t\t\t\t\t\t\tthis.error = msgs[i];\n\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t} else if (msgs[i] instanceof jsmm.msg.Continue) {\n\t\t\t\t\t\t\tcont = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// don't push jsmm.msg.Continue\n\t\t\t\t\t\t\tret.push(msgs[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} while (cont === true);\n\t\t\t\tthis.stepPos++;\n\t\t\t\treturn ret;\n\t\t\t} catch (error) {\n\t\t\t\tthis.handleError(error);\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t},\n\n\t\tstepBack: function() {\n\t\t\tthis.resetError();\n\t\t\tvar stepPos = this.stepPos-1;\n\n\t\t\tvar result;\n\t\t\tif (stepPos >= 0) {\n\t\t\t\tthis.stepInit();\n\t\t\t\twhile (this.stepPos < stepPos) {\n\t\t\t\t\tresult = this.stepNext();\n\t\t\t\t\tif (result === undefined) return undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\t\n\t\tisStepping: function() {\n\t\t\treturn (this.stack !== null && this.stack.hasNext());\n\t\t},\n\t\t\n\t\trunStep: function() {\n\t\t\tthis.resetError();\n\t\t\t\n\t\t\tif (this.stepInit()) {\n\t\t\t\tvar step;\n\t\t\t\tdo {\n\t\t\t\t\tstep = this.stepNext();\n\t\t\t\t} while(step !== undefined);\n\t\t\t}\n\t\t\t\n\t\t\treturn !this.hasError();\n\t\t},\n\t\t\n\t\thasError: function() {\n\t\t\treturn this.error !== null;\n\t\t},\n\t\t\n\t\tgetError: function() {\n\t\t\treturn this.error;\n\t\t},\n\t};\n};\n\n//@ sourceURL=/jsmm/jsmm.simple.runner.js"
));

require.define("/jsmm/jsmm.static.runner.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/*jshint node:true*/\n\"use strict\";\n\nmodule.exports = function(jsmm) {\n\trequire('./jsmm.msg')(jsmm);\n\t\n\tjsmm.StaticRunner = function() { return this.init.apply(this, arguments); };\n\t\t\n\tjsmm.StaticRunner.prototype = {\n\t\tinit: function() {\n\t\t\tthis.tree = null;\n\t\t\tthis.scope = null;\n\t\t\tthis.error = null;\n\t\t\tthis.lastScope = null;\n\t\t\tthis.stepCount = 0;\n\t\t\tthis.messages = [];\n\t\t},\n\n\t\trestart: function() {\n\t\t\t// set a running state\n\t\t\tthis.stepCount = 0;\n\t\t},\n\n\t\thasError: function() {\n\t\t\treturn this.error !== null;\n\t\t},\n\n\t\trun: function() {\n\t\t\tif (this.tree === null || this.scope === null) return false;\n\n\t\t\tif (this.stepCount <= 0) {\n\t\t\t\tif (!this.runSafe()) return false;\n\t\t\t} else {\n\t\t\t\tif (!this.stepInit()) return false;\n\t\t\t\twhile(this.stepPos < this.stepCount) {\n\t\t\t\t\tif (!this.stepNext()) return false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\tstepForward: function() {\n\t\t\tthis.stepCount++;\n\t\t\tif (!this.run()) {\n\t\t\t\tif (this.error !== null) return false;\n\t\t\t\telse {\n\t\t\t\t\tthis.stepCount = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\tstepBackward: function() {\n\t\t\tthis.stepCount--;\n\t\t\tif (this.stepCount < 0) this.stepCount = 0;\n\t\t\treturn this.run();\n\t\t},\n\n\t\tisStepping: function() {\n\t\t\treturn this.stepCount > 0;\n\t\t},\n\n\t\tgetError: function() {\n\t\t\treturn this.error;\n\t\t},\n\n\t\tgetMessages: function() {\n\t\t\treturn this.messages;\n\t\t},\n\n\t\tnewTree: function(tree) {\n\t\t\tthis.tree = tree;\n\t\t},\n\n\t\tnewScope: function(scope) {\n\t\t\tthis.scope = scope;\n\t\t},\n\n\t\tgetExamples: function(text) {\n\t\t\tvar scope = this.lastScope === null ? new jsmm.func.Scope(this.scope) : this.lastScope;\n\t\t\tif (scope === null) return null;\n\t\t\telse {\n\t\t\t\treturn jsmm.editor.autocompletion.getExamples(scope, text);\n\t\t\t}\n\t\t},\n\n\t\t/// INTERNAL FUNCTIONS ///\n\t\thandleError: function(error) {\n\t\t\tif (error instanceof jsmm.msg.Error) {\n\t\t\t\tthis.error = error;\n\t\t\t} else {\n\t\t\t\tthrow error;\n\t\t\t\tthis.error = new jsmm.msg.Error({}, 'An unknown error has occurred', '', error);\n\t\t\t}\n\t\t},\n\n\t\trunSafe: function() {\n\t\t\tthis.error = null;\n\t\t\tthis.messages = [];\n\n\t\t\ttry {\n\t\t\t\tthis.lastScope = this.tree.programNode.getSafeFunction(this.scope)();\n\t\t\t\treturn true;\n\t\t\t} catch (error) {\n\t\t\t\tthis.handleError(error);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\t\tstepInit: function() {\n\t\t\tthis.error = null;\n\t\t\ttry {\n\t\t\t\tthis.stack = new jsmm.step.Stack(this.tree, this.scope);\n\t\t\t\tthis.stepPos = 0;\n\t\t\t\tthis.messages = [];\n\t\t\t\treturn true;\n\t\t\t} catch (error) {\n\t\t\t\tthis.handleError(error);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\t\tstepNext: function() {\n\t\t\tthis.error = null;\n\n\t\t\tvar ret = [];\n\t\t\ttry {\n\t\t\t\tvar cont;\n\t\t\t\tdo {\n\t\t\t\t\tif (this.stack === null || !this.stack.hasNext()) return false;\n\t\t\t\t\t\n\t\t\t\t\tcont = false;\n\t\t\t\t\tvar msgs = this.stack.stepNext();\n\t\t\t\t\tif (msgs.length <= 0) return undefined;\n\t\t\t\t\t\n\t\t\t\t\tfor (var i=0; i<msgs.length; i++) {\n\t\t\t\t\t\tif (msgs[i] instanceof jsmm.msg.Error) {\n\t\t\t\t\t\t\tthis.error = msgs[i];\n\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t} else if (msgs[i] instanceof jsmm.msg.Continue) {\n\t\t\t\t\t\t\tcont = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// don't push jsmm.msg.Continue\n\t\t\t\t\t\t\tret.push(msgs[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// TODO: store all messages instead of the last ones\n\t\t\t\t\tthis.messages = msgs;\n\t\t\t\t} while (cont === true);\n\t\t\t\tthis.stepPos++;\n\t\t\t\treturn ret;\n\t\t\t} catch (error) {\n\t\t\t\tthis.handleError(error);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t};\n};\n\n//@ sourceURL=/jsmm/jsmm.static.runner.js"
));

require.define("/jsmm/jsmm.test.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/*jshint node:true*/\n\"use strict\";\n\nmodule.exports = function(jsmm) {\n\tjsmm.test = {};\n\t\n\tjsmm.test.Console = function() {\n\t\tthis.result = '';\n\t};\n\t\n\tjsmm.test.Console.prototype.log = function(str) {\n\t\tthis.result += str + '\\n';\n\t};\n\t\n\tjsmm.test.runAll = function() {\n\t\tjsmm.test.output = '';\n\t\tvar failed = 0;\n\t\tvar name;\n\n\t\tfor (name in jsmm.test.tests.succeed) {\n\t\t\tif (!jsmm.test.runTest(name.replace(/_/g, ' '), jsmm.test.tests.succeed[name], true, true)) failed++;\n\t\t}\n\t\tfor (name in jsmm.test.tests.fail_threeway) {\n\t\t\tif (!jsmm.test.runTest(name.replace(/_/g, ' '), jsmm.test.tests.fail_threeway[name], true, false)) failed++;\n\t\t}\n\t\tfor (name in jsmm.test.tests.fail_twoway) {\n\t\t\tif (!jsmm.test.runTest(name.replace(/_/g, ' '), jsmm.test.tests.fail_twoway[name], false, false)) failed++;\n\t\t}\n\t\tif (failed <= 0) {\n\t\t\tjsmm.test.output += 'All tests completed successfully!';\n\t\t} else if (failed === 1) {\n\t\t\tjsmm.test.output += 'Unfortunately 1 test failed...';\n\t\t} else {\n\t\t\tjsmm.test.output += 'Unfortunately ' + failed + ' tests failed...';\n\t\t}\n\t\treturn failed <= 0;\n\t};\n\n\tjsmm.test.printError1 = function(name, name1, error1, code) {\n\t\tjsmm.test.output += 'In test \"' + name + '\" ' + name1 + ' was incorrect.\\n';\n\t\tjsmm.test.output += name1 + ':\\n' + JSON.stringify(error1) + '\\n';\n\t\tjsmm.test.output += 'code:\\n' + code + '\\n';\n\t};\n\t\n\tjsmm.test.printError2 = function(name, name1, name2, error1, error2, code) {\n\t\tjsmm.test.output += 'In test \"' + name + '\" ' + name1 + ' and ' + name2 + ' were incorrect.\\n';\n\t\tjsmm.test.output += name1 + ':\\n' + JSON.stringify(error1) + '\\n';\n\t\tjsmm.test.output += name2 + ':\\n' + JSON.stringify(error2) + '\\n';\n\t\tjsmm.test.output += 'code:\\n' + code + '\\n';\n\t};\n\t\n\tjsmm.test.runTest = function(name, code, threeway, succeed) {\n\t\tvar consoleRaw = new jsmm.test.Console();\n\t\tvar consoleSafe = new jsmm.test.Console();\n\t\tvar consoleStep = new jsmm.test.Console();\n\t\tvar errorRaw = null;\n\t\tvar errorSafe = null;\n\t\tvar errorStep = null;\n\t\tvar runner = new jsmm.SimpleRunner(code);\n\t\t\n\t\tif (threeway) {\n\t\t\trunner.setScope({console: consoleRaw});\n\t\t\tif (!runner.runRaw()) {\n\t\t\t\terrorRaw = runner.getError();\n\t\t\t}\n\t\t}\n\t\t\n\t\trunner.setScope({console: consoleSafe});\n\t\tif (!runner.runSafe()) {\n\t\t\terrorSafe = runner.getError();\n\t\t}\n\t\t\n\t\trunner.setScope({console: consoleStep});\n\t\tif (!runner.runStep()) {\n\t\t\terrorStep = runner.getError();\n\t\t}\n\t\t\n\t\t// when it should threeway we can compare against the raw result\n\t\tif (threeway && !jsmm.test.compareErrors(errorRaw, errorSafe, succeed)) {\n\t\t\tjsmm.test.printError2(name, 'errorRaw', 'errorSafe', errorRaw, errorSafe, code);\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!jsmm.test.compareErrors(errorSafe, errorStep, succeed)) {\n\t\t\tjsmm.test.printError2(name, 'errorSafe', 'errorStep', errorSafe, errorStep, code);\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (threeway && consoleRaw.result !== consoleSafe.result) {\n\t\t\tjsmm.test.printError2(name, 'consoleRaw', 'consoleSafe', consoleRaw.result, consoleSafe.result, code);\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (consoleSafe.result !== consoleStep.result) {\n\t\t\tjsmm.test.printError2(name, 'consoleSafe', 'consoleStep', consoleSafe.result, consoleStep.result, code);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (threeway && succeed !== (errorRaw === null)) {\n\t\t\tjsmm.test.printError1(name, 'errorRaw', errorRaw, code);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (succeed !== (errorSafe === null)) {\n\t\t\tjsmm.test.printError1(name, 'errorSafe', errorSafe, code);\n\t\t\treturn false;\n\t\t}\n\n\t\t// no need to check errorStep for null, since otherwise it would have been caught when comparing errors\n\t\t\n\t\tjsmm.test.output += 'Test \"' + name + '\" completed successfully!\\n';\n\t\treturn true;\n\t};\n\t\n\tjsmm.test.compareErrors = function(error1, error2) {\n\t\tif (error1 === null && error2 === null) {\n\t\t\treturn true;\n\t\t} else if (error1 === null || error2 === null) {\n\t\t\treturn false;\n\t\t} else if (error1.orig !== null || error2.orig !== null) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn error1.html === error2.html;\n\t\t}\n\t};\n\t\n\tjsmm.test.tests = { succeed: {}, fail_threeway: {}, fail_twoway: {}};\n\t\n\tjsmm.test.tests.succeed.comments =\n\t'// one line comment' + '\\n' +\n\t'var a;' + '\\n' +\n\t'/*start of line comment*/var a; // end of line comment... with some crazy stuff here *// ***//// / * */' + '\\n' +\n\t'/*start of line comment*/var a; /* end of line comment... with some crazy stuff here * // ***//// / *' + '\\n' +\n\t'/*start of line comment*/var a;/* multiline' + '\\n' +\n\t'comment with * and / and /* and /***...' + '\\n' +\n\t'var a;' + '\\n' +\n\t'and also // and ///*** and more! */' + '\\n' +\n\t'var a;' + '\\n' +\n\t'console.log(\"Hello world!\");';\n\t\n\tjsmm.test.tests.succeed.assignments =\n\t'// variable assignments' + '\\n' +\n\t'var a;' + '\\n' +\n\t'a = 0;' + '\\n' +\n\t'console.log(a);' + '\\n' +\n\t'var a = 5;' + '\\n' +\n\t'console.log(a);' + '\\n' +\n\t'var b = a*a+a/a-a%a+(a*a*a-a);' + '\\n' +\n\t'console.log(b);' + '\\n' +\n\t'var c=b, d=c, e=d;' + '\\n' +\n\t'console.log(e);' + '\\n' +\n\t'c = b==c && c==d && d==b;' + '\\n' +\n\t'console.log(c);' + '\\n' +\n\t'd = c || b > d;' + '\\n' +\n\t'console.log(d);' + '\\n' +\n\t'e = (1>2 && 1>=2 && 2<1 && 2<=1) || 2 != 1;' + '\\n' +\n\t'console.log(e);' + '\\n' +\n\t'var f = -5 > +3 || !false;' + '\\n' +\n\t'console.log(f);' + '\\n' +\n\t'f = !(f || false) || false;' + '\\n' +\n\t'console.log(f);' + '\\n' +\n\t'a = 1.4E-02;' + '\\n' +\n\t'console.log(a);' + '\\n' +\n\t'a += a;' + '\\n' +\n\t'console.log(a);' + '\\n' +\n\t'a *= a;' + '\\n' +\n\t'console.log(a);' + '\\n' +\n\t'a -= a/10;' + '\\n' +\n\t'console.log(a);' + '\\n' +\n\t'a /= 0.003;' + '\\n' +\n\t'console.log(a);' + '\\n' +\n\t'a %= 10;' + '\\n' +\n\t'console.log(a);' + '\\n' +\n\t'a++;' + '\\n' +\n\t'console.log(a);' + '\\n' +\n\t'a--;' + '\\n' +\n\t'console.log(a);' + '\\n' +\n\t'a = 5+3*5+1+9*10/5%2+18/23-52/16%82-53*32;' + '\\n' +\n\t'console.log(a);' + '\\n' +\n\t'var str=\"\";' + '\\n' +\n\t'console.log(str);' + '\\n' +\n\t'str += \"hi\";' + '\\n' +\n\t'console.log(str);' + '\\n' +\n\t'str += 10;' + '\\n' +\n\t'console.log(str);' + '\\n' +\n\t'str = 5+5+str;' + '\\n' +\n\t'console.log(str);' + '\\n' +\n\t'var len = str.length;' + '\\n' +\n\t'console.log(len);';\n\t\n\tjsmm.test.tests.succeed.control =\n\t'// control structures' + '\\n' +\n\t'var f=true, e=!f;' + '\\n' +\n\t'if (true) {' + '\\n' +\n\t'  console.log(true);' + '\\n' +\n\t'  if (f && e && false) {' + '\\n' +\n\t'    console.log(false);' + '\\n' +\n\t'  } else {' + '\\n' +\n\t'    if (false) {' + '\\n' +\n\t'      console.log(false);' + '\\n' +\n\t'    } else if (true) {' + '\\n' +\n\t'      if(true) {' + '\\n' +\n\t'        console.log(\"a\");' + '\\n' +\n\t'      }' + '\\n' +\n\t'      if(false) {' + '\\n' +\n\t'        console.log(\"b\");' + '\\n' +\n\t'      }' + '\\n' +\n\t'      console.log(true);' + '\\n' +\n\t'    }' + '\\n' +\n\t'  }' + '\\n' +\n\t'}' + '\\n' +\n\t'' + '\\n' +\n\t'var i=0;' + '\\n' +\n\t'while (i<10) {' + '\\n' +\n\t'  console.log(i*i-i);' + '\\n' +\n\t'  i++;' + '\\n' +\n\t'}' + '\\n' +\n\t'' + '\\n' +\n\t'for (var j=0; j<10; j++) {' + '\\n' +\n\t'  console.log(j);' + '\\n' +\n\t'}';\n\t\n\tjsmm.test.tests.succeed.functions_simple =\n\t'// functions simple' + '\\n' +\n\t'function f1(n) {' + '\\n' +\n\t'  console.log(n*100);' + '\\n' +\n\t'}' + '\\n' +\n\t'function f2(n) {' + '\\n' +\n\t'  return n*100;' + '\\n' +\n\t'}' + '\\n' +\n\t'f1(10);' + '\\n' +\n\t'console.log(f2(20));';\n\t\n\tjsmm.test.tests.succeed.functions_complex =\n\t'// functions complex' + '\\n' +\n\t'var a, b=100, c=\"test\", d=1000;' + '\\n' +\n\t'function f1(a, b, c, q1, q2, q3) {' + '\\n' +\n\t'  console.log(a+d);' + '\\n' +\n\t'  console.log(f2(b*3)/3);' + '\\n' +\n\t'  console.log(f3(b, c));' + '\\n' +\n\t'  console.log((q1+q2)%q3);' + '\\n' +\n\t'}' + '\\n' +\n\t'function f2(n) {' + '\\n' +\n\t'  var c = n;' + '\\n' +\n\t'  return n+(3/c);' + '\\n' +\n\t'}' + '\\n' +\n\t'function f3(a,b) {' + '\\n' +\n\t'  console.log(a);' + '\\n' +\n\t'  console.log(b);' + '\\n' +\n\t'  for (var c=0; c>-100; c--) {' + '\\n' +\n\t'    a *= b;' + '\\n' +\n\t'  }' + '\\n' +\n\t'  return a+b;' + '\\n' +\n\t'}' + '\\n' +\n\t'var x=5, y=10, z=15;' + '\\n' +\n\t'f1(x,y,z, 8, 9, 10, \"test\", \"blah\", \"more blah\");';\n\t\n\tjsmm.test.tests.fail_threeway.missing_semicolon_1 = 'var a';\n\tjsmm.test.tests.fail_threeway.missing_semicolon_2 = 'var a=5*5';\n\tjsmm.test.tests.fail_threeway.missing_semicolon_3 = 'var a;\\n a=5*5';\n\tjsmm.test.tests.fail_threeway.missing_semicolon_4 = 'var a;\\n if (a) {\\n a=5*5 \\n}';\n\tjsmm.test.tests.fail_threeway.missing_semicolon_5 = 'console.log(5)';\n\tjsmm.test.tests.fail_threeway.missing_semicolon_6 = 'var a;\\n a+=a';\n\tjsmm.test.tests.fail_threeway.missing_semicolon_7 = 'for(var a=0 a<5; a++) {\\n }';\n\tjsmm.test.tests.fail_threeway.missing_bracket_1 = 'if (true) \\n }';\n\tjsmm.test.tests.fail_threeway.missing_bracket_2 = 'if (true) {';\n\tjsmm.test.tests.fail_threeway.missing_bracket_3 = 'while (true) \\n }';\n\tjsmm.test.tests.fail_threeway.missing_bracket_4 = 'while (true) {';\n\tjsmm.test.tests.fail_threeway.missing_bracket_5 = 'for (var i=0; i<10; i++) \\n }';\n\tjsmm.test.tests.fail_threeway.missing_bracket_6 = 'for (var i=0; i<10; i++) {\\n';\n\tjsmm.test.tests.fail_threeway.missing_bracket_7 = 'if (true) {\\n } else \\n }';\n\tjsmm.test.tests.fail_threeway.missing_bracket_8 = 'if (true) {\\n } else { \\n';\n\tjsmm.test.tests.fail_threeway.missing_bracket_9 = 'if (true) {\\n  else { \\n }';\n\tjsmm.test.tests.fail_threeway.missing_bracket_10 = 'if (true) \\n } else { \\n }';\n\tjsmm.test.tests.fail_threeway.missing_bracket_11 = 'if (5>(5+5) {\\n }';\n\tjsmm.test.tests.fail_threeway.missing_bracket_12 = 'if 5>5) {\\n }';\n\tjsmm.test.tests.fail_threeway.incorrect_string_1 = 'var str = \"Hello World!;';\n\tjsmm.test.tests.fail_threeway.incorrect_string_2 = 'var str = \"Hello World!';\n\tjsmm.test.tests.fail_threeway.incorrect_string_3 = 'var str = Hello World!\";';\n\tjsmm.test.tests.fail_threeway.incorrect_string_4 = 'var str = \"Hello World!\\n\";';\n\tjsmm.test.tests.fail_threeway.incorrect_string_5 = 'var str = \"Hello \\\\World!\\n\";';\n\tjsmm.test.tests.fail_threeway.reserved_word_1 = 'var jsmmscope;';\n\tjsmm.test.tests.fail_threeway.reserved_word_2 = 'var jsmmscopeInner;';\n\tjsmm.test.tests.fail_threeway.reserved_word_3 = 'var jsmmscopeOuter;';\n\tjsmm.test.tests.fail_threeway.reserved_word_4 = 'var jsmm;';\n\tjsmm.test.tests.fail_threeway.reserved_word_5 = 'var jsmmparser;';\n\tjsmm.test.tests.fail_threeway.reserved_word_6 = 'var jsmmExecutionCounter;';\n\tjsmm.test.tests.fail_threeway.reserved_word_6 = 'var jsmmtemp;';\n\tjsmm.test.tests.fail_threeway.reserved_word_6 = 'var jsmmtree;';\n\tjsmm.test.tests.fail_threeway.reserved_word_7 = 'var NaN;';\n\tjsmm.test.tests.fail_threeway.reserved_word_8 = 'var this;';\n\tjsmm.test.tests.fail_threeway.reserved_word_9 = 'var arguments;';\n\t\n\tjsmm.test.tests.fail_twoway.unary_1 = 'console.log(+true);';\n\tjsmm.test.tests.fail_twoway.unary_2 = 'console.log(-false);';\n\tjsmm.test.tests.fail_twoway.unary_3 = 'console.log(+\"string\");';\n\tjsmm.test.tests.fail_twoway.unary_4 = 'console.log(-\"string\");';\n\tjsmm.test.tests.fail_twoway.unary_5 = 'console.log(!\"string\");';\n\tjsmm.test.tests.fail_twoway.unary_6 = 'console.log(!5);';\n\tjsmm.test.tests.fail_twoway.invalid_funcion_call_1 = 'function f(a, b) {\\n return a;\\n }\\n f(1);';\n\tjsmm.test.tests.fail_twoway.invalid_funcion_call_2 = 'function f(a, b) {\\n return a+b;\\n }\\n f(1);';\n\t//jsmm.test.tests.fail_twoway.repeated_declaration_1 = 'var a;\\n var a;';\n\t//jsmm.test.tests.fail_twoway.repeated_declaration_2 = 'var a = 1;\\n var a;';\n};\n\n//@ sourceURL=/jsmm/jsmm.test.js"
));

require.define("/jsmm/jsmm.editor.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/*jshint node:true*/\n\"use strict\";\n\nmodule.exports = function(jsmm) {\n\tjsmm.editor = {};\n\n\tjsmm.editor.autocompletion = {\n\t\t// expected text format: someObject.someProperty.startOfAFunction\n\t\tgetExamples: function(scope, text) {\n\t\t\tvar split = text.split('.');\n\n\t\t\tvar obj;\n\t\t\ttry {\n\t\t\t\tobj = jsmm.func.name(null, scope, split[0]);\n\t\t\t\tfor (var i=1; i<split.length-1; i++) {\n\t\t\t\t\tobj = jsmm.func.object(null, obj, split[i]);\n\t\t\t\t}\n\t\t\t\tobj = obj.value;\n\t\t\t} catch (error) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar examples = [];\n\t\t\tvar start = split[split.length-1].toLowerCase();\n\t\t\tfor (var name in obj) {\n\t\t\t\tvar example;\n\t\t\t\tif (typeof obj[name] === 'object' && obj[name].example !== undefined) {\n\t\t\t\t\texample = obj[name].example;\n\t\t\t\t} else {\n\t\t\t\t\texample = name;\n\t\t\t\t}\n\t\t\t\tif (start.length === 0 || example.substring(0, start.length).toLowerCase() === start) {\n\t\t\t\t\texamples.push(example);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\texamples: examples,\n\t\t\t\twidth: start.length,\n\t\t\t\tprefix: text.substring(0, text.length - start.length)\n\t\t\t};\n\t\t}\n\t};\n\n\tjsmm.editor.editables = {\n\t\tgenerate: function(tree, editorEditables, surface, editor) {\n\t\t\tvar editables = [];\n\t\t\tvar i;\n\t\t\tvar booleanNodes = tree.getNodesByType('BooleanLiteral');\n\t\t\tif (booleanNodes !== undefined) {\n\t\t\t\tfor (i=0; i<booleanNodes.length; i++) {\n\t\t\t\t\teditables.push(new editorEditables.CycleEditable(booleanNodes[i], surface, editor, this.parseBoolean, this.makeBoolean));\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar numberNodes = tree.getNodesByType('NumberLiteral');\n\t\t\tif (numberNodes !== undefined) {\n\t\t\t\tfor (i=0; i<numberNodes.length; i++) {\n\t\t\t\t\tvar node = numberNodes[i];\n\t\t\t\t\tif (node.parent.type === 'UnaryExpression') {\n\t\t\t\t\t\tnode = node.parent;\n\t\t\t\t\t}\n\t\t\t\t\teditables.push(new editorEditables.NumberEditable(node, surface, editor, this.parseNumber, this.makeNumber));\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar stringNodes = tree.getNodesByType('StringLiteral');\n\t\t\tif (stringNodes !== undefined) {\n\t\t\t\tfor (i=0; i<stringNodes.length; i++) {\n\t\t\t\t\tvar str = stringNodes[i].str;\n\t\t\t\t\tif (jsmm.editor.editables.splitColor('\"' + str + '\"') !== null) {\n\t\t\t\t\t\teditables.push(new editorEditables.ColorEditable(stringNodes[i], surface, editor, this.parseColor, this.makeColor));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn editables;\n\t\t},\n\n\t\tparseBoolean: function(text) {\n\t\t\tthis.value = text === 'true';\n\t\t\treturn (text === 'true' || text === 'false');\n\t\t},\n\n\t\tmakeBoolean: function() {\n\t\t\treturn this.value ? 'false' : 'true';\n\t\t},\n\n\t\tsplitNumber: function(text) {\n\t\t\tvar match = /^[+]?([\\-]?)[ ]*([0-9]+)(?:[.]([0-9]+))?(?:([eE])[+]?([\\-]?[0-9]+))?$/g.exec(text);\n\t\t\tif (match === null) {\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\tsign: match[1], // either \"-\" or undefined (\"+\" is dropped)\n\t\t\t\t\tinteger: match[2], // integer part, cannot be undefined (if the number is valid)\n\t\t\t\t\tdecimals: match[3], // decimal part without \".\", or undefined\n\t\t\t\t\texponentLetter: match[4], // either \"e\", \"E\", or undefined\n\t\t\t\t\texponent: match[5] // the exponent part without the letter, but with an optional \"-\" (again not \"+\"), or undefined\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\n\t\tparseNumber: function(text) {\n\t\t\tthis.numberData = {};\n\t\t\t// remove spaces since it is possible to have e.g. \"-  5\"\n\t\t\tthis.numberData.value = parseFloat(text.replace(/[ ]+/g, ''));\n\t\t\tvar split = jsmm.editor.editables.splitNumber(text);\n\n\t\t\tif (split === null || !isFinite(this.numberData.value)) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\t// if an exponent is defined, use the capitalisation already used in the value\n\t\t\t\tthis.numberData.exponentLetter = split.exponentLetter || 'e';\n\n\t\t\t\t// calculate the delta for each offset pixel based on the number of decimals in the original number (and of course exponent)\n\t\t\t\t// the delta is inverted as this seems to reduce the number of rounding errors (e.g. 0.57 !== 57*0.01, but 0.57 === 57/100)\n\t\t\t\tthis.numberData.invDelta = Math.pow(10, -(parseInt(split.exponent || '0', 10) - (split.decimals || '').length));\n\n\t\t\t\t// determine the number of significant digits by trimming leading zeros\n\t\t\t\tvar significant = (split.integer + (split.decimals || '')).replace(/^0*/, '').length;\n\t\t\t\tif (significant > 8) significant = 8;\n\t\t\t\telse if (significant < 1) significant = 1;\n\n\t\t\t\tif (significant > 0) {\n\t\t\t\t\t// the final number of decimals has to be based on the .toPrecision value with the calculated number of significant digits,\n\t\t\t\t\t// as this will be used when generating the number, and this function may alter the format of the number (e.g. different\n\t\t\t\t\t// number of digits and exponent, etc.)\n\t\t\t\t\tthis.numberData.decimals = (jsmm.editor.editables.splitNumber(this.numberData.value.toPrecision(significant)).decimals || '').length;\n\t\t\t\t} else {\n\t\t\t\t\t// if there are no significant numbers, the value is 0, so simply look at the number of decimals\n\t\t\t\t\tthis.numberData.decimals = (split.decimals || '').length;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\n\t\tmakeNumber: function(offset) {\n\t\t\t// calculate new number with 8 significant digits and split it\n\t\t\t// for calculating the new number the function x^3/(x^2+200), which provides nice snapping to the original number and\n\t\t\t// lower sensitiveness near the original number\n\t\t\tvar split = jsmm.editor.editables.splitNumber((this.numberData.value + (offset*offset*offset)/((offset*offset+200)*this.numberData.invDelta)).toPrecision(8));\n\n\t\t\t// start off with the integer part\n\t\t\tvar newText = split.integer;\n\n\t\t\t// if we want any decimals, take all the decimals we get with 8 significant digits, and cap this off by the required amount\n\t\t\tif (this.numberData.decimals > 0) {\n\t\t\t\tnewText += '.' + (split.decimals || '0').substring(0, this.numberData.decimals);\n\t\t\t}\n\n\t\t\t// add the exponent using the user-defined letter, if necessary\n\t\t\tif (split.exponent !== undefined) {\n\t\t\t\tnewText += this.numberData.exponentLetter + split.exponent;\n\t\t\t}\n\n\t\t\t// finally add the negative sign if required, and if the rest of the number we have so far does not evaluate to zero\n\t\t\tif (split.sign === '-' && parseFloat(newText) !== 0) {\n\t\t\t\tnewText = '-' + newText;\n\t\t\t}\n\n\t\t\treturn newText;\n\t\t},\n\n\t\tsplitColor: function(text) {\n\t\t\tvar match = /^[\"]([#][0-9a-fA-F]{3}(?:[0-9a-fA-F]{3})?)|(?:(rgb|rgba|hsl|hsla)[(][ ]*(\\d+(?:[.]\\d+)?)([%]?)[ ]*,[ ]*(\\d+(?:[.]\\d+)?)([%]?)[ ]*,[ ]*(\\d+(?:[.]\\d+)?)([%]?)[ ]*(?:,[ ]*(\\d+(?:[.]\\d+)?)[ ]*)?[)])[\"]$/g.exec(text);\n\t\t\tif (match === null) {\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\thex: match[1], // either \"#xxx\" or \"#xxxxxx\"\n\t\t\t\t\tformat: match[2], // either \"rgb\", \"rgba\", \"hsl\", \"hsla\", or undefined\n\t\t\t\t\tpart1: match[3], // number\n\t\t\t\t\tpercent1: match[4], // either \"\" or \"%\"\n\t\t\t\t\tpart2: match[5], // number\n\t\t\t\t\tpercent2: match[6], // either \"\" or \"%\"\n\t\t\t\t\tpart3: match[7], // number\n\t\t\t\t\tpercent3: match[8], // either \"\" or \"%\"\n\t\t\t\t\talpha: match[9] // alpha part or undefined\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\n\t\tparseColor: function(text) {\n\t\t\tthis.colorData = {};\n\t\t\tvar split = jsmm.editor.editables.splitColor(text);\n\t\t\tif (split === null) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tif (split.hex !== undefined) {\n\t\t\t\t\tthis.colorData.value = split.hex;\n\t\t\t\t\tthis.colorData.format = 'hex';\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\tvar a;\n\t\t\t\t\tif (split.format === 'rgb' || split.format === 'rgba') {\n\t\t\t\t\t\tvar r = parseFloat(split.part1);\n\t\t\t\t\t\tvar g = parseFloat(split.part2);\n\t\t\t\t\t\tvar b = parseFloat(split.part3);\n\t\t\t\t\t\ta = parseFloat(split.alpha || '1');\n\t\t\t\t\t\tif (split.percent1 === '%') {\n\t\t\t\t\t\t\tr = r*255/100;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (split.percent2 === '%') {\n\t\t\t\t\t\t\tg = g*255/100;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (split.percent3 === '%') {\n\t\t\t\t\t\t\tb = b*255/100;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255 || a < 0 || a > 1) return false;\n\t\t\t\t\t\tthis.colorData.value = 'rgba(' + r.toFixed(0) + ', ' + g.toFixed(0) + ', ' + b.toFixed(0) + ', ' + a.toFixed(2) + ')';\n\t\t\t\t\t\tthis.colorData.format = 'rgba';\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if (split.format === 'hsl' || split.format === 'hsla') {\n\t\t\t\t\t\tvar h = parseInt(split.part1, 10);\n\t\t\t\t\t\tvar s = parseInt(split.part2, 10);\n\t\t\t\t\t\tvar l = parseInt(split.part3, 10);\n\t\t\t\t\t\ta = parseFloat(split.alpha || '1');\n\t\t\t\t\t\tif (h < 0 || h > 360 || split.percent1 === '%' || s < 0 || s > 100 || split.percent2 !== '%' ||\n\t\t\t\t\t\t\tl < 0 || l > 100 || split.percent3 !== '%' || a < 0 || a > 1) return false;\n\t\t\t\t\t\tthis.colorData.value = 'hsla(' + h.toFixed(0) + ', ' + s.toFixed(2) + '%, ' + l.toFixed(2) + '%, ' + a.toFixed(2) + ')';\n\t\t\t\t\t\tthis.colorData.format = 'hsla';\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tmakeColor: function(color) {\n\t\t\treturn '\"' + color + '\"';\n\t\t}\n\t};\n};\n//@ sourceURL=/jsmm/jsmm.editor.js"
));

require.define("/editor/index.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/*jshint node:true*/\n\"use strict\";\n\nvar editor = {};\n\nrequire('./editor.code')(editor);\nrequire('./editor.editables')(editor);\nrequire('./editor.surface')(editor);\nrequire('./editor.editor')(editor);\n\nmodule.exports = editor;\n//@ sourceURL=/editor/index.js"
));

require.define("/editor/editor.code.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/*jshint node:true jquery:true*/\n\"use strict\";\n\nmodule.exports = function(editor) {\n\teditor.Code = function() { return this.init.apply(this, arguments); };\n\n\teditor.Code.prototype = {\n\t\tinit: function(text) {\n\t\t\tthis.text = '' + text;\n\t\t},\n\t\tgetText: function() {\n\t\t\treturn this.text;\n\t\t},\n\t\tgetLine: function(line) {\n\t\t\tthis.makeLines();\n\t\t\treturn (this.lines[line-1] === undefined ? null : this.lines[line-1]);\n\t\t},\n\t\tlineColumnToOffset: function(line, column) {\n\t\t\tthis.makeOffsets();\n\t\t\treturn (this.offsets[line-1] === undefined ? null : this.offsets[line-1] + column);\n\t\t},\n\t\tposToOffset: function(loc) {\n\t\t\treturn this.lineColumnToOffset(loc.line, loc.column);\n\t\t},\n\t\trangeToText: function(textLoc) {\n\t\t\treturn this.text.substring(this.lineColumnToOffset(textLoc.line, textLoc.column), this.lineColumnToOffset(textLoc.line2, textLoc.column2));\n\t\t},\n\t\toffsetToLoc: function(offset) {\n\t\t\tthis.makeOffsets();\n\t\t\t// TODO: implement binary search\n\t\t\tfor (var i=0; i<this.lines.length; i++) {\n\t\t\t\tif (offset < this.offsets[i]) {\n\t\t\t\t\treturn {line: i, column: offset-(this.offsets[i-1] || 0)};\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {line: this.lines.length, column: offset-this.offsets[this.lines.length-1]};\n\t\t},\n\t\tinsertAtOffset: function(offset, text) {\n\t\t\treturn this.text.substring(0, offset) + text + this.text.substring(offset);\n\t\t},\n\t\tremoveOffsetRange: function(offset1, offset2) {\n\t\t\treturn this.text.substring(0, offset1) + this.text.substring(offset2);\n\t\t},\n\t\treplaceOffsetRange: function(offset1, offset2, text) {\n\t\t\treturn this.text.substring(0, offset1) + text + this.text.substring(offset2);\n\t\t},\n\t\tblockToLeftColumn: function(line1, line2) {\n\t\t\tthis.makeLines();\n\t\t\tvar result = Infinity;\n\t\t\tfor (var i=line1; i<=line2; i++) {\n\t\t\t\tresult = Math.min(result, this.lines[i-1].match(/^ */)[0].length);\n\t\t\t\tif (result <= 0) return result;\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\tblockToRightColumn: function(line1, line2) {\n\t\t\tthis.makeLines();\n\t\t\tvar result = 0;\n\t\t\tfor (var i=line1; i<=line2; i++) {\n\t\t\t\tresult = Math.max(result, this.lines[i-1].length);\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\t/// INTERNAL FUNCTIONS ///\n\t\tmakeLines: function() {\n\t\t\tif (this.lines !== undefined) return;\n\t\t\tthis.lines = this.text.split(/\\n/);\n\t\t},\n\t\tmakeOffsets: function() {\n\t\t\tif (this.offsets !== undefined) return;\n\t\t\tthis.makeLines();\n\t\t\tthis.offsets = [0];\n\t\t\tfor (var i=1; i<this.lines.length; i++) {\n\t\t\t\t// add one for the actual newline character\n\t\t\t\tthis.offsets[i] = this.offsets[i-1] + this.lines[i-1].length + 1;\n\t\t\t}\n\t\t}\n\t};\n};\n\n//@ sourceURL=/editor/editor.code.js"
));

require.define("/editor/editor.editables.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/*jshint node:true jquery:true*/\n\"use strict\";\n\nvar clayer = require('../clayer');\n\nmodule.exports = function(editor) {\n\teditor.editables = {};\n\n\teditor.editables.NumberEditable = function() { return this.build.apply(this, arguments); };\n\teditor.editables.CycleEditable = function() { return this.build.apply(this, arguments); };\n\teditor.editables.ColorEditable = function() { return this.build.apply(this, arguments); };\n\n\tvar addCommonMethods = function(type, editable) {\n\t\teditable.build = function(node, surface, delegate, parseValue, makeValue) {\n\t\t\tthis.surface = surface;\n\t\t\tthis.delegate = delegate;\n\t\t\tthis.parseValue = parseValue;\n\t\t\tthis.makeValue = makeValue;\n\n\t\t\tthis.line = node.lineLoc.line;\n\t\t\tthis.column = node.lineLoc.column;\n\t\t\tthis.column2 = node.lineLoc.column2;\n\t\t\tthis.text = delegate.getEditablesText(node);\n\t\t\tthis.finalText = this.text;\n\t\t\tthis.valid = this.parseValue(this.text);\n\n\t\t\tthis.$marking = $('<div class=\"editor-marking editor-editable editor-' + type + '-editable\"></div>');\n\t\t\tthis.surface.addElement(this.$marking);\n\t\t\tthis.init();\n\n\t\t\tthis.updateMarking();\n\t\t};\n\n\t\teditable.offsetColumn = function(column, amount) {\n\t\t\tif (this.column2 > column) {\n\t\t\t\tthis.column2 += amount;\n\t\t\t\tif (this.column > column) {\n\t\t\t\t\tthis.column += amount;\n\t\t\t\t}\n\t\t\t\tthis.updateMarking();\n\t\t\t}\n\t\t};\n\n\t\t/// INTERNAL FUNCTIONS ///\n\n\t\teditable.updateMarking = function() {\n\t\t\tif (!this.valid) this.remove();\n\t\t\tthis.surface.setElementLocationRange(this.$marking, this.line, this.column, this.line+1, this.column2);\n\t\t};\n\n\t\teditable.updateValue = function() {\n\t\t\tthis.delegate.editableReplaceCode(this.line, this.column, this.column2, this.text);\n\t\t};\n\n\t\treturn editable;\n\t};\n\n\teditor.editables.CycleEditable.prototype = addCommonMethods('cycle', {\n\t\tinit: function() {\n\t\t\tthis.$marking.on('click', $.proxy(this.cycle, this));\n\t\t},\n\t\tremove: function() {\n\t\t\tthis.$marking.remove();\n\t\t},\n\t\tcycle: function() {\n\t\t\tthis.text = this.makeValue();\n\t\t\tthis.updateValue();\n\t\t\tthis.valid = this.parseValue(this.text);\n\t\t}\n\t});\n\n\teditor.editables.NumberEditable.prototype = addCommonMethods('number', {\n\t\tinit: function() {\n\t\t\tthis.hasTooltip = false;\n\t\t\tthis.touchable = new clayer.Touchable(this.$marking, this);\n\t\t},\n\n\t\tremove: function() {\n\t\t\tthis.hideTooltip();\n\t\t\tthis.$marking.remove();\n\t\t\tthis.touchable.setTouchable(false);\n\t\t},\n\n\t\t/// INTERNAL FUNCTIONS ///\n\t\tshowTooltip: function() {\n\t\t\tif (!this.hasTooltip) {\n\t\t\t\tthis.hasTooltip = true;\n\t\t\t\tthis.$marking.tooltip({\n\t\t\t\t\ttitle: '&larr; drag &rarr;',\n\t\t\t\t\tplacement: 'bottom'\n\t\t\t\t});\n\t\t\t}\n\t\t\tthis.$marking.tooltip('show');\n\t\t},\n\n\t\thideTooltip: function() {\n\t\t\tif (this.hasTooltip) {\n\t\t\t\tthis.$marking.tooltip('hide');\n\t\t\t}\n\t\t},\n\n\t\ttouchDown: function(touch) {\n\t\t\tthis.hideTooltip();\n\t\t},\n\n\t\ttouchMove: function(touch) {\n\t\t\tthis.text = this.makeValue(touch.translation.x);\n\t\t\tthis.updateValue();\n\t\t},\n\n\t\ttouchUp: function(touch) {\n\t\t\tthis.valid = this.parseValue(this.text);\n\t\t\tif (touch.wasTap) {\n\t\t\t\tthis.showTooltip();\n\t\t\t}\n\t\t}\n\t});\n\n\teditor.editables.ColorEditable.prototype = addCommonMethods('color', {\n\t\tinit: function() {\n\t\t\tthis.$colorPicker = $('<div class=\"editor-editable-colorpicker\"></div>');\n\t\t\tthis.box = new editor.Box(this.$marking, this.surface);\n\t\t\tthis.box.html(this.$colorPicker);\n\t\t\tthis.$colorPicker.colorPicker({\n\t\t\t\tformat: this.colorData.format,\n\t\t\t\tsize: 200,\n\t\t\t\tcolorChange: $.proxy(this.colorChange, this)\n\t\t\t});\n\t\t\tthis.$colorPicker.colorPicker('setColor', this.colorData.value);\n\t\t\tthis.$marking.on('click', $.proxy(this.click, this));\n\t\t},\n\n\t\t/// INTERNAL FUNCTIONS ///\n\t\tremove: function() {\n\t\t\tthis.$marking.remove();\n\t\t\tthis.box.remove();\n\t\t},\n\n\t\tcolorChange: function(event, ui) {\n\t\t\tthis.text = this.makeValue(ui.color);\n\t\t\tthis.updateValue();\n\t\t},\n\n\t\tclick: function(event) {\n\t\t\tthis.valid = this.parseValue(this.text);\n\t\t\tif (this.box.$element.is(':visible')) {\n\t\t\t\tthis.box.$element.fadeOut(150);\n\t\t\t} else {\n\t\t\t\tthis.box.$element.fadeIn(150);\n\t\t\t\tthis.box.updatePosition();\n\t\t\t}\n\t\t}\n\t});\n};\n\n//@ sourceURL=/editor/editor.editables.js"
));

require.define("/clayer/index.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/*jshint node:true jquery:true */\n/*global Modernizr:false */\n\"use strict\";\n\nvar clayer = {};\n\nclayer.Touchable = function() { return this.init.apply(this, arguments); };\nclayer.Touch = function() { return this.init.apply(this, arguments); };\n\n\n/*\nclayer.properties = {};\nvar ua = navigator.userAgent.toLowerCase();\nclayer.properties.isWebKit = !!ua.match(/applewebkit/);\nclayer.properties.isTouch = !!(ua.match(/ipad/) || ua.match(/iphone/) || ua.match(/ipod/) || ua.match(/android/));\nclayer.properties.isHoverAvailable = !clayer.properties.isTouch;\n\nclayer.properties.useTransitions = Modernizr.csstransitions;\nclayer.properties.useTransforms = Modernizr.csstransforms;\nclayer.properties.useTransforms3D = Modernizr.csstransforms3d;\n\nclayer.properties.defaultMoveAnimationDuration = 0;\nclayer.properties.defaultFadeAnimationDuration = 150;\n\nclayer.Layer = function() { return this.init.apply(this, arguments); };\nclayer.Layer.prototype = {\n\tinit: function($element) {\n\t\tthis.$element = $element;\n\t\tthis.x = 0;\n\t\tthis.y = 0;\n\t\tthis.width = 0;\n\t\tthis.height = 0;\n\t\tthis.opacity = 1;\n\t\tthis.hidden = false;\n\t\tthis.timeout = null;\n\t\t\n\t\tthis.offsetX = 0;\n\t\tthis.offsetY = 0;\n\t\t\n\t\tthis.accelerated = true;\n\t\tthis.moveAnimationDuration = clayer.properties.defaultMoveAnimationDuration;\n\t\tthis.fadeAnimationDuration = clayer.properties.defaultFadeAnimationDuration;\n\t\n\t\tif (clayer.properties.useTransitions) {\n\t\t\tif (clayer.properties.useTransforms && this.accelerated) {\n\t\t\t\tthis.$element.css(Modernizr.prefixed('TransitionProperty'), 'transform, width, height, opacity');\n\t\t\t} else {\n\t\t\t\tthis.$element.css(Modernizr.prefixed('TransitionProperty'), 'left, top, width, height, opacity');\n\t\t\t}\n\t\t\tthis.$element.css(Modernizr.prefixed('TransitionDuration'), '0s');\n\t\t\tthis.$element.css(Modernizr.prefixed('TransitionTimingFunction'), 'ease-in-out');\n\t\t}\n\t},\n\tsetX: function(x, animate) {\n\t\tthis.setPosition(x, this.y, animate);\n\t},\n\tsetY: function(y, animate) {\n\t\tthis.setPosition(this.x, y, animate);\n\t},\n\tsetPosition: function(x, y, animate) {\n\t\tif (this.x === x && this.y === y) return;\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.updateElementPosition(animate);\n\t},\n\tsetOffset: function(x, y, animate) {\n\t\tif (this.offsetX === x && this.offsetY === y) return;\n\t\tthis.offsetX = x;\n\t\tthis.offsetY = y;\n\t\tthis.updateElementPosition(animate);\n\t},\n\tsetWidth: function(width, animate) {\n\t\tif (this.width === width) return;\n\t\tthis.width = width;\n\t\tthis.setAnimatableProperty('width', width, 'px', animate ? this.moveAnimationDuration : 0);\n\t},\n\tsetHeight: function(height, animate) {\n\t\tif (this.height === height) return;\n\t\tthis.height = height;\n\t\tthis.setAnimatableProperty('height', height, 'px', animate ? this.moveAnimationDuration : 0);\n\t},\n\tsetOpacity: function(opacity, animate) {\n\t\tif (this.opacity === opacity) return;\n\t\tthis.opacity = opacity;\n\t\tthis.setAnimatableProperty('opacity', opacity, '', animate ? this.fadeAnimationDuration : 0);\n\t},\n\tshow: function(animate) {\n\t\tif (!this.hidden) return;\n\t\tthis.hidden = false;\n\t\tif (this.timeout !== null) {\n\t\t\twindow.clearTimeout(this.timeout);\n\t\t\tthis.timeout = null;\n\t\t}\n\t\tthis.setAnimatableProperty('opacity', 0, '', 0);\n\t\tthis.$element.css('display', 'block');\n\t\tthis.setOpacity(this.opacity, animate);\n\t},\n\thide: function(animate) {\n\t\tif (this.hidden) return;\n\t\tthis.hidden = true;\n\t\tif (this.timeout !== null) {\n\t\t\twindow.clearTimeout(this.timeout);\n\t\t\tthis.timeout = null;\n\t\t}\n\t\tthis.setAnimatableProperty('opacity', 0, '', animate ? this.fadeAnimationDuration : 0);\n\t\tvar that = this;\n\t\tthis.timeout = window.setTimeout(function() {\n\t\t\tthat.$element.css('display', 'none');\n\t\t\tthat.timeout = null;\n\t\t}, animate ? this.fadeAnimationDuration : 0);\n\t},\n\ttoggle: function() {\n\t\tif (this.hidden) this.show();\n\t\telse this.hide();\n\t},\n\tsetAccelerated: function(value) {\n\t\tthis.accelerated = value;\n\t},\n\tsetAnimationDuration: function(move, fade) {\n\t\tthis.moveAnimationDuration = move;\n\t\tthis.fadeAnimationDuration = fade;\n\t},\n\tremove: function() {\n\t\tthis.$element.remove();\n\t},\n\t/// INTERNAL FUNCTIONS ///\n\tupdateElementPosition: function (animate) {\n\t\tanimate = animate || false;\n\t\tvar x = this.x+this.offsetX, y = this.y+this.offsetY;\n\n\t\tif (clayer.properties.useTransitions && clayer.properties.useTransforms && this.accelerated) {\n\t\t\tif (animate && this.moveAnimationDuration > 0) {\n\t\t\t\tthis.$element.css(Modernizr.prefixed('TransitionDuration'), '' + (0.001 * this.moveAnimationDuration) + 's');\n\t\t\t}\n\n\t\t\tvar translation = clayer.properties.useTransforms3D ?\n\t\t\t\t'translate3d(' + x + 'px,' + y + 'px, 0) ' :\n\t\t\t\t'translate('   + x + 'px,' + y + 'px) ';\n\n\t\t\tthis.$element.css(Modernizr.prefixed('Transform'), translation);\n\t\t} else {\n\t\t\tthis.setAnimatableProperty('left', x, 'px', animate ? this.moveAnimationDuration : 0);\n\t\t\tthis.setAnimatableProperty('top', y, 'px', animate ? this.moveAnimationDuration : 0);\n\t\t}\n\t},\n\tsetAnimatableProperty: function (name, value, suffix, animationDuration) {\n\t\tsuffix = suffix || '';\n\t\tanimationDuration = animationDuration || 0;\n\t\tif (animationDuration > 0) {\n\t\t\tif (clayer.properties.useTransitions) {\n\t\t\t\tthis.$element.css(Modernizr.prefixed('TransitionDuration'), '' + (0.001 * animationDuration) + 's');\n\t\t\t\tthis.$element.css(name, '' + value + suffix);\n\t\t\t} else {\n\t\t\t\tthis.$element.animate({name: '' + value + suffix}, animationDuration);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.$element.css(name, '' + value + suffix);\n\t\t}\n\t}\n};\n*/\n\nclayer.Touchable.prototype = {\n\tinit: function($element, delegate) {\n\t\tthis.$element = $element;\n\t\tthis.$document = $($element[0].ownerDocument);\n\t\tthis.delegate = delegate;\n\n\t\tthis.mouseDown = $.proxy(this.mouseDownHandler, this);\n\t\tthis.mouseMove = $.proxy(this.mouseMoveHandler, this);\n\t\tthis.mouseUp = $.proxy(this.mouseUpHandler, this);\n\t\tthis.touchStart = $.proxy(this.touchStartHandler, this);\n\t\tthis.touchMove = $.proxy(this.touchMoveHandler, this);\n\t\tthis.touchEnd = $.proxy(this.touchEndHandler, this);\n\n\t\tthis.documentEvents = {\n\t\t\tmousemove: this.mouseMove,\n\t\t\tmouseup: this.mouseUp,\n\t\t\ttouchmove: this.touchMove,\n\t\t\ttouchend: this.touchEnd,\n\t\t\ttouchcancel: this.touchEnd\n\t\t};\n\n\t\tthis.setTouchable(true);\n\t},\n\n\tsetTouchable: function(isTouchable) {\n\t\tif (this.isTouchable === isTouchable) return;\n\t\tthis.isTouchable = isTouchable;\n\n\t\tif (isTouchable) {\n\t\t\tthis.$element.on({\n\t\t\t\tmousedown: this.mouseDown,\n\t\t\t\ttouchstart: this.touchStart\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\tthis.$element.off('mousedown touchstart');\n\t\t\tthis.$document.off(this.documentEvents);\n\t\t}\n\t},\n\n\tmouseDownHandler: function(event) {\n\t\tif (this.isTouchable) {\n\t\t\tthis.$document.on({\n\t\t\t\tmousemove: this.mouseMove,\n\t\t\t\tmouseup: this.mouseUp\n\t\t\t});\n\t\t\t\n\t\t\tthis.touch = new clayer.Touch(this.$element, event);\n\t\t\tthis.delegate.touchDown(this.touch);\n\t\t}\n\t\treturn false;\n\t},\n\n\tmouseMoveHandler: function(event) {\n\t\tif (this.isTouchable && this.touch) {\n\t\t\tthis.touch.touchMove(event);\n\t\t\tthis.delegate.touchMove(this.touch);\n\t\t}\n\t\treturn false;\n\t},\n\n\tmouseUpHandler: function(event) {\n\t\tif (this.isTouchable && this.touch) {\n\t\t\tthis.touch.touchUp(event);\n\t\t\tthis.delegate.touchUp(this.touch);\n\t\t\t\n\t\t\tdelete this.touch;\n\t\t}\n\t\tthis.$document.off(this.documentEvents);\n\t\treturn false;\n\t},\n\n\ttouchStartHandler: function(event) {\n\t\tif (!this.isTouchable || this.touch || event.originalEvent.touches.length > 1) {\n\t\t\t// only single touch for now\n\t\t\tthis.touchEnd(event);\n\t\t} else {\n\t\t\tthis.$document.on({\n\t\t\t\ttouchmove: this.touchMove,\n\t\t\t\ttouchend: this.touchEnd,\n\t\t\t\ttouchcancel: this.touchEnd\n\t\t\t});\n\t\t\n\t\t\tthis.touch = new clayer.Touch(this.$element, event.originalEvent.touches[0]);\n\t\t\tthis.touchDown(this.touch);\n\t\t}\n\t\treturn false;\n\t},\n\n\ttouchMoveHandler: function(event) {\n\t\tif (this.isTouchable && this.touch) {\n\t\t\tthis.touch.touchMove(event.originalEvent.touches[0]);\n\t\t\tthis.delegate.touchMove(this.touch);\n\t\t}\n\t\treturn false;\n\t},\n\n\ttouchEndHandler: function(event) {\n\t\tif (this.isTouchable && this.touch) {\n\t\t\tthis.touch.touchUp(event.originalEvent.touches[0]);\n\t\t\tthis.delegate.touchUp(this.touch);\n\t\t\t\n\t\t\tdelete this.touch;\n\t\t}\n\t\tthis.$document.off(this.documentEvents);\n\t\treturn false;\n\t}\n};\n\nclayer.Touch.prototype = {\n\tinit: function($element, event) {\n\t\tthis.$element = $element;\n\t\tthis.globalPoint = { x: event.pageX, y: event.pageY };\n\t\tthis.translation = { x:0, y:0 };\n\t\tthis.deltaTranslation = { x:0, y:0 };\n\t\tthis.localPoint = { x:0, y:0 };\n\t\tthis.updateLocalPoint();\n\n\t\tthis.event = event;\n\t\tthis.timestamp = event.timeStamp;\n\t\tthis.downTimestamp = this.timestamp;\n\t\tthis.hasMoved = false;\n\t\tthis.wasTap = false;\n\t},\n\n\ttouchMove: function(event) {\n\t\tthis.event = event;\n\t\tthis.timestamp = event.timeStamp;\n\t\tthis.updatePositions();\n\t},\n\n\ttouchUp: function(event) {\n\t\tthis.event = event;\n\t\tthis.timestamp = event.timeStamp;\n\t\tthis.wasTap = !this.hasMoved && (this.getTimeSinceGoingDown() < 300);\n\t},\n\n\tgetTimeSinceGoingDown: function () {\n\t\treturn this.timestamp - this.downTimestamp;\n\t},\n\n\tresetDeltaTranslation: function() {\n\t\tthis.deltaTranslation.x = 0;\n\t\tthis.deltaTranslation.y = 0;\n\t},\n\n\tupdatePositions: function() {\n\t\tvar dx = this.event.pageX - this.globalPoint.x;\n\t\tvar dy = this.event.pageY - this.globalPoint.y;\n\t\tthis.translation.x += dx;\n\t\tthis.translation.y += dy;\n\t\tthis.deltaTranslation.x += dx;\n\t\tthis.deltaTranslation.y += dy;\n\t\tthis.globalPoint.x = this.event.pageX;\n\t\tthis.globalPoint.y = this.event.pageY;\n\t\tthis.updateLocalPoint();\n\n\t\tif (Math.abs(this.translation.x) > 10 || Math.abs(this.translation.y) > 10) this.hasMoved = true;\n\t},\n\n\tupdateLocalPoint: function() {\n\t\tvar offset = this.$element.offset();\n\t\tthis.localPoint.x = this.globalPoint.x - offset.left;\n\t\tthis.localPoint.y = this.globalPoint.y - offset.left;\n\t}\n};\n\nmodule.exports = clayer;\n\n//@ sourceURL=/clayer/index.js"
));

require.define("/editor/editor.surface.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/*jshint node:true jquery:true*/\n\"use strict\";\n\nvar clayer = require('../clayer');\n\nmodule.exports = function(editor) {\n\teditor.Box = function() { return this.init.apply(this, arguments); };\n\teditor.Message = function() { return this.init.apply(this, arguments); };\n\teditor.AutoCompleteBox = function() { return this.init.apply(this, arguments); };\n\teditor.Surface = function() { return this.init.apply(this, arguments); };\n\t\n\teditor.Box.prototype = {\n\t\tinit: function($marking, surface) {\n\t\t\tthis.$marking = $marking;\n\t\t\tthis.surface = surface;\n\t\t\tthis.$element = $('<div class=\"editor-box\"></div>');\n\t\t\tthis.surface.addElement(this.$element);\n\t\t\tthis.$element.hide();\n\t\t\tthis.$arrow = $('<div class=\"editor-box-arrow\"></div>');\n\t\t\tthis.$element.append(this.$arrow);\n\t\t\tthis.$message = $('<div class=\"editor-box-message\"></div>');\n\t\t\tthis.$element.append(this.$message);\n\t\t},\n\t\tupdatePosition: function() {\n\t\t\t//console.log(this.$marking.offset().left);\n\t\t\t//this.surface.setElementCenterPosition(this.$element, this.$marking.position().left+this.$marking.outerWidth()/2, this.$marking.position().top+this.$marking.outerHeight());\n\t\t\tvar left = this.$marking.position().left+this.$marking.outerWidth()/2;\n\t\t\tvar newLeft = Math.max(-8, left-this.$element.outerWidth()/2);\n\t\t\tthis.$element.css('left', newLeft);\n\t\t\tthis.$arrow.css('left', left-newLeft);\n\t\t\tthis.$element.css('top', this.$marking.position().top+this.$marking.outerHeight());\n\t\t},\n\t\thtml: function(html) {\n\t\t\tthis.$message.html(html);\n\t\t\tthis.updatePosition();\n\t\t},\n\t\tremove: function() {\n\t\t\tthis.$element.remove();\n\t\t}\n\t};\n\n\teditor.Message.prototype = {\n\t\tinit: function(type, surface) {\n\t\t\tthis.surface = surface;\n\t\t\tthis.$marginIcon = $('<div class=\"editor-margin-icon editor-margin-message-icon-' + type + '\"><img src=\"img/margin-message-icon-' + type + '.png\"/></div>');\n\t\t\tthis.surface.addElementToMargin(this.$marginIcon);\n\t\t\tthis.$marginIcon.hide();\n\t\t\tthis.$marking = $('<div class=\"editor-marking\"></div>');\n\t\t\tthis.surface.addElement(this.$marking);\n\t\t\tthis.$marking.hide();\n\t\t\tthis.box = new editor.Box(this.$marking, this.surface);\n\t\t\tthis.$marginIcon.on('click', $.proxy(this.toggleMesssage, this));\n\t\t\tthis.$marking.on('click', $.proxy(this.toggleMesssage, this));\n\t\t\tthis.box.$element.on('click', $.proxy(this.toggleMesssage, this));\n\t\t\tthis.visible = false;\n\t\t\tthis.messageOpen = false;\n\t\t\tthis.message = null;\n\t\t},\n\t\tshowAtLocation: function(msg) {\n\t\t\tthis.$marginIcon.css('top', this.surface.lineToY(msg.line));\n\t\t\tthis.$marginIcon.fadeIn(150);\n\t\t\tthis.message = msg;\n\t\t\tthis.visible = true;\n\t\t\tthis.updateMessage();\n\t\t},\n\t\topenMessage: function() {\n\t\t\tthis.messageOpen = true;\n\t\t\tthis.updateMessage();\n\t\t},\n\t\tcloseMessage: function() {\n\t\t\tthis.messageOpen = false;\n\t\t\tthis.updateMessage();\n\t\t},\n\t\thide: function() {\n\t\t\tthis.visible = false;\n\t\t\tthis.$marginIcon.fadeOut(150);\n\t\t\tthis.updateMessage();\n\t\t},\n\t\t/// INTERNAL FUNCTIONS ///\n\t\ttoggleMesssage: function() {\n\t\t\tthis.messageOpen = !this.messageOpen;\n\t\t\tthis.updateMessage();\n\t\t},\n\t\tupdateMessage: function() {\n\t\t\tif (this.visible && this.messageOpen && this.message !== null) {\n\t\t\t\tthis.$marking.fadeIn(150);\n\t\t\t\tthis.box.$element.fadeIn(150);\n\t\t\t\tthis.surface.setElementLocationRange(this.$marking, this.message.line, this.message.column, this.message.line+1, this.message.column2);\n\t\t\t\tthis.box.html(this.message.html);\n\t\t\t} else {\n\t\t\t\tthis.$marking.fadeOut(150);\n\t\t\t\tthis.box.$element.fadeOut(150);\n\t\t\t}\n\t\t}\n\t};\n\n\teditor.AutoCompleteBox.prototype = {\n\t\tinit: function(surface, delegate, line, column, offset) {\n\t\t\tthis.$element = $('<div class=\"editor-autocomplete-box\"><div class=\"editor-autocomplete-arrow\"></div></div>');\n\t\t\tsurface.addElement(this.$element);\n\n\t\t\tthis.$content = $('<div class=\"editor-autocomplete-content\"></div>');\n\t\t\tthis.$element.append(this.$content);\n\n\t\t\tthis.$marginIcon = $('<div class=\"editor-margin-icon\"><img src=\"img/margin-message-icon-preview.png\"/></div>');\n\t\t\tsurface.addElementToMargin(this.$marginIcon);\n\t\t\tthis.$marginIcon.css('top', surface.lineToY(line));\n\t\t\tthis.$marginIcon.hide();\n\t\t\tthis.$marginIcon.fadeIn(150);\n\n\t\t\tthis.line = line; this.column = column, this.offset = offset;\n\t\t\tsurface.setElementLocation(this.$element, line+1, column);\n\n\t\t\tthis.delegate = delegate;\n\t\t\tthis.width = 0;\n\t\t\tthis.offset = offset;\n\t\t\tthis.addSemicolon = false;\n\t\t\tthis.selected = -1;\n\t\t\tthis.examples = [];\n\t\t},\n\t\tsetExamples: function(examples, text, addSemicolon) {\n\t\t\tvar previousExample = this.examples[this.selected] || '';\n\t\t\tthis.examples = examples.examples;\n\t\t\tthis.width = examples.width;\n\t\t\tthis.text = text;\n\t\t\tthis.addSemicolon = addSemicolon;\n\t\t\tthis.$content.children('.editor-autocomplete-line').remove();\n\t\t\tthis.$lines = [];\n\t\t\tvar selected = -1;\n\t\t\tfor (var i=0; i<this.examples.length; i++) {\n\t\t\t\tvar $line = $('<div class=\"editor-autocomplete-line\"></div>');\n\t\t\t\t$line.html(examples.prefix + '<strong>' + this.examples[i].substring(0, examples.width) + '</strong>' + this.examples[i].substring(this.width));\n\t\t\t\t$line.on('mousemove', $.proxy(this.mouseMove, this));\n\t\t\t\t$line.on('click', $.proxy(this.click, this));\n\t\t\t\t$line.data('example-number', i);\n\t\t\t\tthis.$content.append($line);\n\t\t\t\tthis.$lines.push($line);\n\t\t\t\tif (this.examples[i] === previousExample) selected = i;\n\t\t\t}\n\t\t\tthis.select(selected);\n\t\t},\n\t\tremove: function() {\n\t\t\tthis.$element.remove();\n\t\t\tthis.$marginIcon.remove();\n\t\t},\n\t\tup: function() {\n\t\t\tif (this.selected > 0) {\n\t\t\t\tthis.select(this.selected-1);\n\t\t\t} else {\n\t\t\t\tthis.select(this.examples.length-1);\n\t\t\t}\n\t\t\tthis.scrollToSelected();\n\t\t\treturn true;\n\t\t},\n\t\tdown: function() {\n\t\t\tif (this.selected < this.examples.length-1) {\n\t\t\t\tthis.select(this.selected+1);\n\t\t\t} else {\n\t\t\t\tthis.select(0);\n\t\t\t}\n\t\t\tthis.scrollToSelected();\n\t\t\treturn true;\n\t\t},\n\t\tenter: function() {\n\t\t\tif (this.selected >= 0 && this.selected < this.examples.length) {\n\t\t\t\tthis.insert();\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\t/// INTERNAL FUNCTIONS ///\n\t\tselect: function(number) {\n\t\t\tthis.$content.children('.editor-autocomplete-line').removeClass('editor-autocomplete-selected');\n\t\t\tthis.selected = number;\n\t\t\tif (this.selected >= 0) {\n\t\t\t\tthis.$lines[this.selected].addClass('editor-autocomplete-selected');\n\t\t\t\tvar example = this.examples[this.selected] + (this.addSemicolon ? ';' : '');\n\t\t\t\tthis.delegate.previewExample(this.offset, this.offset+this.width, example);\n\t\t\t} else {\n\t\t\t\tthis.delegate.previewExample(this.offset, this.offset+this.width, '');\n\t\t\t}\n\t\t},\n\t\tscrollToSelected: function() {\n\t\t\tif (this.selected >= 0) {\n\t\t\t\t// the offset is weird since .position().top changes when scrolling\n\t\t\t\tvar y = this.$lines[this.selected].position().top + this.$content.scrollTop();\n\t\t\t\ty = Math.max(0, y - this.$content.height()/2);\n\t\t\t\tthis.$content.stop(true).animate({scrollTop : y}, 150);\n\t\t\t} else {\n\t\t\t\tthis.$content.stop(true).animate({scrollTop : 0}, 150);\n\t\t\t}\n\t\t},\n\t\tinsert: function(number) {\n\t\t\tnumber = number || this.selected;\n\t\t\tvar example = this.examples[number] + (this.addSemicolon ? ';' : '');\n\t\t\tthis.delegate.insertExample(this.offset, this.offset+this.width, example);\n\t\t},\n\t\tmouseMove: function(event) {\n\t\t\tthis.select($(event.delegateTarget).data('example-number'));\n\t\t},\n\t\tclick: function(event) {\n\t\t\tthis.insert($(event.delegateTarget).data('example-number'));\n\t\t}\n\t};\n\n\teditor.Surface.prototype = {\n\t\tinit: function($div, delegate) {\n\t\t\tthis.$div = $div;\n\t\t\tthis.$div.addClass('editor');\n\t\t\tthis.delegate = delegate;\n\n\t\t\t// setting up textarea\n\t\t\tthis.$textarea = $('<textarea class=\"editor-code\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" wrap=\"off\"></textarea>');\n\t\t\tthis.$div.append(this.$textarea);\n\n\t\t\tthis.$textarea.on('keydown', $.proxy(this.keyDown, this));\n\t\t\tthis.$textarea.on('keyup', $.proxy(this.keyUp, this));\n\t\t\tthis.$textarea.on('click', $.proxy(this.click, this));\n\n\t\t\t// setting up surface\n\t\t\tthis.$surface = $('<div class=\"editor-surface\"></div>');\n\t\t\tthis.$div.append(this.$surface);\n\n\t\t\t// setting up margin\n\t\t\tthis.$margin = $('<div class=\"editor-margin\"></div>');\n\t\t\tthis.$div.append(this.$margin);\n\t\t\t\n\t\t\t// setting up messages\n\t\t\tthis.errorMessage = new editor.Message('error', this);\n\t\t\tthis.stepMessage = new editor.Message('step', this);\n\n\t\t\t// highlights\n\t\t\tthis.$highlightMarking = $('<div class=\"editor-marking editor-highlight\"></div>');\n\t\t\tthis.addElement(this.$highlightMarking);\n\t\t\tthis.$highlightMarking.hide();\n\n\t\t\tthis.initOffsets();\n\n\t\t\tthis.text = '';\n\t\t\tthis.userChangedText = false;\n\t\t\tthis.autoCompleteBox = null;\n\t\t},\n\n\t\tgetText: function() {\n\t\t\treturn this.text;\n\t\t},\n\n\t\tsetText: function(newText) {\n\t\t\tthis.lastSelectionStart = this.$textarea[0].selectionStart;\n\t\t\tthis.lastSelectionEnd = this.$textarea[0].selectionEnd;\n\t\t\tthis.$textarea.val(newText);\n\t\t\tthis.text = newText;\n\t\t\tthis.userChangedText = false;\n\t\t\tthis.updateSize();\n\t\t\tthis.$textarea[0].selectionStart = this.lastSelectionStart;\n\t\t\tthis.$textarea[0].selectionEnd = this.lastSelectionStart;\n\t\t},\n\n\t\tcolumnToX: function(column) {\n\t\t\treturn column*this.charWidth;\n\t\t},\n\n\t\tlineToY: function(line) {\n\t\t\treturn (line-1)*this.lineHeight;\n\t\t},\n\n\t\taddElement: function($element) {\n\t\t\tthis.$surface.append($element);\n\t\t},\n\n\t\taddElementToMargin: function($element) {\n\t\t\tthis.$margin.append($element);\n\t\t},\n\n\t\tenableMouse: function() {\n\t\t\tthis.$div.on('mousemove', $.proxy(this.mouseMove, this));\n\t\t\tthis.$div.on('mouseleave', $.proxy(this.mouseLeave, this));\n\t\t},\n\n\t\tdisableMouse: function() {\n\t\t\tthis.$div.off('mousemove mouseleave');\n\t\t},\n\n\t\tshowErrorMessage: function(message) {\n\t\t\tthis.errorMessage.showAtLocation(message);\n\t\t\tthis.$textarea.addClass('editor-error');\n\t\t},\n\n\t\thideErrorMessage: function() {\n\t\t\tthis.$textarea.removeClass('editor-error');\n\t\t\tthis.errorMessage.closeMessage();\n\t\t\tthis.errorMessage.hide();\n\t\t},\n\n\t\topenStepMessage: function() {\n\t\t\tthis.stepMessage.openMessage();\n\t\t},\n\n\t\tshowStepMessage: function(message) {\n\t\t\tthis.$textarea.addClass('editor-step');\n\t\t\tthis.stepMessage.showAtLocation(message);\n\t\t},\n\n\t\thideStepMessage: function() {\n\t\t\tthis.$textarea.removeClass('editor-step');\n\t\t\tthis.stepMessage.hide();\n\t\t},\n\n\t\tenableHighlighting: function() {\n\t\t\tthis.$textarea.addClass('editor-highlighting');\n\t\t},\n\n\t\tdisableHighlighting: function() {\n\t\t\tthis.$textarea.removeClass('editor-highlighting');\n\t\t\tthis.hideHighlight();\n\t\t},\n\n\t\tshowHighlight: function(line, column, line2, column2) {\n\t\t\tthis.$highlightMarking.show();\n\t\t\tthis.setElementLocationRange(this.$highlightMarking, line, column, line2, column2);\n\t\t},\n\n\t\thideHighlight: function() {\n\t\t\tthis.$highlightMarking.hide();\n\t\t},\n\n\t\tscrollToLine: function(line) {\n\t\t\tthis.scrollToY(this.lineToY(line));\n\t\t},\n\n\t\tsetElementLocation: function($element, line, column) {\n\t\t\t$element.css('left', this.columnToX(column));\n\t\t\t$element.css('top', this.lineToY(line));\n\t\t},\n\n\t\tsetElementLocationRange: function($element, line, column, line2, column2) {\n\t\t\tvar x = this.columnToX(column), y = this.lineToY(line);\n\t\t\t$element.css('left', x);\n\t\t\t$element.css('top', y);\n\t\t\t$element.width(this.columnToX(column2) - x);\n\t\t\t$element.height(this.lineToY(line2) - y);\n\t\t},\n\n\t\tsetElementCenterPosition: function($element, x, y) {\n\t\t\t$element.css('left', x-$element.outerWidth()/2);\n\t\t\t$element.css('top', y);\n\t\t},\n\n\t\tsetElementCenterLocation: function($element, line, column) {\n\t\t\t$element.css('left', this.columnToX(column)-$element.outerWidth()/2);\n\t\t\t$element.css('top', this.lineToY(line));\n\t\t},\n\n\t\trestoreCursor: function(from, offset) {\n\t\t\tif (this.lastSelectionStart !== null && this.lastSelectionEnd !== null) {\n\t\t\t\tif (this.lastSelectionStart >= from) this.$textarea[0].selectionStart = this.lastSelectionStart + offset;\n\t\t\t\tif (this.lastSelectionEnd >= from) this.$textarea[0].selectionEnd = this.lastSelectionEnd + offset;\n\t\t\t}\n\t\t},\n\n\t\trestoreCursorRange: function(offset1, offset2) {\n\t\t\tif (this.lastSelectionStart !== null && this.lastSelectionEnd !== null) {\n\t\t\t\tthis.$textarea[0].selectionStart = this.lastSelectionStart + offset1;\n\t\t\t\tthis.$textarea[0].selectionEnd = this.lastSelectionEnd + offset2;\n\t\t\t}\n\t\t},\n\n\t\tsetCursor: function(start, end) {\n\t\t\tthis.$textarea[0].selectionStart = start;\n\t\t\tthis.$textarea[0].selectionEnd = end;\n\t\t},\n\n\t\tresetCursor: function() {\n\t\t\tthis.lastSelectionStart = null;\n\t\t\tthis.lastSelectionEnd = null;\n\t\t},\n\n\t\tshowAutoCompleteBox: function(line, column, offset, examples, addSemicolon) {\n\t\t\tif (this.autoCompleteBox !== null) {\n\t\t\t\tif (this.autoCompleteBox.offset !== offset) {\n\t\t\t\t\tthis.autoCompleteBox.remove();\n\t\t\t\t\tthis.autoCompleteBox = new editor.AutoCompleteBox(this, this.delegate, line, column, offset);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.autoCompleteBox = new editor.AutoCompleteBox(this, this.delegate, line, column, offset);\n\t\t\t}\n\t\t\tthis.autoCompleteBox.setExamples(examples, this.text, addSemicolon);\n\t\t\tthis.hideErrorMessage();\n\t\t\tthis.hideStepMessage();\n\t\t},\n\n\t\thideAutoCompleteBox: function() {\n\t\t\tif (this.autoCompleteBox !== null) {\n\t\t\t\tthis.autoCompleteBox.remove();\n\t\t\t\tthis.autoCompleteBox = null;\n\t\t\t}\n\t\t},\n\n\t\tautoCompleteNavigate: function(event) {\n\t\t\tif (event.keyCode === 38) { // 38 == up\n\t\t\t\tif (this.autoCompleteBox.up()) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t} else if (event.keyCode === 40) { // 40 == down\n\t\t\t\tif (this.autoCompleteBox.down()) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t} else if (event.keyCode === 13) { // 13 == enter\n\t\t\t\tif (this.autoCompleteBox.enter()) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/// INTERNAL FUNCTIONS ///\n\t\tinitOffsets: function($div) {\n\t\t\t// setting up mirror\n\t\t\tthis.$mirror = $('<div class=\"editor-mirror\"></div>');\n\t\t\tvar $mirrorContainer = $('<div class=\"editor-mirror-container\"></div>');\n\t\t\t$mirrorContainer.append(this.$mirror);\n\t\t\tthis.$div.append($mirrorContainer);\n\n\t\t\tthis.$mirror.text('a');\n\t\t\tthis.textOffset = {x: this.$mirror.outerWidth(), y: this.$mirror.outerHeight()};\n\n\t\t\t// this trick of measuring a long string especially helps Firefox get an accurate character width\n\t\t\tthis.$mirror.text('a' + new Array(100+1).join('a'));\n\t\t\tthis.charWidth = (this.$mirror.outerWidth() - this.textOffset.x)/100;\n\n\t\t\tthis.$mirror.text('a\\na');\n\t\t\tthis.lineHeight = this.$mirror.outerHeight() - this.textOffset.y;\n\t\t\t\n\t\t\t// this works assuming there is no padding on the right or bottom\n\t\t\tthis.textOffset.x -= this.charWidth;\n\t\t\tthis.textOffset.y -= this.lineHeight;\n\n\t\t\t// the offset is weird since .position().top changes when scrolling\n\t\t\tvar textAreaOffset = {\n\t\t\t\tx: (this.$textarea.position().left + this.$div.scrollLeft()),\n\t\t\t\ty: (this.$textarea.position().top + this.$div.scrollTop())\n\t\t\t};\n\n\t\t\tthis.$surface.css('left', textAreaOffset.x + this.textOffset.x);\n\t\t\tthis.$surface.css('top', textAreaOffset.y + this.textOffset.y);\n\t\t\tthis.$margin.css('top', textAreaOffset.y + this.textOffset.y);\n\t\t},\n\n\t\tupdateSize: function() {\n\t\t\tthis.$mirror.text(this.text);\n\t\t\tthis.$textarea.width(this.$mirror.outerWidth() + 130);\n\t\t\tthis.$textarea.height(Math.max(this.$mirror.outerHeight() + 100, this.$div.height()));\n\t\t\tthis.$surface.width(this.$mirror.outerWidth() + 130);\n\t\t},\n\n\t\tshowElements: function() {\n\t\t\tthis.$surface.show();\n\t\t\tthis.$margin.show();\n\t\t},\n\n\t\thideElements: function() {\n\t\t\tthis.$surface.hide();\n\t\t\tthis.$margin.hide();\n\t\t},\n\n\t\tpageXToColumn: function(x) {\n\t\t\treturn Math.floor((x-this.$textarea.offset().left-this.textOffset.x)/this.charWidth);\n\t\t},\n\n\t\tpageYToLine: function(y) {\n\t\t\treturn 1+Math.floor((y-this.$textarea.offset().top-this.textOffset.y)/this.lineHeight);\n\t\t},\n\n\t\tscrollToY: function(y) {\n\t\t\ty = Math.max(0, y - this.$div.height()/2);\n\t\t\tthis.$div.stop(true).animate({scrollTop : y}, 150);\n\t\t\t//this.$div.scrollTop(y);\n\t\t},\n\n\t\tkeyDown: function(event) {\n\t\t\tif (this.$textarea.val() !== this.text) {\n\t\t\t\t// note: this will never be called at the first keypress, only when holding it!\n\t\t\t\tthis.text = this.$textarea.val();\n\t\t\t\tthis.updateSize();\n\t\t\t\tthis.userChangedText = true;\n\t\t\t}\n\n\t\t\tif (this.delegate.tabIndent(event, this.$textarea[0].selectionStart, this.$textarea[0].selectionEnd)) {\n\t\t\t\tthis.userChangedText = true;\n\t\t\t}\n\n\t\t\tif (this.autoCompleteBox !== null) {\n\t\t\t\tthis.autoCompleteNavigate(event);\n\t\t\t}\n\n\t\t\t//this.delegate.autoComplete(event, this.$textarea[0].selectionStart);\n\n\t\t\tif (this.userChangedText) {\n\t\t\t\tthis.hideElements();\n\t\t\t}\n\t\t\t// TODO: include offset vars and update UI elements\n\t\t},\n\n\t\tkeyUp: function(event) {\n\t\t\tif (this.$textarea.val() !== this.text) {\n\t\t\t\tthis.text = this.$textarea.val();\n\t\t\t\tthis.delegate.autoIndent(event, this.$textarea[0].selectionStart);\n\t\t\t\tthis.updateSize();\n\t\t\t\tthis.userChangedText = true;\n\t\t\t}\n\n\t\t\t// 38 == up, 40 == down, 13 == enter, 16 == shift\n\t\t\tif ([38, 40, 13, 16].indexOf(event.keyCode) < 0) {\n\t\t\t\tthis.delegate.autoComplete(event, this.$textarea[0].selectionStart);\n\t\t\t}\n\n\t\t\tif (this.userChangedText) {\n\t\t\t\tthis.userChangedText = false;\n\t\t\t\tthis.showElements();\n\t\t\t\tif (this.autoCompleteBox === null) {\n\t\t\t\t\tthis.delegate.userChangedText();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tclick: function() {\n\t\t\tthis.delegate.disableAutoCompletion();\n\t\t},\n\n\t\tmouseMove: function(event) {\n\t\t\tthis.delegate.mouseMove(event, this.pageYToLine(event.pageY), this.pageXToColumn(event.pageX));\n\t\t},\n\n\t\tmouseLeave: function(event) {\n\t\t\tthis.delegate.mouseLeave(event);\n\t\t}\n\t};\n};\n\n//@ sourceURL=/editor/editor.surface.js"
));

require.define("/editor/editor.editor.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/*jshint node:true jquery:true*/\n\"use strict\";\n\nvar clayer = require('../clayer');\n\n\nmodule.exports = function(editor) {\n\teditor.Editor = function() { return this.init.apply(this, arguments); };\n\n\teditor.Editor.prototype = {\n\t\tinit: function(language, $div, delegate, text) {\n\t\t\tthis.language = language;\n\t\t\tthis.surface = new editor.Surface($div, this);\n\t\t\tthis.delegate = delegate;\n\t\t\tthis.outputs = [];\n\t\t\tthis.runner = new language.StaticRunner();\n\n\t\t\tthis.editables = [];\n\t\t\tthis.editablesByLine = [];\n\t\t\tthis.editablesEnabled = false;\n\n\t\t\tthis.highlightingEnabled = false;\n\t\t\tthis.highlightLine = 0;\n\t\t\tthis.currentHighlightNode = null;\n\n\t\t\tthis.autoCompletionEnabled = false;\n\n\t\t\tthis.updateTimeout = null;\n\t\t\tthis.runTimeout = null;\n\n\t\t\tthis.setText(text || '');\n\t\t},\n\n\t\tgetText: function() {\n\t\t\treturn this.code.text;\n\t\t},\n\n\t\tsetText: function(text) {\n\t\t\tthis.surface.setText(text);\n\t\t\tthis.surface.resetCursor();\n\t\t\tthis.update();\n\t\t},\n\n\t\tsetScope: function(scope) {\n\t\t\tthis.runner.newScope(scope);\n\t\t\tthis.update();\n\t\t},\n\n\t\taddOutput: function(output) {\n\t\t\tthis.outputs.push(output);\n\t\t\tthis.update();\n\t\t},\n\n\t\tcallOutputs: function(funcName) {\n\t\t\tfor (var i=0; i<this.outputs.length; i++) {\n\t\t\t\tthis.outputs[i][funcName]();\n\t\t\t}\n\t\t},\n\n\t\tdelayedUpdate: function() {\n\t\t\tthis.code = new editor.Code(this.surface.getText());\n\t\t\tif (this.updateTimeout === null) {\n\t\t\t\tthis.updateTimeout = setTimeout($.proxy(this.update, this), 5);\n\t\t\t}\n\t\t},\n\n\t\tupdate: function() {\n\t\t\tthis.updateTimeout = null;\n\t\t\tthis.code = new editor.Code(this.surface.getText());\n\t\t\tthis.tree = new this.language.Tree(this.code.text);\n\t\t\tif (this.tree.hasError()) {\n\t\t\t\tif (this.editablesEnabled) {\n\t\t\t\t\tthis.disableEditables();\n\t\t\t\t}\n\t\t\t\tif (this.highlightingEnabled) {\n\t\t\t\t\tthis.disableHighlighting();\n\t\t\t\t}\n\t\t\t\tthis.handleError(this.tree.getError());\n\t\t\t\tthis.delegate.criticalError();\n\t\t\t} else {\n\t\t\t\tif (this.highlightingEnabled) {\n\t\t\t\t\tthis.refreshHighlights();\n\t\t\t\t}\n\t\t\t\tthis.run();\n\t\t\t}\n\t\t\tthis.delegate.textChanged(this.code);\n\t\t},\n\n\t\tdelayedRun: function() {\n\t\t\tif (this.runTimeout === null) {\n\t\t\t\tthis.runTimeout = setTimeout($.proxy(this.run, this), 5);\n\t\t\t}\n\t\t},\n\n\t\trun: function() {\n\t\t\tthis.runTimeout = null;\n\t\t\tthis.callOutputs('startRun');\n\t\t\tthis.runner.newTree(this.tree);\n\t\t\tthis.runner.run();\n\t\t\t//this.callOutputs('endRun');\n\t\t\tthis.handleRunnerOutput();\n\t\t},\n\n\t\trestart: function() {\n\t\t\tif (!this.tree.hasError() && !this.autoCompletionEnabled) {\n\t\t\t\tthis.runner.restart();\n\t\t\t\tthis.run();\n\t\t\t}\n\t\t},\n\n\t\tstepForward: function() {\n\t\t\tif (!this.tree.hasError() && !this.autoCompletionEnabled) {\n\t\t\t\tif (!this.runner.isStepping()) {\n\t\t\t\t\tthis.surface.openStepMessage();\n\t\t\t\t}\n\t\t\t\tthis.callOutputs('startRun');\n\t\t\t\tthis.runner.stepForward();\n\t\t\t\t//this.callOutputs('endRun');\n\t\t\t\tthis.handleRunnerOutput();\n\t\t\t}\n\t\t},\n\n\t\tstepBackward: function() {\n\t\t\tif (!this.tree.hasError() && !this.autoCompletionEnabled) {\n\t\t\t\tthis.callOutputs('startRun');\n\t\t\t\tthis.runner.stepBackward();\n\t\t\t\t//this.callOutputs('endRun');\n\t\t\t\tthis.handleRunnerOutput();\n\t\t\t}\n\t\t},\n\n\t\thandleRunnerOutput: function() {\n\t\t\tthis.surface.hideAutoCompleteBox();\n\t\t\tif (this.runner.hasError()) {\n\t\t\t\tthis.handleError(this.runner.getError());\n\t\t\t\tif (this.runner.isStepping()) {\n\t\t\t\t\tthis.delegate.steppingWithError();\n\t\t\t\t} else {\n\t\t\t\t\tthis.delegate.runningWithError();\n\t\t\t\t}\n\t\t\t\tthis.callOutputs('endRun');\n\t\t\t} else {\n\t\t\t\tthis.handleMessages(this.runner.getMessages());\n\t\t\t\tif (this.runner.isStepping()) {\n\t\t\t\t\tthis.delegate.steppingWithoutError();\n\t\t\t\t\tthis.callOutputs('endRunStepping');\n\t\t\t\t} else {\n\t\t\t\t\tthis.delegate.runningWithoutError();\n\t\t\t\t\tthis.callOutputs('endRun');\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\thandleError: function(error) {\n\t\t\tthis.surface.hideStepMessage();\n\t\t\tthis.surface.hideAutoCompleteBox();\n\t\t\tthis.surface.showErrorMessage(error);\n\t\t\tthis.callOutputs('hasError');\n\t\t},\n\n\t\thandleMessages: function(messages) {\n\t\t\tthis.surface.hideErrorMessage();\n\t\t\tif (messages.length <= 0) {\n\t\t\t\tthis.surface.hideStepMessage();\n\t\t\t} else {\n\t\t\t\tfor (var i=0; i<messages.length; i++) {\n\t\t\t\t\tif (messages[i].type === 'Inline') {\n\t\t\t\t\t\tthis.surface.showStepMessage(messages[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tuserChangedText: function() { // callback\n\t\t\tthis.update(); // refreshEditables uses this.tree\n\t\t\tif (this.editablesEnabled) {\n\t\t\t\tthis.refreshEditables();\n\t\t\t}\n\t\t\t//window.localStorage.setItem('1', this.code.text);\n\t\t},\n\n\t\toutputRequestsRerun: function() { //callback\n\t\t\tif (!this.tree.hasError()) {\n\t\t\t\tthis.delayedRun();\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\t\t/// EDITABLES METHODS AND CALLBACKS ///\n\t\tenableEditables: function() {\n\t\t\tif (!this.tree.hasError() && !this.autoCompletionEnabled) {\n\t\t\t\tthis.editablesEnabled = true;\n\t\t\t\tthis.delegate.editablesEnabled();\n\t\t\t\tthis.refreshEditables();\n\t\t\t}\n\t\t},\n\n\t\tdisableEditables: function() {\n\t\t\tthis.removeEditables();\n\t\t\tthis.editablesEnabled = false;\n\t\t\tthis.delegate.editablesDisabled();\n\t\t},\n\n\t\trefreshEditables: function() {\n\t\t\tif (this.editablesEnabled) {\n\t\t\t\tthis.removeEditables();\n\t\t\t\tthis.editables = this.language.editor.editables.generate(this.tree, editor.editables, this.surface, this);\n\t\t\t\tfor (var i=0; i<this.editables.length; i++) {\n\t\t\t\t\tvar line = this.editables[i].line;\n\t\t\t\t\tif (this.editablesByLine[line] === undefined) {\n\t\t\t\t\t\tthis.editablesByLine[line] = [];\n\t\t\t\t\t}\n\t\t\t\t\tthis.editablesByLine[line].push(this.editables[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tremoveEditables: function() {\n\t\t\tif (this.editablesEnabled) {\n\t\t\t\tfor (var i=0; i<this.editables.length; i++) {\n\t\t\t\t\tthis.editables[i].remove();\n\t\t\t\t}\n\t\t\t\tthis.editables = [];\n\t\t\t\tthis.editablesByLine = [];\n\t\t\t}\n\t\t},\n\n\t\tgetEditablesText: function(node) { //callback\n\t\t\treturn this.code.rangeToText(node.textLoc);\n\t\t},\n\n\t\teditableReplaceCode: function(line, column, column2, newText) { // callback\n\t\t\tif (this.editablesByLine[line] === undefined) return;\n\n\t\t\tvar offset1 = this.code.lineColumnToOffset(line, column), offset2 = this.code.lineColumnToOffset(line, column2);\n\t\t\tthis.surface.setText(this.code.replaceOffsetRange(offset1, offset2, newText));\n\n\t\t\tvar changeOffset = newText.length - (column2-column);\n\t\t\tif (changeOffset !== 0) {\n\t\t\t\tfor (var i=0; i<this.editablesByLine[line].length; i++) {\n\t\t\t\t\tthis.editablesByLine[line][i].offsetColumn(column, changeOffset);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.delayedUpdate();\n\t\t\tthis.surface.restoreCursor(offset2, changeOffset);\n\t\t},\n\n\t\t/// HIGHLIGHTING METHODS AND CALLBACKS ///\n\t\tenableHighlighting: function() {\n\t\t\tif (!this.tree.hasError() && !this.autoCompletionEnabled) {\n\t\t\t\tthis.surface.enableMouse();\n\t\t\t\tthis.surface.enableHighlighting();\n\t\t\t\tthis.highlightingEnabled = true;\n\t\t\t\tthis.delegate.highlightingEnabled();\n\t\t\t\tthis.callOutputs('enableHighlighting');\n\t\t\t}\n\t\t},\n\n\t\tdisableHighlighting: function() {\n\t\t\tthis.tree.clearHooks();\n\t\t\tthis.highlightLine = 0;\n\t\t\tthis.currentHighlightNode = null;\n\t\t\tthis.surface.disableMouse();\n\t\t\tthis.surface.disableHighlighting();\n\t\t\tthis.highlightingEnabled = false;\n\t\t\tthis.delegate.highLightingDisabled();\n\t\t\tthis.callOutputs('disableHighlighting');\n\t\t},\n\n\t\thighlightNode: function(node) { // callback\n\t\t\tif (node !== null) {\n\t\t\t\tthis.surface.showHighlight(node.lineLoc.line, node.lineLoc.column, node.lineLoc.line+1, node.lineLoc.column2);\n\t\t\t\tthis.surface.scrollToLine(node.lineLoc.line);\n\t\t\t} else {\n\t\t\t\tthis.surface.hideHighlight();\n\t\t\t}\n\t\t},\n\n\t\t// internal method; return whether or not a rerun is required\n\t\trefreshHighlights: function() {\n\t\t\tvar node = this.tree.getNodeByLine(this.highlightLine);\n\n\t\t\tif (node !== this.currentHighlightNode) {\n\t\t\t\tthis.currentHighlightNode = node;\n\t\t\t\tthis.tree.clearHooks();\n\t\t\t\tif (node !== null) {\n\t\t\t\t\tthis.tree.addHookBeforeNode(node, $.proxy(this.startHighlighting, this));\n\t\t\t\t\tthis.tree.addHookAfterNode(node, $.proxy(this.stopHighlighting, this));\n\t\t\t\t\tvar line1 = node.blockLoc.line, line2 = node.blockLoc.line2;\n\t\t\t\t\tthis.surface.showHighlight(line1, this.code.blockToLeftColumn(line1, line2), line2+1, this.code.blockToRightColumn(line1, line2));\n\t\t\t\t} else {\n\t\t\t\t\tthis.surface.hideHighlight();\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\t\tmouseMove: function(event, line, column) { // callback\n\t\t\tif (this.highlightingEnabled) {\n\t\t\t\tthis.highlightLine = line;\n\t\t\t\tif (this.refreshHighlights()) {\n\t\t\t\t\tthis.delayedRun();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tmouseLeave: function(event) { //callback\n\t\t\tif (this.highlightingEnabled) {\n\t\t\t\tthis.highlightLine = 0;\n\t\t\t\tif (this.refreshHighlights()) {\n\t\t\t\t\tthis.delayedRun();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tstartHighlighting: function(node, scope) { // callback\n\t\t\tthis.callOutputs('startHighlighting');\n\t\t},\n\n\t\tstopHighlighting: function(node, scope) { // callback\n\t\t\tthis.callOutputs('stopHighlighting');\n\t\t},\n\n\t\t/// KEYBOARD CALLBACKS ///\n\t\ttabIndent: function(event, offset1, offset2) { // callback\n\t\t\t// 9 == tab key\n\t\t\tif (event.keyCode === 9) {\n\t\t\t\tvar code = new editor.Code(this.surface.getText());\n\t\t\t\tvar pos1 = code.offsetToLoc(offset1);\n\t\t\t\tvar pos2 = pos1;\n\t\t\t\tif (offset2 !== offset1) {\n\t\t\t\t\tpos2 = code.offsetToLoc(offset2);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar newText = code.text.substring(0, code.lineColumnToOffset(pos1.line, 0));\n\t\t\t\tvar totalOffset1 = 0, totalOffset2 = 0;\n\n\t\t\t\tfor (var i=pos1.line; i<=pos2.line; i++) {\n\t\t\t\t\tvar startOffset = code.lineColumnToOffset(i, 0);\n\t\t\t\t\tvar line = code.getLine(i);\n\t\t\t\t\tif (!event.shiftKey) {\n\t\t\t\t\t\t// insert spaces\n\t\t\t\t\t\tnewText += '  ' + line + '\\n';\n\t\t\t\t\t\tif (i === pos1.line) totalOffset1 += 2;\n\t\t\t\t\t\ttotalOffset2 += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// remove spaces\n\t\t\t\t\t\tvar spaces = Math.min(code.getLine(i).match(/^ */)[0].length, 2);\n\t\t\t\t\t\tnewText += line.substring(spaces) + '\\n';\n\t\t\t\t\t\tif (i === pos1.line) totalOffset1 -= spaces;\n\t\t\t\t\t\ttotalOffset2 -= spaces;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar finalOffset = code.lineColumnToOffset(pos2.line+1, 0);\n\t\t\t\tif (finalOffset !== null) newText += code.text.substring(finalOffset);\n\n\t\t\t\tthis.surface.setText(newText);\n\t\t\t\tthis.surface.restoreCursorRange(totalOffset1, totalOffset2);\n\t\t\t\t\n\t\t\t\tevent.preventDefault();\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\t\t// TODO: use http://archive.plugins.jquery.com/project/fieldselection\n\t\tautoIndent: function(event, offset) { // callback\n\t\t\t// 13 == enter, 221 = } or ]\n\t\t\tif ([13, 221].indexOf(event.keyCode) >= 0) {\n\t\t\t\tvar code = new editor.Code(this.surface.getText());\n\n\t\t\t\tvar pos = code.offsetToLoc(offset);\n\t\t\t\tif (pos.line > 1) {\n\t\t\t\t\tvar prevLine = code.getLine(pos.line-1);\n\t\t\t\t\tvar curLine = code.getLine(pos.line);\n\n\t\t\t\t\t// how many spaces are there on the previous line (reference), and this line\n\t\t\t\t\tvar spaces = prevLine.match(/^ */)[0].length;\n\t\t\t\t\tvar spacesAlready = curLine.match(/^ */)[0].length;\n\n\t\t\t\t\t// \"{\" on previous line means extra spaces, \"}\" on this one means less\n\t\t\t\t\tspaces += prevLine.match(/\\{ *$/) !== null ? 2 : 0;\n\t\t\t\t\tspaces -= curLine.match(/^ *\\}/) !== null ? 2 : 0;\n\n\t\t\t\t\t// also, since we are returning an offset, remove the number of spaces we have already\n\t\t\t\t\tspaces -= spacesAlready;\n\n\t\t\t\t\tvar startOffset = code.lineColumnToOffset(pos.line, 0);\n\t\t\t\t\tif (spaces < 0) {\n\t\t\t\t\t\t// don't delete more spaces that there are on this line\n\t\t\t\t\t\tspaces = Math.max(spaces, -spacesAlready);\n\t\t\t\t\t\tthis.surface.setText(code.removeOffsetRange(startOffset, startOffset-spaces));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.surface.setText(code.insertAtOffset(startOffset, new Array(spaces+1).join(' ')));\n\t\t\t\t\t}\n\t\t\t\t\tthis.surface.restoreCursor(startOffset, spaces);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tautoComplete: function(event, offset) { // callback\n\t\t\t// 190 == ., 48-90 == alpha-num, 8 == backspace\n\t\t\tif (event.keyCode === 190 || (event.keyCode >= 48 && event.keyCode <= 90) || event.keyCode === 8) {\n\t\t\t\tthis.code = new editor.Code(this.surface.getText());\n\t\t\t\tvar pos = this.code.offsetToLoc(offset);\n\t\t\t\tif (pos.line > 0) {\n\t\t\t\t\tvar line = this.code.getLine(pos.line);\n\t\t\t\t\tvar match = /([A-Za-z][A-Za-z0-9]*[.])+([A-Za-z][A-Za-z0-9]*)?$/.exec(line.substring(0, pos.column));\n\t\t\t\t\tif (match !== null) {\n\t\t\t\t\t\tvar examples = this.runner.getExamples(match[0]);\n\t\t\t\t\t\tif (examples !== null) {\n\t\t\t\t\t\t\tvar addSemicolon = line.substring(pos.column).replace(' ', '').length <= 0;\n\t\t\t\t\t\t\tthis.surface.showAutoCompleteBox(pos.line, pos.column-examples.width, offset-examples.width, examples, addSemicolon);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.disableAutoCompletion();\n\t\t},\n\n\t\tpreviewExample: function(offset1, offset2, example) { // callback\n\t\t\tthis.autoCompletionEnabled = true;\n\t\t\tif (this.editablesEnabled) {\n\t\t\t\tthis.disableEditables();\n\t\t\t}\n\t\t\tif (this.highlightingEnabled) {\n\t\t\t\tthis.disableHighlighting();\n\t\t\t}\n\n\t\t\tvar text = this.surface.getText();\n\t\t\tthis.tree = new this.language.Tree(text.substring(0, offset1) + example + text.substring(offset2));\n\t\t\tif (!this.tree.hasError()) {\n\t\t\t\tthis.runner.restart();\n\t\t\t\tthis.callOutputs('startRun');\n\t\t\t\tthis.runner.newTree(this.tree);\n\t\t\t\tthis.runner.run();\n\t\t\t\tthis.callOutputs('endRun');\n\t\t\t}\n\t\t\t\n\t\t\tthis.delegate.previewing();\n\t\t},\n\n\t\tinsertExample: function(offset1, offset2, example) { // callback\n\t\t\tif (this.autoCompletionEnabled) {\n\t\t\t\tvar text = this.surface.getText();\n\t\t\t\tthis.surface.setText(text.substring(0, offset1) + example + text.substring(offset2));\n\t\t\t\tthis.surface.setCursor(offset1 + example.length, offset1 + example.length);\n\t\t\t\tthis.disableAutoCompletion();\n\t\t\t}\n\t\t},\n\n\t\tdisableAutoCompletion: function() {\n\t\t\tif (this.autoCompletionEnabled) {\n\t\t\t\tthis.autoCompletionEnabled = false;\n\t\t\t\tthis.delayedUpdate();\n\t\t\t}\n\t\t}\n\t};\n};\n\n//@ sourceURL=/editor/editor.editor.js"
));

require.define("/output/index.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/*jshint node:true*/\n\"use strict\";\n\nvar output = {};\n\nrequire('./output.console')(output);\nrequire('./output.canvas')(output);\nrequire('./output.robot')(output);\n\nmodule.exports = output;\n//@ sourceURL=/output/index.js"
));

require.define("/output/output.console.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/*jshint node:true jquery:true*/\n\"use strict\";\n\nmodule.exports = function(output) {\n\toutput.Console = function() { return this.init.apply(this, arguments); };\n\n\toutput.Console.prototype = {\n\t\tinit: function($div, editor) {\n\t\t\tthis.$div = $div;\n\t\t\tthis.$div.addClass('console');\n\t\t\tthis.$div.on('scroll', $.proxy(this.refreshAutoScroll, this));\n\n\t\t\tthis.$content = $('<div class=\"console-content\"></div>');\n\t\t\tthis.$div.append(this.$content);\n\n\t\t\t//this.debugToBrowser = true;\n\t\t\tthis.highlighting = false;\n\t\t\tthis.highlightNextLines = false;\n\t\t\tthis.autoScroll = false;\n\t\t\tthis.editor = editor;\n\t\t\tthis.editor.addOutput(this);\n\n\t\t\tthis.refreshAutoScroll();\n\t\t\tthis.clear();\n\t\t},\n\n\t\tgetAugmentedObject: function() {\n\t\t\treturn {\n\t\t\t\tlog: {\n\t\t\t\t\tname: 'log',\n\t\t\t\t\taugmented: 'function',\n\t\t\t\t\texample: 'log(\"Hello World!\")',\n\t\t\t\t\tfunc: $.proxy(this.log, this)\n\t\t\t\t},\n\t\t\t\tclear: {\n\t\t\t\t\tname: 'clear',\n\t\t\t\t\taugmented: 'function',\n\t\t\t\t\texample: 'clear()',\n\t\t\t\t\tfunc: $.proxy(this.clear, this)\n\t\t\t\t},\n\t\t\t\tsetColor: {\n\t\t\t\t\tname: 'setColor',\n\t\t\t\t\taugmented: 'function',\n\t\t\t\t\texample: 'setColor(\"#a00\")',\n\t\t\t\t\tfunc: $.proxy(this.setColor, this)\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\n\t\tlog: function(node, name, args) {\n\t\t\tvar value = args[0];\n\t\t\tvar text = '' + value;\n\t\t\tif (typeof value === 'object') text = '[object]';\n\t\t\telse if (typeof value === 'function') text = '[function]';\n\n\t\t\tvar $element = $('<div class=\"console-line\"></div>');\n\t\t\tif (this.highlightNextLines) {\n\t\t\t\t$element.addClass('console-highlight-line');\n\t\t\t}\n\t\t\t$element.text(text);\n\t\t\t$element.data('node', node);\n\t\t\tthis.$content.append($element);\n\n\t\t\tif (this.color !== '') $element.css('color', this.color);\n\n\t\t\tif (this.debugToBrowser && console && console.log) console.log(value);\n\t\t},\n\n\t\tsetColor: function(node, name, args) {\n\t\t\tvar color = args[0];\n\t\t\tthis.color = color;\n\t\t},\n\n\t\tstartHighlighting: function() {\n\t\t\tthis.highlightNextLines = true;\n\t\t},\n\n\t\tstopHighlighting: function() {\n\t\t\tthis.highlightNextLines = false;\n\t\t},\n\n\t\tenableHighlighting: function() {\n\t\t\tthis.highlighting = true;\n\t\t\tthis.$div.addClass('console-highlighting');\n\t\t\tthis.$div.on('mousemove', $.proxy(this.mouseMove, this));\n\t\t\tthis.$div.on('mouseleave', $.proxy(this.mouseLeave, this));\n\t\t\tthis.autoScroll = false;\n\t\t\tthis.$div.removeClass('console-autoscroll');\n\t\t},\n\n\t\tdisableHighlighting: function() {\n\t\t\tthis.highlighting = false;\n\t\t\tthis.$content.children('.console-highlight-line').removeClass('console-highlight-line');\n\t\t\tthis.$div.removeClass('console-highlighting');\n\t\t\tthis.$div.off('mousemove mouseleave');\n\t\t\tthis.refreshAutoScroll();\n\t\t},\n\n\t\tstartRun: function() {\n\t\t\tthis.stopHighlighting();\n\t\t\tthis.clear();\n\t\t\tthis.$content.removeClass('console-error');\n\t\t},\n\n\t\tendRun: function() {\n\t\t\tif (this.highlighting) {\n\t\t\t\tvar $last = this.$content.children('.console-highlight-line').last();\n\t\t\t\tif ($last.length > 0) {\n\t\t\t\t\t// the offset is weird since .position().top changes when scrolling\n\t\t\t\t\tthis.scrollToY($last.position().top + this.$div.scrollTop());\n\t\t\t\t}\n\t\t\t} else if (this.autoScroll) {\n\t\t\t\tthis.scrollToY(this.$content.height());\n\t\t\t}\n\t\t},\n\n\t\tendRunStepping: function() {\n\t\t\tthis.endRun();\n\t\t},\n\n\t\thasError: function() {\n\t\t\tthis.$content.addClass('console-error');\n\t\t},\n\n\t\tclear: function() {\n\t\t\tthis.color = '';\n\t\t\tthis.$content.children('.console-line').remove(); // like this to prevent $.data memory leaks\n\t\t\tif (this.debugToBrowser && console && console.clear) console.clear();\n\t\t},\n\n\t\t/// INTERNAL FUNCTIONS ///\n\t\tscrollToY: function(y) {\n\t\t\ty = Math.max(0, y - this.$div.height()/2);\n\t\t\tthis.$div.stop(true).animate({scrollTop : y}, 150);\n\t\t},\n\n\t\tmouseMove: function(event) {\n\t\t\tif (this.highlighting) {\n\t\t\t\tvar $target = $(event.target);\n\t\t\t\tthis.$content.children('.console-highlight-line').removeClass('console-highlight-line');\n\t\t\t\tif ($target.data('node') !== undefined && !$target.hasClass('console-highlight-line')) {\n\t\t\t\t\t$target.addClass('console-highlight-line');\n\t\t\t\t\tthis.editor.highlightNode($target.data('node'));\n\t\t\t\t} else {\n\t\t\t\t\tthis.editor.highlightNode(null);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tmouseLeave: function(event) {\n\t\t\tif (this.highlighting) {\n\t\t\t\tthis.$content.children('.console-highlight-line').removeClass('console-highlight-line');\n\t\t\t\tthis.editor.highlightNode(null);\n\t\t\t}\n\t\t},\n\n\t\trefreshAutoScroll: function() {\n\t\t\tif (!this.highlighting) {\n\t\t\t\tif (this.$div.scrollTop() >= this.$content.outerHeight(true)-this.$div.height()-4) {\n\t\t\t\t\tthis.$div.addClass('console-autoscroll');\n\t\t\t\t\tthis.autoScroll = true;\n\t\t\t\t} else {\n\t\t\t\t\tthis.$div.removeClass('console-autoscroll');\n\t\t\t\t\tthis.autoScroll = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n};\n\n//@ sourceURL=/output/output.console.js"
));

require.define("/output/output.canvas.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/*jshint node:true jquery:true*/\n\"use strict\";\n\nmodule.exports = function(output) {\n\toutput.Canvas = function() { return this.init.apply(this, arguments); };\n\n\toutput.Canvas.prototype = {\n\t\tinit: function($div, editor) {\n\t\t\tthis.$div = $div;\n\t\t\tthis.$div.addClass('canvas');\n\n\t\t\tthis.$canvas = $('<canvas class=\"canvas-canvas\"></canvas>');\n\t\t\tthis.$div.append(this.$canvas);\n\t\t\tthis.size = this.$canvas.css('max-width').replace('px', '');\n\t\t\tthis.$canvas.attr('width', this.size);\n\t\t\tthis.$canvas.attr('height', this.size);\n\t\t\tthis.context = this.$canvas[0].getContext('2d');\n\t\t\tthis.context.save();\n\n\t\t\tvar $mirror = $('<canvas class=\"canvas-mirror\"></canvas>');\n\t\t\tthis.$div.append($mirror);\n\t\t\t$mirror.attr('width', this.size);\n\t\t\t$mirror.attr('height', this.size);\n\t\t\tthis.mirrorContext = $mirror[0].getContext('2d');\n\t\t\tthis.mirrorContext.save();\n\n\t\t\t//this.debugToBrowser = true;\n\t\t\tthis.highlighting = false;\n\t\t\tthis.highlightNextShapes = false;\n\t\t\tthis.highlightCallTarget = 0;\n\t\t\tthis.editor = editor;\n\t\t\tthis.editor.addOutput(this);\n\n\t\t\tthis.clear();\n\t\t},\n\n\t\tfunctions: {\n\t\t\tclearRect: {type: 'method', argsMin: 4, argsMax: 4, example: 'clearRect(100, 100, 100, 100)', draws: true, mirror: true},\n\t\t\tfillRect: {type: 'method', argsMin: 4, argsMax: 4, example: 'fillRect(100, 100, 100, 100)', draws: true, mirror: true},\n\t\t\tstrokeRect: {type: 'method', argsMin: 4, argsMax: 4, example: 'strokeRect(100, 100, 100, 100)', draws: true, mirror: true},\n\t\t\tbeginPath: {type: 'method', argsMin: 0, argsMax: 0, example: 'beginPath()', draws: false, mirror: true},\n\t\t\tclosePath: {type: 'method', argsMin: 0, argsMax: 0, example: 'closePath()', draws: false, mirror: true},\n\t\t\tfill: {type: 'method', argsMin: 0, argsMax: 0, example: 'fill()', draws: true, mirror: true},\n\t\t\tstroke: {type: 'method', argsMin: 0, argsMax: 0, example: 'stroke()', draws: true, mirror: true},\n\t\t\tclip: {type: 'method', argsMin: 0, argsMax: 0, example: 'clip()', draws: false, mirror: true},\n\t\t\tmoveTo: {type: 'method', argsMin: 2, argsMax: 2, example: 'moveTo(100, 100)', draws: false, mirror: true},\n\t\t\tlineTo: {type: 'method', argsMin: 2, argsMax: 2, example: 'lineTo(100, 100)', draws: false, mirror: true},\n\t\t\tquadraticCurveTo: {type: 'method', argsMin: 4, argsMax: 4, example: 'quadraticCurveTo(30, 80, 100, 100)', draws: false, mirror: true},\n\t\t\tbezierCurveTo: {type: 'method', argsMin: 6, argsMax: 6, example: 'bezierCurveTo(30, 80, 60, 40, 100, 100)', draws: false, mirror: true},\n\t\t\tarcTo: {type: 'method', argsMin: 5, argsMax: 5, example: 'arcTo(20, 20, 100, 100, 60)', draws: false, mirror: true},\n\t\t\tarc: {type: 'method', argsMin: 5, argsMax: 6, example: 'arc(100, 100, 30, 0, 360)', draws: false, mirror: true},\n\t\t\trect: {type: 'method', argsMin: 4, argsMax: 4, example: 'rect(100, 100, 100, 100)', draws: false, mirror: true},\n\t\t\tscale: {type: 'method', argsMin: 2, argsMax: 2, example: 'scale(2.0, 3.0)', draws: true, mirror: true},\n\t\t\trotate: {type: 'method', argsMin: 1, argsMax: 1, example: 'rotate(0.40)', draws: true, mirror: true},\n\t\t\ttranslate: {type: 'method', argsMin: 2, argsMax: 2, example: 'translate(10, 30)', draws: true, mirror: true},\n\t\t\ttransform: {type: 'method', argsMin: 6, argsMax: 6, example: 'transform(0.8, 0.3, 0.5, 1.0, 10, 30)', draws: true, mirror: true},\n\t\t\tfillText: {type: 'method', argsMin: 3, argsMax: 4, example: 'fillText(\"Hello World!\", 100, 100)', draws: true, mirror: true},\n\t\t\tstrokeText: {type: 'method', argsMin: 3, argsMax: 4, example: 'strokeText(\"Hello World!\", 100, 100)', draws: true, mirror: true},\n\t\t\tisPointInPath: {type: 'method', argsMin: 2, argsMax: 2, example: 'isPointInPath(150, 150)', draws: false, mirror: true},\n\t\t\tfillStyle: {type: 'attribute', example: 'fillStyle = \"#a00\"', draws: false, mirror: false},\n\t\t\tstrokeStyle: {type: 'attribute', example: 'strokeStyle = \"#a00\"', draws: false, mirror: false},\n\t\t\tshadowOffsetX: {type: 'attribute', example: 'shadowOffsetX = 10', draws: false, mirror: true},\n\t\t\tshadowOffsetY: {type: 'attribute', example: 'shadowOffsetY = 10', draws: false, mirror: true},\n\t\t\tshadowBlur: {type: 'attribute', example: 'shadowBlur = 5', draws: false, mirror: false},\n\t\t\tshadowColor: {type: 'attribute', example: 'shadowColor = \"#3a3\"', draws: false, mirror: false},\n\t\t\tglobalAlpha: {type: 'attribute', example: 'globalAlpha = 0.5', draws: false, mirror: false},\n\t\t\tlineWidth: {type: 'attribute', example: 'lineWidth = 3', draws: false, mirror: false},\n\t\t\tlineCap: {type: 'attribute', example: 'lineCap = \"round\"', draws: false, mirror: true},\n\t\t\tlineJoin: {type: 'attribute', example: 'lineJoin = \"bevel\"', draws: false, mirror: true},\n\t\t\tmiterLimit: {type: 'attribute', example: 'miterLimit = 3', draws: false, mirror: true},\n\t\t\tfont: {type: 'attribute', example: 'font = \"40pt Calibri\"', draws: false, mirror: true},\n\t\t\ttextAlign: {type: 'attribute', example: 'textAlign = \"center\"', draws: false, mirror: true},\n\t\t\ttextBaseline: {type: 'attribute', example: 'textBaseline = \"top\"', draws: false, mirror: true}\n\t\t},\n\n\t\tgetAugmentedObject: function() {\n\t\t\treturn {\n\t\t\t\twidth: {\n\t\t\t\t\tname: 'width',\n\t\t\t\t\taugmented: 'variable',\n\t\t\t\t\texample: 'width',\n\t\t\t\t\tget: $.proxy(function() {\n\t\t\t\t\t\treturn this.size;\n\t\t\t\t\t}, this),\n\t\t\t\t\tset: function() {\n\t\t\t\t\t\tthrow function(f) { return f('width') + ' cannot be set'; };\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\theight: {\n\t\t\t\t\tname: 'height',\n\t\t\t\t\taugmented: 'variable',\n\t\t\t\t\texample: 'height',\n\t\t\t\t\tget: $.proxy(function() {\n\t\t\t\t\t\treturn this.size;\n\t\t\t\t\t}, this),\n\t\t\t\t\tset: function() {\n\t\t\t\t\t\tthrow function(f) { return f('height') + ' cannot be set'; };\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tgetContext: {\n\t\t\t\t\tname: 'getContext',\n\t\t\t\t\taugmented: 'function',\n\t\t\t\t\texample: 'getContext(\"2d\")',\n\t\t\t\t\tfunc: $.proxy(function(node, name, args) {\n\t\t\t\t\t\tif (args.length !== 1) {\n\t\t\t\t\t\t\tthrow function(f) { return f('getContext') + ' takes exactly ' + f('1') + ' argument'; };\n\t\t\t\t\t\t} else if (args[0] !== '2d') {\n\t\t\t\t\t\t\tthrow function(f) { return 'Only the ' + f('2d') + ' context is supported'; };\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this.getContextObject();\n\t\t\t\t\t}, this)\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\n\t\tgetContextObject: function() {\n\t\t\tvar obj = {};\n\t\t\tfor (var name in this.functions) {\n\t\t\t\tvar func = this.functions[name];\n\t\t\t\tif (func.type === 'method') {\n\t\t\t\t\tobj[name] = {\n\t\t\t\t\t\tname: name,\n\t\t\t\t\t\taugmented: 'function',\n\t\t\t\t\t\tfunc: $.proxy(this.handleMethod, this),\n\t\t\t\t\t\texample: func.example\n\t\t\t\t\t};\n\t\t\t\t} else if (func.type === 'attribute') {\n\t\t\t\t\tobj[name] = {\n\t\t\t\t\t\tname: name,\n\t\t\t\t\t\taugmented: 'variable',\n\t\t\t\t\t\tget: $.proxy(this.handleAttributeGet, this),\n\t\t\t\t\t\tset: $.proxy(this.handleAttributeSet, this),\n\t\t\t\t\t\texample: func.example\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.getContextObject = function() { return obj; };\n\t\t\treturn obj;\n\t\t},\n\n\t\thandleMethod: function(node, name, args) {\n\t\t\tvar min = this.functions[name].argsMin, max = this.functions[name].argsMax;\n\t\t\tif (args.length < min) {\n\t\t\t\tthrow function(f) { return f(name) + ' requires at least ' + f('' + min) + ' arguments'; };\n\t\t\t} else if (args.length > max) {\n\t\t\t\tthrow function(f) { return f(name) + ' accepts no more than ' + f('' + max) + ' arguments'; };\n\t\t\t}\n\t\t\tif (this.highlighting) return this.highlight(node, name, args);\n\t\t\telse return this.context[name].apply(this.context, args);\n\t\t},\n\n\t\thandleAttributeGet: function(node, name) {\n\t\t\treturn this.context[name];\n\t\t},\n\n\t\thandleAttributeSet: function(node, name, value) {\n\t\t\tthis.context[name] = value;\n\t\t\tif (this.highlighting) {\n\t\t\t\tif (this.functions[name].mirror) this.mirrorContext[name] = value;\n\n\t\t\t\tif (name === 'strokeStyle') {\n\t\t\t\t\tthis.actualStrokeStyle = this.context.strokeStyle;\n\t\t\t\t} else if (name === 'fillStyle') {\n\t\t\t\t\tthis.actualFillStyle = this.context.fillStyle;\n\t\t\t\t} else if (name === 'shadowColor') {\n\t\t\t\t\tthis.actualShadowColor = this.context.shadowColor;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tstartHighlighting: function() {\n\t\t\tthis.highlightNextShapes = true;\n\t\t},\n\n\t\tstopHighlighting: function() {\n\t\t\tthis.highlightNextShapes = false;\n\t\t},\n\n\t\tenableHighlighting: function() {\n\t\t\tthis.highlighting = true;\n\t\t\tthis.$div.addClass('canvas-highlighting');\n\t\t\tthis.$div.on('mousemove', $.proxy(this.mouseMove, this));\n\t\t\tthis.editor.outputRequestsRerun();\n\t\t},\n\n\t\tdisableHighlighting: function() {\n\t\t\tthis.highlighting = false;\n\t\t\tthis.highlightCallTarget = 0;\n\t\t\tthis.$div.removeClass('canvas-highlighting');\n\t\t\tthis.$div.off('mousemove');\n\t\t\tthis.editor.outputRequestsRerun();\n\t\t},\n\n\t\tstartRun: function() {\n\t\t\tthis.stopHighlighting();\n\t\t\tthis.clear();\n\t\t\tthis.$canvas.removeClass('canvas-error');\n\t\t},\n\n\t\tendRun: function() {\n\n\t\t},\n\n\t\tendRunStepping: function() {\n\n\t\t},\n\n\t\thasError: function() {\n\t\t\tthis.$canvas.addClass('canvas-error');\n\t\t},\n\n\t\tclear: function() {\n\t\t\tthis.context.restore();\n\t\t\tthis.context.save();\n\t\t\tthis.context.clearRect(0, 0, this.size, this.size);\n\t\t\tthis.context.beginPath();\n\n\t\t\tif (this.highlighting) {\n\t\t\t\tthis.mirrorContext.restore();\n\t\t\t\tthis.mirrorContext.save();\n\t\t\t\tthis.mirrorContext.clearRect(0, 0, this.size, this.size);\n\t\t\t\tthis.mirrorContext.beginPath();\n\t\t\t\tthis.highlightCallCounter = 1;\n\t\t\t\tthis.actualStrokeStyle = this.context.strokeStyle;\n\t\t\t\tthis.actualFillStyle = this.context.fillStyle;\n\t\t\t\tthis.actualShadowColor = this.context.shadowColor;\n\t\t\t}\n\t\t},\n\n\t\t/// INTERNAL FUNCTIONS ///\n\t\thighlight: function(node, name, args) {\n\t\t\tif (this.functions[name].draws) {\n\t\t\t\tif (this.functions[name].mirror && this.context.globalAlpha > 0) {\n\t\t\t\t\t// some spread is needed between the numbers as borders are blurred, and colour information is thus not 100% reliable\n\t\t\t\t\t// therefore we use calculation modulo prime, so that eventually all numbers are used, and this also introduces a nice cycle,\n\t\t\t\t\t// so that colours can be used again; the assumption is that whenever there are so many elements on the screen, the ones\n\t\t\t\t\t// that introduced faulty colours, or the original ones in case of reusing colours, are most likely overwritten already\n\t\t\t\t\tthis.highlightCallCounter = (this.highlightCallCounter + 67*65536 + 111*256 + 11) % 16777213;\n\t\t\t\t\t//this.highlightCallCounter++;\n\t\t\t\t\tvar color = 'rgba(' + (~~(this.highlightCallCounter/65536)%256) + ',' + (~~(this.highlightCallCounter/256)%256) + ',' + (this.highlightCallCounter%256) + ', 1)';\n\t\t\t\t\tthis.mirrorContext.strokeStyle = color;\n\t\t\t\t\tthis.mirrorContext.fillStyle = color;\n\t\t\t\t\tthis.mirrorContext.shadowColor = color;\n\t\t\t\t\tthis.mirrorContext.lineWidth = Math.max(3, this.context.lineWidth);\n\t\t\t\t\tthis.mirrorContext[name].apply(this.mirrorContext, args);\n\t\t\t\t}\n\n\t\t\t\tif (this.highlightNextShapes || this.highlightCallCounter === this.highlightCallTarget) {\n\t\t\t\t\tthis.context.strokeStyle = 'rgba(5, 195, 5, 0.85)';\n\t\t\t\t\tthis.context.fillStyle = 'rgba(5, 195, 5, 0.85)';\n\t\t\t\t\tthis.context.shadowColor = 'rgba(5, 195, 5, 0.85)';\n\t\t\t\t\tif (this.highlightCallTarget > 0) this.editor.highlightNode(node);\n\n\t\t\t\t\tvar retVal = this.context[name].apply(this.context, args);\n\t\t\t\t\tthis.context.strokeStyle = this.actualStrokeStyle;\n\t\t\t\t\tthis.context.fillStyle = this.actualFillStyle;\n\t\t\t\t\tthis.context.shadowColor = this.actualShadowColor;\n\t\t\t\t\treturn retVal;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.functions[name].mirror) this.mirrorContext[name].apply(this.mirrorContext, args);\n\t\t\t}\n\t\t\treturn this.context[name].apply(this.context, args);\n\t\t},\n\n\t\tmouseMove: function(event) {\n\t\t\tif (this.highlighting) {\n\t\t\t\tvar offset = this.$canvas.offset();\n\t\t\t\tvar x = event.pageX - offset.left, y = event.pageY - offset.top;\n\t\t\t\tvar pixel = this.mirrorContext.getImageData(x, y, 1, 1).data;\n\t\t\t\t// use the alpha channel as an extra safeguard\n\t\t\t\tvar target = (pixel[3] < 255 ? 0 : (pixel[0]*65536 + pixel[1]*256 + pixel[2]) % 16777213);\n\n\t\t\t\tif (this.highlightCallTarget !== target) {\n\t\t\t\t\tthis.highlightCallTarget = target;\n\t\t\t\t\tif (!this.editor.outputRequestsRerun()) {\n\t\t\t\t\t\tthis.highlightCallTarget = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (this.highlightCallTarget <= 0) {\n\t\t\t\t\t\tthis.editor.highlightNode(null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n};\n//@ sourceURL=/output/output.canvas.js"
));

require.define("/output/output.robot.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/*jshint node:true jquery:true*/\n\"use strict\";\n\nmodule.exports = function(output) {\n\toutput.RobotAnimationManager = function() { return this.init.apply(this, arguments); };\n\toutput.RobotAnimation = function() { return this.init.apply(this, arguments); };\n\toutput.Robot = function() { return this.init.apply(this, arguments); };\n\n\tvar setCss3 = function($element, name, value, addBrowserToValue) {\n\t\taddBrowserToValue = addBrowserToValue || false;\n\t\tvar browsers = ['', '-ms-', '-moz-', '-webkit-', '-o-'];\n\t\tfor (var i=0; i<browsers.length; i++) {\n\t\t\tvar cssName = browsers[i] + name;\n\t\t\tvar cssValue = (addBrowserToValue ? browsers[i] : '') + value;\n\t\t\t$element.css(cssName, cssValue);\n\t\t}\n\t};\n\n\tvar blockSize = 64;\n\n\toutput.RobotAnimationManager.prototype = {\n\t\tinit: function($robot) {\n\t\t\tthis.$robot = $robot;\n\t\t\tthis.$robot.hide();\n\t\t\tthis.runningAnimation = null;\n\t\t\tthis.insertingAnimation = null;\n\t\t},\n\n\t\tnewAnimation: function() {\n\t\t\tthis.insertingAnimation = new output.RobotAnimation(this.$robot);\n\t\t\treturn this.insertingAnimation;\n\t\t},\n\t\t\n\t\tplayAll: function() {\n\t\t\tif (this.runningAnimation === null) {\n\t\t\t\tthis.runningAnimation = this.insertingAnimation;\n\t\t\t\tthis.runningAnimation.playAll();\n\t\t\t} else if (this.insertingAnimation.animationString !== this.runningAnimation.animationString) {\n\t\t\t\tthis.runningAnimation.remove();\n\t\t\t\tthis.runningAnimation = this.insertingAnimation;\n\t\t\t\tthis.runningAnimation.playAll();\n\t\t\t}\n\t\t\tthis.insertingAnimation = null;\n\t\t},\n\n\t\tplayLast: function() {\n\t\t\tif (this.runningAnimation === null) {\n\t\t\t\tthis.runningAnimation = this.insertingAnimation;\n\t\t\t\tthis.runningAnimation.playLast();\n\t\t\t} else if (this.insertingAnimation.animationString !== this.runningAnimation.animationString) {\n\t\t\t\tthis.runningAnimation.remove();\n\t\t\t\tthis.runningAnimation = this.insertingAnimation;\n\t\t\t\tthis.runningAnimation.playLast();\n\t\t\t}\n\t\t\tthis.insertingAnimation = null;\n\t\t}\n\t};\n\n\toutput.RobotAnimation.prototype = {\n\t\tinit: function($robot) {\n\t\t\tthis.$robot = $robot;\n\t\t\t\n\t\t\tthis.rotationFactor = 0.6;\n\t\t\tthis.detectWallLength = 40000;\n\t\t\tthis.animationQueue = [];\n\t\t\tthis.animationLength = 0;\n\t\t\tthis.duration = 0.006;\n\t\t\tthis.animateTimeout = null;\n\t\t\tthis.currentAnimation = null;\n\t\t\tthis.lastNumber = 0;\n\t\t\tthis.animationString = '';\n\t\t},\n\n\t\taddMovement: function(x1, y1, x2, y2, angle) {\n\t\t\tvar dx = (x2-x1)*blockSize, dy = (y2-y1)*blockSize;\n\t\t\tvar length = Math.sqrt(dx*dx + dy*dy);\n\t\t\tthis.animationQueue.push({\n\t\t\t\ttype: 'movement', x: x1, y: y1, x2: x2, y2: y2, angle: angle, length: length\n\t\t\t});\n\t\t\tthis.animationLength += length;\n\t\t\tthis.animationString += 'm' + x1 + ',' + y1 + ',' + x2 + ',' + y2 + ',' + angle;\n\t\t},\n\n\t\taddRotation: function(x, y, angle1, angle2) {\n\t\t\tvar length = Math.abs(angle2-angle1);\n\t\t\tthis.animationQueue.push({\n\t\t\t\ttype: 'rotation', x: x, y: y, angle: angle1, angle2: angle2, length: length\n\t\t\t});\n\t\t\tthis.animationLength += length*this.rotationFactor;\n\t\t\tthis.animationString += 'r' + x + ',' + y + ',' + angle1 + ',' + angle2;\n\t\t},\n\n\t\taddDetectWall: function(x, y, angle, wall) {\n\t\t\tthis.animationQueue.push({\n\t\t\t\ttype: 'wall', x: x, y: y, angle: angle, wall: wall\n\t\t\t});\n\t\t\tthis.animationLength += this.detectWallLength;\n\t\t\tthis.animationString += 'w' + x + ',' + y + ',' + angle + ',' + wall;\n\t\t},\n\n\t\tplayAnimation: function(number) {\n\t\t\tthis.$robot.show();\n\t\t\tsetCss3(this.$robot, 'transition', '');\n\t\t\tthis.$robot.off('transitionend webkitTransitionEnd MSTransitionEnd oTransitionEnd');\n\n\t\t\tvar animation = this.animationQueue[number];\n\t\t\tthis.number = number;\n\t\t\tthis.setPosition(animation.x, animation.y);\n\t\t\tthis.setOrientation(animation.angle);\n\t\t\tthis.setLight('default');\n\n\t\t\tif (this.animateTimeout !== null) {\n\t\t\t\tclearTimeout(this.animateTimeout);\n\t\t\t}\n\n\t\t\tif (animation.type === 'wall') {\n\t\t\t\tthis.setLight(animation.wall ? 'red' : 'green');\n\t\t\t\tthis.animateTimeout = setTimeout($.proxy(this.animationEnd, this), this.duration*this.detectWallLength);\n\t\t\t} else {\n\t\t\t\tthis.animateTimeout = setTimeout($.proxy(this.animationStart, this), 0);\n\t\t\t\tthis.$robot.on('transitionend webkitTransitionEnd MSTransitionEnd oTransitionEnd', $.proxy(this.animationEnd, this));\n\t\t\t}\n\t\t},\n\n\t\tplayAll: function() {\n\t\t\tconsole.log('playAll');\n\t\t\tif (this.animationQueue.length > 0) {\n\t\t\t\tthis.lastNumber = this.animationQueue.length-1;\n\t\t\t\tthis.playAnimation(0);\n\t\t\t}\n\t\t},\n\n\t\tplayLast: function() {\n\t\t\tif (this.animationQueue.length > 0) {\n\t\t\t\tthis.lastNumber = this.animationQueue.length-1;\n\t\t\t\tthis.playAnimation(this.lastNumber);\n\t\t\t}\n\t\t},\n\n\t\tremove: function() {\n\t\t\tif (this.animateTimeout !== null) {\n\t\t\t\tclearTimeout(this.animateTimeout);\n\t\t\t}\n\t\t\tthis.$robot.off('transitionend webkitTransitionEnd MSTransitionEnd oTransitionEnd');\n\t\t\tthis.$robot.hide();\n\t\t},\n\n\t\t/// INTERNAL FUNCTIONS ///\n\t\tanimationStart: function() {\n\t\t\tthis.animateTimeout = null;\n\t\t\tvar animation = this.animationQueue[this.number];\n\t\t\tvar duration = this.duration*animation.length;\n\n\t\t\tif (animation.type === 'movement') {\n\t\t\t\tsetCss3(this.$robot, 'transition', 'left ' + duration + 's ease-in-out, top ' + duration + 's ease-in-out');\n\t\t\t\tthis.setPosition(animation.x2, animation.y2);\n\t\t\t} else if (animation.type === 'rotation') {\n\t\t\t\tduration = this.rotationFactor*duration;\n\t\t\t\tsetCss3(this.$robot, 'transition', 'transform ' + duration + 's linear', true);\n\t\t\t\tthis.setOrientation(animation.angle2);\n\t\t\t}\n\t\t},\n\n\t\tanimationEnd: function() {\n\t\t\tthis.animateTimeout = null;\n\t\t\tif (this.number < this.lastNumber) {\n\t\t\t\tthis.playAnimation(this.number+1);\n\t\t\t}\n\t\t},\n\n\t\tsetPosition: function(x, y) {\n\t\t\tthis.$robot.css('left', x*blockSize);\n\t\t\tthis.$robot.css('top', y*blockSize);\n\t\t},\n\n\t\tsetOrientation: function(angle) {\n\t\t\tsetCss3(this.$robot, 'transform', 'rotate(' + (90-angle) + 'deg)');\n\t\t},\n\n\t\tsetLight: function(state) {\n\t\t\tthis.$robot.removeClass('robot-green robot-red');\n\t\t\tif (state === 'red') {\n\t\t\t\tthis.$robot.addClass('robot-red');\n\t\t\t} else if (state === 'green') {\n\t\t\t\tthis.$robot.addClass('robot-green');\n\t\t\t}\n\t\t}\n\t};\n\n\toutput.Robot.prototype = {\n\t\tinit: function($div, editor, columns, rows) {\n\t\t\tthis.columns = columns;\n\t\t\tthis.rows = rows;\n\n\t\t\tthis.$div = $div;\n\t\t\tthis.$div.addClass('robot');\n\n\t\t\tthis.$container = $('<div class=\"robot-container robot-not-highlighting\"></div>');\n\t\t\tthis.$container.on('mouseup', $.proxy(this.containerMouseUp, this));\n\t\t\tthis.$container.on('mouseleave', $.proxy(this.containerMouseLeave, this));\n\t\t\tthis.$div.append(this.$container);\n\n\t\t\tthis.$maze = $('<div class=\"robot-maze\"></div>');\n\t\t\tthis.$container.append(this.$maze);\n\n\t\t\tthis.$path = $('<div class=\"robot-path\"></div>');\n\t\t\tthis.$container.append(this.$path);\n\n\t\t\tthis.$initial = $('<div class=\"robot-robot robot-initial\"></div>');\n\t\t\tthis.$initial.on('mousedown', $.proxy(this.initialMouseDown, this));\n\t\t\tthis.$initial.on('mouseup', $.proxy(this.initialMouseUp, this));\n\t\t\tthis.$container.append(this.$initial);\n\n\t\t\tthis.$robot = $('<div class=\"robot-robot\"></div>');\n\t\t\tthis.$container.append(this.$robot);\n\t\t\tthis.$robot.hide();\n\n\t\t\tthis.highlighting = false;\n\t\t\tthis.highlightNext = false;\n\t\t\tthis.animation = null;\n\t\t\tthis.stateChangedCallback = null;\n\t\t\tthis.animationManager = new output.RobotAnimationManager(this.$robot);\n\n\t\t\tthis.initialState(columns, rows);\n\t\t\tthis.clear();\n\n\t\t\tthis.editor = editor;\n\t\t\tthis.editor.addOutput(this);\n\t\t},\n\n\t\tdrive: function(node, name, args) {\n\t\t\tvar amount = args[0] || 1;\n\t\t\tif (args.length > 1) {\n\t\t\t\tthrow function(f) { return f('forward') + ' accepts no more than' + f('1') + ' argument'; };\n\t\t\t} else if (typeof amount !== 'number' || !isFinite(amount)) {\n\t\t\t\tthrow function(f) { return 'Argument has to be a valid number'; };\n\t\t\t} else if (Math.round(amount) !== amount && this.mazeObjects > 0) {\n\t\t\t\tthrow function(f) { return 'Fractional amounts are only allowed when the maze is empty'; };\n\t\t\t} else if (amount !== 0) {\n\t\t\t\tvar fromX = this.robotX, fromY = this.robotY;\n\n\t\t\t\tif (this.mazeObjects > 0) {\n\t\t\t\t\tvar positive = amount > 0;\n\t\t\t\t\tfor (var i=0; i<Math.abs(amount); i++) {\n\t\t\t\t\t\tif (this.isWall(this.robotX, this.robotY, positive ? this.robotAngle : (this.robotAngle + 180)%360)) {\n\t\t\t\t\t\t\tthis.animation.addMovement(fromX, fromY, this.robotX, this.robotY, this.robotAngle);\n\t\t\t\t\t\t\tthis.insertLine(node, fromX, fromY, this.robotX, this.robotY);\n\t\t\t\t\t\t\tthrow 'Robot ran into a wall';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (this.robotAngle === 0) {\n\t\t\t\t\t\t\tthis.robotX += (positive ? 1 : -1);\n\t\t\t\t\t\t} else if (this.robotAngle === 90) {\n\t\t\t\t\t\t\tthis.robotY -= (positive ? 1 : -1);\n\t\t\t\t\t\t} else if (this.robotAngle === 180) {\n\t\t\t\t\t\t\tthis.robotX -= (positive ? 1 : -1);\n\t\t\t\t\t\t} else if (this.robotAngle === 270) {\n\t\t\t\t\t\t\tthis.robotY += (positive ? 1 : -1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.robotX += Math.cos(this.robotAngle / 180 * Math.PI)*amount;\n\t\t\t\t\tthis.robotY -= Math.sin(this.robotAngle / 180 * Math.PI)*amount;\n\t\t\t\t}\n\t\t\t\tthis.insertLine(node, fromX, fromY, this.robotX, this.robotY);\n\t\t\t\tif (this.animation !== null) {\n\t\t\t\t\tthis.animation.addMovement(fromX, fromY, this.robotX, this.robotY, this.robotAngle);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tturn: function(node, name, args) {\n\t\t\tvar amount = args[0] || 90;\n\t\t\tamount = (name === 'turnLeft' ? amount : -amount);\n\n\t\t\tvar amountNormalized = ((amount%360)+360)%360;\n\t\t\tif (args.length > 1) {\n\t\t\t\tthrow function(f) { return f(name) + ' accepts no more than' + f('1') + ' argument'; };\n\t\t\t} else if (typeof amount !== 'number' || !isFinite(amount)) {\n\t\t\t\tthrow function(f) { return 'Argument has to be a valid number'; };\n\t\t\t} else if ([0, 90, 180, 270].indexOf(amountNormalized) < 0 && this.mazeObjects > 0) {\n\t\t\t\tthrow function(f) { return 'Only 90, 180 and 270 degrees are allowed when the maze is not empty'; };\n\t\t\t} else {\n\t\t\t\tif (this.animation !== null) {\n\t\t\t\t\tthis.animation.addRotation(this.robotX, this.robotY, this.robotAngle, this.robotAngle + amount);\n\t\t\t\t}\n\t\t\t\tthis.robotAngle += amount;\n\t\t\t\tthis.robotAngle = ((this.robotAngle%360)+360)%360;\n\t\t\t\tthis.insertPoint(node, this.robotX, this.robotY, this.robotAngle);\n\t\t\t}\n\t\t},\n\n\t\tdetectWall: function(node, name, args) {\n\t\t\tvar wall = this.isWall(this.robotX, this.robotY, this.robotAngle);\n\t\t\tif (this.animation !== null) {\n\t\t\t\tthis.animation.addDetectWall(this.robotX, this.robotY, this.robotAngle, wall);\n\t\t\t}\n\t\t\treturn wall;\n\t\t},\n\n\t\tdetectGoal: function(node, name, args) {\n\t\t\tif (this.mazeObjects <= 0) return false;\n\t\t\telse return this.blockGoal[this.robotX][this.robotY];\n\t\t},\n\t\t\n\t\tgetAugmentedObject: function() {\n\t\t\treturn {\n\t\t\t\tdrive: {\n\t\t\t\t\tname: 'drive',\n\t\t\t\t\taugmented: 'function',\n\t\t\t\t\texample: 'drive(3)',\n\t\t\t\t\tfunc: $.proxy(this.drive, this)\n\t\t\t\t},\n\t\t\t\tturnLeft: {\n\t\t\t\t\tname: 'turnLeft',\n\t\t\t\t\taugmented: 'function',\n\t\t\t\t\texample: 'turnLeft()',\n\t\t\t\t\tfunc: $.proxy(this.turn, this)\n\t\t\t\t},\n\t\t\t\tturnRight: {\n\t\t\t\t\tname: 'turnRight',\n\t\t\t\t\taugmented: 'function',\n\t\t\t\t\texample: 'turnRight()',\n\t\t\t\t\tfunc: $.proxy(this.turn, this)\n\t\t\t\t},\n\t\t\t\tdetectWall: {\n\t\t\t\t\tname: 'detectWall',\n\t\t\t\t\taugmented: 'function',\n\t\t\t\t\texample: 'detectWall()',\n\t\t\t\t\tfunc: $.proxy(this.detectWall, this)\n\t\t\t\t},\n\t\t\t\tdetectGoal: {\n\t\t\t\t\tname: 'detectGoal',\n\t\t\t\t\taugmented: 'function',\n\t\t\t\t\texample: 'detectGoal()',\n\t\t\t\t\tfunc: $.proxy(this.detectGoal, this)\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\n\t\tstartHighlighting: function() {\n\t\t\tthis.highlightNext = true;\n\t\t},\n\n\t\tstopHighlighting: function() {\n\t\t\tthis.highlightNext = false;\n\t\t},\n\n\t\tenableHighlighting: function() {\n\t\t\tthis.highlighting = true;\n\t\t\tthis.$container.removeClass('robot-not-highlighting');\n\t\t\tthis.$container.addClass('robot-highlighting');\n\t\t},\n\n\t\tdisableHighlighting: function() {\n\t\t\tthis.highlighting = false;\n\t\t\tthis.$container.removeClass('robot-highlighting');\n\t\t\tthis.$container.addClass('robot-not-highlighting');\n\t\t\t/*\n\t\t\tif (this.animation !== null) {\n\t\t\t\tthis.animation.remove();\n\t\t\t\tthis.animation = null;\n\t\t\t}\n\t\t\t*/\n\t\t},\n\n\t\tstartRun: function() {\n\t\t\tthis.clear();\n\t\t\tthis.$container.removeClass('robot-error');\n\t\t\tthis.animation = this.animationManager.newAnimation();\n\t\t},\n\n\t\tendRun: function() {\n\t\t\tthis.animationManager.playAll();\n\t\t},\n\n\t\tendRunStepping: function() {\n\t\t\tthis.animationManager.playLast();\n\t\t},\n\n\t\thasError: function() {\n\t\t\tthis.$container.addClass('robot-error');\n\t\t},\n\n\t\tclear: function() {\n\t\t\tthis.robotX = this.initialX;\n\t\t\tthis.robotY = this.initialY;\n\t\t\tthis.robotAngle = this.initialAngle;\n\t\t\tthis.$path.children('.robot-path-line, .robot-path-point').remove();\n\t\t},\n\n\t\tgetState: function() {\n\t\t\tvar verticalActive = [], horizontalActive = [], blockGoal = [];\n\t\t\tfor (var x=0; x<this.columns; x++) {\n\t\t\t\tverticalActive[x] = [];\n\t\t\t\thorizontalActive[x] = [];\n\t\t\t\tblockGoal[x] = [];\n\t\t\t\tfor (var y=0; y<this.rows; y++) {\n\t\t\t\t\tverticalActive[x][y] = this.verticalActive[x][y];\n\t\t\t\t\thorizontalActive[x][y] = this.horizontalActive[x][y];\n\t\t\t\t\tblockGoal[x][y] = this.blockGoal[x][y];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tcolumns: this.columns,\n\t\t\t\trows: this.rows,\n\t\t\t\tinitialX: this.initialX,\n\t\t\t\tinitialY: this.initialY,\n\t\t\t\tinitialAngle: this.initialAngle,\n\t\t\t\tmazeObjects: this.mazeObjects,\n\t\t\t\tverticalActive: verticalActive,\n\t\t\t\thorizontalActive: horizontalActive,\n\t\t\t\tblockGoal: blockGoal\n\t\t\t};\n\t\t},\n\n\t\tsetState: function(state) {\n\t\t\tthis.columns = state.columns;\n\t\t\tthis.rows = state.rows;\n\t\t\tthis.initialX = state.initialX;\n\t\t\tthis.initialY = state.initialY;\n\t\t\tthis.initialAngle = state.initialAngle;\n\t\t\tthis.mazeObjects = state.mazeObjects;\n\t\t\tthis.verticalActive = [];\n\t\t\tthis.horizontalActive = [];\n\t\t\tthis.blockGoal = [];\n\t\t\tfor (var x=0; x<this.columns; x++) {\n\t\t\t\tthis.verticalActive[x] = [];\n\t\t\t\tthis.horizontalActive[x] = [];\n\t\t\t\tthis.blockGoal[x] = [];\n\t\t\t\tfor (var y=0; y<this.rows; y++) {\n\t\t\t\t\tthis.verticalActive[x][y] = state.verticalActive[x][y];\n\t\t\t\t\tthis.horizontalActive[x][y] = state.horizontalActive[x][y];\n\t\t\t\t\tthis.blockGoal[x][y] = state.blockGoal[x][y];\n\t\t\t\t}\n\t\t\t}\n\t\t\t//console.log(this.verticalActive);\n\t\t\tthis.drawInterface();\n\t\t},\n\n\t\tinitialState: function(columns, rows) {\n\t\t\tthis.columns = columns;\n\t\t\tthis.rows = rows;\n\t\t\tthis.initialX = Math.floor(this.columns/2);\n\t\t\tthis.initialY = rows-1;\n\t\t\tthis.initialAngle = 90;\n\t\t\tthis.mazeObjects = 0;\n\t\t\tthis.verticalActive = [];\n\t\t\tthis.horizontalActive = [];\n\t\t\tthis.blockGoal = [];\n\t\t\tfor (var x=0; x<this.columns; x++) {\n\t\t\t\tthis.verticalActive[x] = [];\n\t\t\t\tthis.horizontalActive[x] = [];\n\t\t\t\tthis.blockGoal[x] = [];\n\t\t\t\tfor (var y=0; y<this.rows; y++) {\n\t\t\t\t\tthis.verticalActive[x][y] = false;\n\t\t\t\t\tthis.horizontalActive[x][y] = false;\n\t\t\t\t\tthis.blockGoal[x][y] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.drawInterface();\n\t\t},\n\n\t\tsetStateChangedCallback: function(callback) {\n\t\t\tthis.stateChangedCallback = callback;\n\t\t},\n\n\t\t/// INTERNAL FUNCTIONS ///\n\t\tdrawInterface: function() {\n\t\t\tvar x, y, $line, $block;\n\n\t\t\tthis.width = this.columns * blockSize;\n\t\t\tthis.height = this.rows * blockSize;\n\t\t\tthis.$container.width(this.width);\n\t\t\tthis.$container.height(this.height);\n\n\t\t\t// inits\n\t\t\tthis.$container.children('.robot-maze-block .robot-maze-line-vertical, .robot-maze-line-horizontal').remove();\n\t\t\tthis.$verticalLines = [];\n\t\t\tthis.$horizontalLines = [];\n\t\t\tthis.$blocks = [];\n\t\t\tfor (x=0; x<this.columns; x++) {\n\t\t\t\tthis.$verticalLines[x] = [];\n\t\t\t\tthis.$horizontalLines[x] = [];\n\t\t\t\tthis.$blocks[x] = [];\n\t\t\t}\n\n\t\t\t// blocks\n\t\t\tfor (x=0; x<this.columns; x++) {\n\t\t\t\tfor (y=0; y<this.rows; y++) {\n\t\t\t\t\t$block = $('<div class=\"robot-maze-block\"></div>');\n\t\t\t\t\t$block.css('left', x*blockSize);\n\t\t\t\t\t$block.css('top', y*blockSize);\n\t\t\t\t\t$block.data('x', x);\n\t\t\t\t\t$block.data('y', y);\n\t\t\t\t\t$block.on('click', $.proxy(this.clickBlock, this));\n\t\t\t\t\tif (this.blockGoal[x][y]) $block.addClass('robot-maze-block-goal');\n\t\t\t\t\tthis.$maze.append($block);\n\t\t\t\t\tthis.$blocks[x][y] = $block;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// vertical lines\n\t\t\tfor (y=0; y<this.rows; y++) {\n\t\t\t\tfor (x=1; x<this.columns; x++) {\n\t\t\t\t\t$line = $('<div class=\"robot-maze-line-vertical\"><div class=\"robot-maze-line-inside\"></div></div>');\n\t\t\t\t\t$line.css('left', x*blockSize);\n\t\t\t\t\t$line.css('top', y*blockSize);\n\t\t\t\t\t$line.on('click', $.proxy(this.clickVerticalLine, this));\n\t\t\t\t\t$line.data('x', x);\n\t\t\t\t\t$line.data('y', y);\n\t\t\t\t\tif (this.verticalActive[x][y]) $line.addClass('robot-maze-line-active');\n\t\t\t\t\tthis.$maze.append($line);\n\t\t\t\t\tthis.$verticalLines[x][y] = $line;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// horizontal lines\n\t\t\tfor (x=0; x<this.columns; x++) {\n\t\t\t\tfor (y=1; y<this.rows; y++) {\n\t\t\t\t\t$line = $('<div class=\"robot-maze-line-horizontal\"><div class=\"robot-maze-line-inside\"></div></div>');\n\t\t\t\t\t$line.css('left', x*blockSize);\n\t\t\t\t\t$line.css('top', y*blockSize);\n\t\t\t\t\t$line.on('click', $.proxy(this.clickHorizontalLine, this));\n\t\t\t\t\t$line.data('x', x);\n\t\t\t\t\t$line.data('y', y);\n\t\t\t\t\tif (this.horizontalActive[x][y]) $line.addClass('robot-maze-line-active');\n\t\t\t\t\tthis.$maze.append($line);\n\t\t\t\t\tthis.$horizontalLines[x][y] = {$line: $line, active: false};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.drawInitial();\n\t\t},\n\n\t\tdrawInitial: function() {\n\t\t\tthis.$initial.css('left', this.initialX * blockSize);\n\t\t\tthis.$initial.css('top', this.initialY * blockSize);\n\t\t},\n\n\t\tclickVerticalLine: function(event) {\n\t\t\tvar $target = $(event.delegateTarget);\n\t\t\tvar active = !this.verticalActive[$target.data('x')][$target.data('y')];\n\t\t\tthis.verticalActive[$target.data('x')][$target.data('y')] = active;\n\t\t\tif (active) {\n\t\t\t\tthis.mazeObjects++;\n\t\t\t\t$target.addClass('robot-maze-line-active');\n\t\t\t} else {\n\t\t\t\tthis.mazeObjects--;\n\t\t\t\t$target.removeClass('robot-maze-line-active');\n\t\t\t}\n\t\t\tthis.editor.outputRequestsRerun();\n\t\t\tthis.stateChanged();\n\t\t},\n\n\t\tclickHorizontalLine: function(event) {\n\t\t\tvar $target = $(event.delegateTarget);\n\t\t\tvar active = !this.horizontalActive[$target.data('x')][$target.data('y')];\n\t\t\tthis.horizontalActive[$target.data('x')][$target.data('y')] = active;\n\t\t\tif (active) {\n\t\t\t\tthis.mazeObjects++;\n\t\t\t\t$target.addClass('robot-maze-line-active');\n\t\t\t} else {\n\t\t\t\tthis.mazeObjects--;\n\t\t\t\t$target.removeClass('robot-maze-line-active');\n\t\t\t}\n\t\t\tthis.editor.outputRequestsRerun();\n\t\t\tthis.stateChanged();\n\t\t},\n\t\t\n\t\tisWall: function(x, y, angle) {\n\t\t\tif (this.mazeObjects <= 0) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tif (angle === 0) {\n\t\t\t\t\tif (x >= this.columns-1 || this.verticalActive[x+1][y]) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else if (angle === 90) {\n\t\t\t\t\tif (y <= 0 || this.horizontalActive[x][y]) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else if (angle === 180) {\n\t\t\t\t\tif (x <= 0 || this.verticalActive[x][y]) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else if (angle === 270) {\n\t\t\t\t\tif (y >= this.rows-1 || this.horizontalActive[x][y+1]) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\t\tinsertLine: function(node, fromX, fromY, toX, toY) {\n\t\t\tvar dy = (toY-fromY)*blockSize, dx = (toX-fromX)*blockSize;\n\t\t\tvar angleRad = Math.atan2(dy, dx);\n\t\t\tvar length = Math.sqrt(dx*dx+dy*dy);\n\t\t\tvar $line = $('<div class=\"robot-path-line\"><div class=\"robot-path-line-inside\"></div></div>');\n\t\t\tthis.$path.append($line);\n\t\t\t$line.width(length);\n\t\t\tsetCss3($line, 'transform', 'rotate(' + (angleRad*180/Math.PI) + 'deg)');\n\t\t\t$line.css('left', fromX*blockSize + blockSize/2 + dx/2 - length/2);\n\t\t\t$line.css('top', fromY*blockSize + blockSize/2 + dy/2);\n\t\t\tif (this.highlightNext) {\n\t\t\t\t$line.addClass('robot-path-highlight');\n\t\t\t}\n\t\t\t$line.on('mousemove', $.proxy(this.pathMouseMove, this));\n\t\t\t$line.on('mouseleave', $.proxy(this.pathMouseLeave, this));\n\t\t\t$line.data('node', node);\n\t\t},\n\n\t\tinsertPoint: function(node, x, y, angle) {\n\t\t\tvar $point = $('<div class=\"robot-path-point\"><div class=\"robot-path-point-inside\"><div class=\"robot-path-point-arrow\"></div></div></div>');\n\t\t\tthis.$path.append($point);\n\t\t\tvar angleRad = angle/180*Math.PI;\n\t\t\t// 5 = 0.5*@robot-path-point-arrow-hover\n\t\t\t$point.css('left', x*blockSize + blockSize/2 + 5*Math.cos(angleRad));\n\t\t\t$point.css('top', y*blockSize + blockSize/2 - 5*Math.sin(angleRad));\n\t\t\tsetCss3($point, 'transform', 'rotate(' + (-angle) + 'deg)');\n\t\t\tif (this.highlightNext) {\n\t\t\t\t$point.addClass('robot-path-highlight');\n\t\t\t}\n\t\t\t$point.on('mousemove', $.proxy(this.pathMouseMove, this));\n\t\t\t$point.on('mouseleave', $.proxy(this.pathMouseLeave, this));\n\t\t\t$point.data('node', node);\n\t\t},\n\n\t\tpathMouseMove: function(event) {\n\t\t\tif (this.highlighting) {\n\t\t\t\tvar $target = $(event.delegateTarget);\n\t\t\t\tif ($target.data('node') !== undefined && !$target.hasClass('robot-path-highlight')) {\n\t\t\t\t\tthis.$path.children('.robot-path-highlight').removeClass('robot-path-highlight');\n\t\t\t\t\t$target.addClass('robot-path-highlight');\n\t\t\t\t\tthis.editor.highlightNode($target.data('node'));\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tpathMouseLeave: function(event) {\n\t\t\tif (this.highlighting) {\n\t\t\t\tthis.$path.children('.robot-path-highlight').removeClass('robot-path-highlight');\n\t\t\t\tthis.editor.highlightNode(null);\n\t\t\t}\n\t\t},\n\n\t\tinitialMouseDown: function(event) {\n\t\t\tif (!this.draggingInitial) {\n\t\t\t\tthis.draggingInitial = true;\n\t\t\t\tthis.$container.on('mousemove', $.proxy(this.containerInitialMouseMove, this));\n\t\t\t\tthis.$initial.addClass('robot-initial-dragging');\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t},\n\n\t\tcontainerMouseUp: function(event) {\n\t\t\tif (this.draggingInitial) {\n\t\t\t\tthis.$container.off('mousemove');\n\t\t\t\tthis.$initial.removeClass('robot-initial-dragging');\n\t\t\t\tthis.draggingInitial = false;\n\t\t\t}\n\t\t},\n\n\t\tcontainerMouseLeave: function(event) {\n\t\t\tif (this.draggingInitial) {\n\t\t\t\tthis.$container.off('mousemove');\n\t\t\t\tthis.$initial.removeClass('robot-initial-dragging');\n\t\t\t\tthis.draggingInitial = false;\n\t\t\t}\n\t\t},\n\n\t\tcontainerInitialMouseMove: function(event) {\n\t\t\tvar $target = $(event.target);\n\t\t\tif ($target.hasClass('robot-maze-block')) {\n\t\t\t\tthis.initialX = $target.data('x');\n\t\t\t\tthis.initialY = $target.data('y');\n\t\t\t\tthis.drawInitial();\n\t\t\t\tthis.editor.outputRequestsRerun();\n\t\t\t\tthis.stateChanged();\n\t\t\t}\n\t\t},\n\n\t\tclickBlock: function(event) {\n\t\t\tvar $target = $(event.delegateTarget);\n\t\t\tvar goal = !this.blockGoal[$target.data('x')][$target.data('y')];\n\t\t\tthis.blockGoal[$target.data('x')][$target.data('y')] = goal;\n\t\t\tif (goal) {\n\t\t\t\tthis.mazeObjects++;\n\t\t\t\t$target.addClass('robot-maze-block-goal');\n\t\t\t} else {\n\t\t\t\tthis.mazeObjects--;\n\t\t\t\t$target.removeClass('robot-maze-block-goal');\n\t\t\t}\n\t\t\tthis.editor.outputRequestsRerun();\n\t\t\tthis.stateChanged();\n\t\t},\n\n\t\tstateChanged: function() {\n\t\t\tif (this.stateChangedCallback !== null) {\n\t\t\t\tthis.stateChangedCallback(this.getState());\n\t\t\t}\n\t\t}\n\t};\n};\n//@ sourceURL=/output/output.robot.js"
));

require.define("/cli-widget.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/*jshint node:true jquery:true*/\n\"use strict\";\n\n$(function() {\n\tvar jsmm = require('./jsmm');\n\tvar editor = require('./editor');\n\tvar output = require('./output');\n\n\tif (window.localStorage.getItem('2') === null) {\n\t\twindow.localStorage.setItem('2', \"console.setColor(\\\"#fbf706\\\");\\nconsole.log(\\\"Colourful multiplication table:\\\");\\nconsole.log(\\\"\\\");\\n\\nvar width = 9;\\n\\nfunction printLine(x) {\\n  var line = \\\"\\\";\\n  for (var i=1; i<=width; i++) {\\n    var number = i*x;\\n    line += number + \\\"\\\\t\\\";\\n  }\\n  console.log(line);\\n}\\n\\nfunction drawLine() {\\n    var line = \\\"\\\";\\n    for (var i=1; i<=width-1; i++) {\\n      line += \\\"--------\\\"; // 8 dashes\\n    }\\n    line += \\\"---\\\"; // some extra for the last column\\n    \\n    console.setColor(\\\"#e821e1\\\");\\n    console.log(line);  \\n}\\n\\nfor (var i=1; i<=29; i++) {\\n  console.setColor(\\\"hsl(\\\" + i*11 + \\\", 100%, 50%)\\\");\\n  printLine(i);\\n  \\n  // try playing with true and false here! :)\\n  if (i % 10 == 0 && true || false) {\\n    drawLine();\\n  }\\n}\\n\\nconsole.setColor(\\\"hsla(130, 75%, 55%, 0.9)\\\");\\nconsole.log(\\\"\\\");\\nconsole.log(\\\"By Jan Paul Posma\\\");\\nconsole.log(\\\"\\\");\\n\\nconsole.setColor(\\\"rgba(230, 230, 0, 1)\\\");\\nconsole.log(\\\";)\\\");\");\n\t}\n\n\tvar highlightingKey = false, editablesKey = false;\n\n\tvar ui = {\n\t\teditablesEnabled: function() {\n\t\t\t$('#edit').addClass('active');\n\t\t},\n\t\teditablesDisabled: function() {\n\t\t\t$('#edit').removeClass('active');\n\t\t\teditablesKey = false;\n\t\t\trefreshCheckKeys();\n\t\t},\n\t\thighlightingEnabled: function() {\n\t\t\t$('#highlight').addClass('active');\n\t\t},\n\t\thighLightingDisabled: function() {\n\t\t\t$('#highlight').removeClass('active');\n\t\t\thighlightingKey = false;\n\t\t\trefreshCheckKeys();\n\t\t},\n\t\tpreviewing: function() {\n\t\t\t$('#step').addClass('disabled');\n\t\t\t$('#step-back').addClass('disabled');\n\t\t\t$('#refresh').addClass('disabled');\n\t\t\t$('#edit').addClass('disabled');\n\t\t\t$('#highlight').addClass('disabled');\n\t\t},\n\t\tcriticalError: function() {\n\t\t\t$('#step').addClass('disabled');\n\t\t\t$('#step-back').addClass('disabled');\n\t\t\t$('#refresh').addClass('disabled');\n\t\t\t$('#edit').addClass('disabled');\n\t\t\t$('#highlight').addClass('disabled');\n\t\t},\n\t\trunningWithoutError: function() {\n\t\t\t$('#step').removeClass('disabled');\n\t\t\t$('#step-back').addClass('disabled');\n\t\t\t$('#refresh').addClass('disabled');\n\t\t\t$('#edit').removeClass('disabled');\n\t\t\t$('#highlight').removeClass('disabled');\n\t\t},\n\t\trunningWithError: function() {\n\t\t\t$('#step').removeClass('disabled');\n\t\t\t$('#step-back').addClass('disabled');\n\t\t\t$('#refresh').addClass('disabled');\n\t\t\t$('#edit').removeClass('disabled');\n\t\t\t$('#highlight').removeClass('disabled');\n\t\t},\n\t\tsteppingWithoutError: function() {\n\t\t\t$('#step').removeClass('disabled');\n\t\t\t$('#step-back').removeClass('disabled');\n\t\t\t$('#refresh').removeClass('disabled');\n\t\t\t$('#edit').removeClass('disabled');\n\t\t\t$('#highlight').removeClass('disabled');\n\t\t},\n\t\tsteppingWithError: function() {\n\t\t\t$('#step').addClass('disabled');\n\t\t\t$('#step-back').removeClass('disabled');\n\t\t\t$('#refresh').removeClass('disabled');\n\t\t\t$('#edit').removeClass('disabled');\n\t\t\t$('#highlight').removeClass('disabled');\n\t\t},\n\t\ttextChanged: function(code) {\n\t\t\twindow.localStorage.setItem('2', code.text);\n\t\t}\n\t};\n\n\tvar ed = new editor.Editor(jsmm, $('#editor'), ui, window.localStorage.getItem('2'));\n\twindow.ed = ed;\n\tvar myConsole = new output.Console($('#console'), ed);\n\tvar canvas = new output.Canvas($('#canvas'), ed);\n\tvar robot = new output.Robot($('#robot'), ed, 8, 8);\n\twindow.robot = robot;\n\n\tif (window.localStorage.getItem('robot-2') !== null) {\n\t\trobot.setState(JSON.parse(window.localStorage.getItem('robot-2')));\n\t}\n\n\trobot.setStateChangedCallback(function(state) {\n\t\twindow.localStorage.setItem('robot-2', JSON.stringify(state));\n\t});\n\n\tvar scope = {\n\t\tconsole: myConsole.getAugmentedObject(),\n\t\tcanvas: canvas.getAugmentedObject(),\n\t\trobot: robot.getAugmentedObject()\n\t};\n\n\ted.setScope(scope);\n\t\n\tvar realConsole = {\n\t\tlog: function(text) {\n\t\t\tif (console && console.log) {\n\t\t\t\tconsole.log(text);\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t};\n\n\tvar runner = new jsmm.SimpleRunner('', scope);\n\n\tvar clear = function() {\n\t\tmyConsole.clear();\n\t\t//myCanvas.clear();\n\t\trunner.setText(ed.getText());\n\t\t$('#refresh').removeClass('disabled');\n\t};\n\n\tvar log = function(text) {\n\t\tmyConsole.log(null, 'log', [text]);\n\t};\n\n\tvar isMac = navigator.platform.indexOf(\"Mac\") >= 0;\n\t$('#highlight').tooltip({title: '<strong>ctrl</strong>' + (isMac ? ' or <strong>cmd</strong> (&#8984;)' : ''), placement: 'bottom'});\n\t$('#edit').tooltip({title: '<strong>alt</strong>' + (isMac ? ' (&#8997;)' : ''), placement: 'bottom'});\n\n\t$('#step').click($.proxy(ed.stepForward, ed));\n\t$('#step-back').click($.proxy(ed.stepBackward, ed));\n\t$('#refresh').click($.proxy(ed.restart, ed));\n\t$('#highlight').click(function(event) {\n\t\tif ($('#highlight').hasClass('active')) ed.disableHighlighting();\n\t\telse ed.enableHighlighting();\n\t});\n\t$('#edit').click(function(event) {\n\t\tif ($('#edit').hasClass('active')) ed.disableEditables();\n\t\telse ed.enableEditables();\n\t});\n\n\t$('#console-button').click(function(e) {\n\t\t$('#canvas').hide();\n\t\t$('#console').show();\n\t});\n\n\n\tvar checkKeys = function(event) {\n\t\tif (highlightingKey && !(event.ctrlKey || event.metaKey)) {\n\t\t\ted.disableHighlighting();\n\t\t}\n\t\tif (editablesKey && !event.altKey) {\n\t\t\ted.disableEditables();\n\t\t}\n\t};\n\n\tvar refreshCheckKeys = function() {\n\t\tif (highlightingKey || editablesKey) {\n\t\t\t$(document).on('mousemove', checkKeys);\n\t\t} else {\n\t\t\t$(document).off('mousemove', checkKeys);\n\t\t}\n\t};\n\n\t$(document).on('keydown', function(event) {\n\t\t// 17 == CTRL, 18 == ALT, (17, 91, 93, 224) == COMMAND\n\t\tif ([17, 91, 93, 224].indexOf(event.keyCode) >= 0) {\n\t\t\ted.enableHighlighting();\n\t\t\thighlightingKey = true;\n\t\t\trefreshCheckKeys();\n\t\t} else if (event.keyCode === 18) {\n\t\t\ted.enableEditables();\n\t\t\teditablesKey = true;\n\t\t\trefreshCheckKeys();\n\t\t}\n\t});\n\n\t$(document).on('keyup', function(event) {\n\t\t// 17 == CTRL, 18 == ALT, (17, 91, 93, 224) == COMMAND\n\t\tif ([17, 91, 93, 224].indexOf(event.keyCode) >= 0) {\n\t\t\ted.disableHighlighting();\n\t\t} else if (event.keyCode === 18) {\n\t\t\ted.disableEditables();\n\t\t}\n\t});\n\n\n\n\t/*\n\t$('#canvas-button').click(function(e) {\n\t\t$('#canvas').show();\n\t\t$('#console').hide();\n\t});\n*/\n\t\n\t/*\n\t$('#console-log').click(function(e) {\n\t\trun();\n\t\tvar offset = $('#code')[0].selectionStart;\n\t\tvar code = runner.getCode();\n\t\t$('#code').val(code.insertAtOffset(offset, 'console.log(\"Hi!\");'));\n\t\t$('#code')[0].selectionStart = offset + 12;\n\t\t$('#code')[0].selectionEnd = $('#code')[0].selectionStart + 5;\n\t\trun();\n\t});\n\t\n\t$('#console-clear').click(function(e) {\n\t\trun();\n\t\tvar offset = $('#code')[0].selectionStart;\n\t\tvar code = runner.getCode();\n\t\t$('#code').val(code.insertAtOffset(offset, 'console.clear();'));\n\t\t$('#code')[0].selectionStart = offset + 16;\n\t\t$('#code')[0].selectionEnd = $('#code')[0].selectionStart;\n\t\trun();\n\t});\n\t\n\t$('#console-example').click(function(e) {\n\t\t$('#code').val($('#code').val() + '\\n// Some example code\\nfunction cube(n) {\\n  return n*n*n;\\n}\\n\\nfor (var i=0; i<10; i++) {\\n  var output = cube(i);\\n  console.log(i + \": \" + output);\\n}\\n');\n\t\trun();\n\t});\n*/\n\t\n\t$('#extra-compile').click(function(e) {\n\t\tclear();\n\t\tlog(runner.getRawCode());\n\t});\n\t\n\t$('#extra-safe').click(function(e) {\n\t\tclear();\n\t\tlog(runner.getSafeCode());\n\t});\n\t\n\t$('#extra-tree').click(function(e) {\n\t\tclear();\n\t\twindow.open('https://chart.googleapis.com/chart?cht=gv&chl=' + encodeURIComponent(runner.getDot()));\n\t\tlog('\"dot\" string (renderable with Graphviz):\\n');\n\t\tlog(runner.getDot());\n\t});\n\n\t$('#extra-canvas-mirror').click(function(e) {\n\t\tclear();\n\t\t$('#canvas').addClass('canvas-show-mirror');\n\t\tlog('The canvas mirror is used to map canvas x-y coordinates back to lines of code. With the console this is easy, as DOM elements can be given jQuery data attributes. Canvas pixels, however, can be drawn using complex functions such as splines. As such, the mirror mimics every action of the real canvas, but the three colour channels are used for encoding call information. This way the corresponding line in the code can be highlighted, and all corresponding pixels in the image can be highlighted as well. Note that the specific call, and not only the line of code, is stored, so that only the pixels of that specific call are highlighted.');\n\t});\n\t\n\t$('#extra-nodes').click(function(e) {\n\t\tclear();\n\t\trunner.parse();\n\t\t\n\t\tfor (var i=0; i<runner.tree.nodes.length; i++) {\n\t\t\tvar node = runner.tree.nodes[i];\n\t\t\tlog(node.type + ' @ line ' + node.lineLoc.line + ', column ' + node.lineLoc.column);\n\t\t}\n\t\t\n\t\tif (realConsole.log(runner.tree)) {\n\t\t\tlog('\\nNote: full tree has also been printed to browser console.');\n\t\t}\n\t});\n\t\n\t$('#extra-tests').click(function(e) {\n\t\tclear();\n\t\tjsmm.test.runAll();\n\t\tlog(jsmm.test.output);\n\t});\n\t\n\tvar stressTime = function(n, f) {\n\t\tvar start = (new Date()).getTime();\n\t\tfor (var i=0; i<n; i++) {\n\t\t\tf();\n\t\t}\n\t\treturn ((new Date()).getTime() - start)/n;\n\t};\n\t\n\t$('#extra-stress').click(function(e) {\n\t\tclear();\n\t\tvar parseAvg = stressTime(200, function() { runner.reset(); runner.parse(); });\n\t\tvar parseGenAvg = stressTime(200, function() { runner.reset(); runner.makeSafeFunc(); });\n\t\tvar runAvg = stressTime(200, function() { runner.runSafe(); });\n\t\tclear();\n\t\tlog('Program average parse time: ' + parseAvg + 'ms (out of 200 trials)');\n\t\tlog('Program average parse + code generation time: ' + parseGenAvg + 'ms (out of 200 trials)');\n\t\tlog('Program average run time: ' + runAvg + 'ms (out of 200 trials)');\n\t\tlog('');\n\t\tlog('Note: the Javascript time function is not completely reliable...');\n\t});\n\t\n\t/*\n\t$('#extra-scope').click(function(e) {\n\t\tclear();\n\t\tif (!runner.isStepping()) {\n\t\t\tlog('Not stepping...');\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tlog(JSON.stringify(runner.stack.getLastStackElement().scope, function(key, value) {\n\t\t\tif (typeof value === 'function') {\n\t\t\t\treturn '[Function]';\n\t\t\t} else {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}, 2));\n\t\t\n\t\tif (realConsole.log(runner.stack.getLastStackElement().scope)) {\n\t\t\tlog('\\nNote: scope has also been printed to browser console.');\n\t\t}\n\t});\n\t\n\t$('#extra-stack').click(function(e) {\n\t\tclear();\n\t\tif (!runner.isStepping()) {\n\t\t\tlog('Not stepping...');\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor (var i=0; i<runner.stack.elements.length; i++) {\n\t\t\tvar element = runner.stack.elements[i].element;\n\t\t\tlog(element.type + ' @ line ' + element.startPos.line);\n\t\t}\n\t\t\n\t\tif (realConsole.log(runner.stack)) {\n\t\t\tlog('\\nNote: full stack has also been printed to browser console.');\n\t\t}\n\t});\n\t\n\t$('#extra-error').click(function(e) {\n\t\tclear();\n\t\tlog(JSON.stringify(runner.getError(), null, 2));\n\t\t\n\t\tif (realConsole.log(runner.getError())) {\n\t\t\tlog('\\nNote: error has also been printed to browser console.');\n\t\t}\n\t});\n\t\n\t$('#about').click(function(e) {\n\t\tclear();\n\t\tlog('This is a tool to become a good programmer. The primary objective is to teach programming in an engaging way. It can also give current programmers insights in what it is they are doing.');\n\t\tlog();\n\t\tlog('The programming language you program in is js--, a subset of Javascript. A lot of things allowed in Javascript are not allowed here, yet it is still quite an expressive language. The intention is to stimulate learning by giving meaningful error messages and sensible operations.');\n\t\tlog();\n\t\tlog('Most of the interface ideas presented in this and feature prototypes are stolen from Bret Victor. I share his belief that direct interaction and abstraction are very powerful concepts, both in programming and other fields. We should program and teach programming this way.');\n\t\tlog();\n\t\tlog('This is a first step, mostly to test the compiler, and verify that something like this is possible in the runner. Next on the roadmap are:');\n\t\tlog('* drawing on canvas');\n\t\tlog('* autocompletion');\n\t\tlog('* interactive programs (event handling, time-based)');\n\t\tlog('* direct value manipulation');\n\t\tlog('* up on the ladder of abstraction!');\n\t\tlog();\n\t\tlog('If you have any ideas, complaints, or suggestions about this prototype or its wider context, do not hesitate to mail me at me@janpaulposma.nl.');\n\t});\n*/\n\t\n\n\t/*\n\tvar canvas = document.getElementById('canvas');\n\tvar context = canvas.getContext('2d');\n\n\tvar myCanvas = {\n\t\tclear: function() {\n\t\t\t//$('#canvas').width($('#canvas').width());\n\t\t\tcontext.clearRect(0, 0, canvas.width, canvas.height);\n\t\t\tcontext = canvas.getContext('2d');\n\t\t\tcontext.beginPath();\n\t\t\tcontext.strokeStyle = \"#00dd00\";\n\t\t\tcontext.fillStyle = \"rgba(50, 250, 50, 0.4)\";\n\t\t},\n\t\tarc: function() {\n\t\t\tcontext.arc.apply(context, arguments);\n\t\t},\n\t\tbeginPath: function() {\n\t\t\tcontext.beginPath.apply(context, arguments);\n\t\t},\n\t\tclosePath: function() {\n\t\t\tcontext.closePath.apply(context, arguments);\n\t\t},\n\t\tfill: function() {\n\t\t\tcontext.fill.apply(context, arguments);\n\t\t},\n\t\tstroke: function() {\n\t\t\tcontext.stroke.apply(context, arguments);\n\t\t},\n\t\tclip: function() {\n\t\t\tcontext.clip.apply(context, arguments);\n\t\t},\n\t\tmoveTo: function() {\n\t\t\tcontext.moveTo.apply(context, arguments);\n\t\t},\n\t\tlineTo: function() {\n\t\t\tcontext.lineTo.apply(context, arguments);\n\t\t},\n\t\tarcTo: function() {\n\t\t\tcontext.arcTo.apply(context, arguments);\n\t\t},\n\t\tbezierCurveTo: function() {\n\t\t\tcontext.bezierCurveTo.apply(context, arguments);\n\t\t},\n\t\tquadraticCurveTo: function() {\n\t\t\tcontext.quadraticCurveTo.apply(context, arguments);\n\t\t},\n\t\trect: function() {\n\t\t\tcontext.rect.apply(context, arguments);\n\t\t}\n\t};\n\t*/\n});\n//@ sourceURL=/cli-widget.js"
));
require("/cli-widget.js");
